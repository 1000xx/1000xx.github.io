<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>专为32位单片机开发的轻量级OTA组件(开源)</title>
      <link href="/20230702/learn_ota/%E4%B8%93%E4%B8%BA32%E4%BD%8D%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7OTA%E7%BB%84%E4%BB%B6(%E5%BC%80%E6%BA%90).html"/>
      <url>/20230702/learn_ota/%E4%B8%93%E4%B8%BA32%E4%BD%8D%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7OTA%E7%BB%84%E4%BB%B6(%E5%BC%80%E6%BA%90).html</url>
      
        <content type="html"><![CDATA[<p>今天为大家分享一款专为 32 位 MCU 开发的 OTA 组件。组件包含了 bootloader 、固件打包器 (Firmware_Packager) 、固件发送器 三部分，并提供了基于多款 MCU (STM32F1 / STM32F407 / STM32F411 / STM32L4) 和 YModem-1K  协议的案例。</p><blockquote><p>该项目的开源地址：<code>https://gitee.com/DinoHaw/mOTA.git</code></p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>项目名称为 mOTA，m 可意为 mini 、 micro 、 MCU ( Microcontroller Unit )，而 OTA ( Over-the-Air Technology )，即空中下载技术，OTA 是一种为设备分发新软件、配置，乃至更新加密密钥（为例如移动电话、数字视频转换盒或安全语音通信设备——加密的双向无线电）的方法。<br>参考文章：<a href="/20230702/learn_ota/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0OTA%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86.html">嵌入式设备实现OTA升级的原理</a><br>OTA 的一项重要特征是，一个中心位置可以向所有用户发送更新，其不能拒绝、破坏或改变该更新，并且该更新为立即应用到频道上的每个人。用户有可能“拒绝” OTA 更新，但频道管理者也可以将其踢出频道。由此可得出 OTA 技术几个主要的特性：</p><ul><li>一个中心可向多个设备分发更新资料（固件）；</li><li>更新资料一旦发送便不可被更改；</li><li>设备可以拒绝更新；</li><li>中心可以排除指定的设备，使其不会接收到更新资料。</li></ul><p>本工程仅实现 OTA 更新资料的部分技术，即上文列出的 OTA 技术几个主要的特性，而不关心中心分发资料中间采用何种传输技术。（本工程的 example 使用 UART 作为 MCU 和外部的传输媒介）</p><h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>MCU 设备上的 OTA 升级可理解为 IAP (In Application Programming) 技术， MCU 通过外设接口（如 UART 、 IIC 、 SPI 、 CAN 、 USB 等接口），连接具备联网能力的模块、器件、设备（以下统称上位机）。上位机从服务器上拉取固件包，再将固件包以约定的通讯协议，经由通讯接口发送至 MCU ，由 MCU 负责固件的解析、解密、存储、更新等操作，以完成设备固件更新的功能。<br>本组件实现了以下功能：</p><ul><li>固件包完整性检查： 自动检测固件 CRC 值，保证固件数据的可靠性。</li><li>固件加密： 支持 AES256 加密算法，提高固件的安全性。</li><li>APP 完整性检查： 支持 APP 运行前进行完整性检查，以确认运行的固件无数据缺陷。</li><li>断电保护： 当固件更新过程中（含下载、解密、更新等过程），任何一个环节断电，设备再次上电时，依然能确保有可用的固件。（需配置为至少双分区）</li><li>固件水印检查： 可检测固件包是否携带了特殊的水印，确认非第三方或非匹配的固件包。</li><li>固件自动更新： 当 download 或 factory 分区有可用的固件，且 APP 分区为空或 APP 分区不是最新版本的固件时，可配置为自动开始更新。</li><li>恢复出厂设置： factory 分区存放稳定版的固件，当设备需要恢复出厂设置时，该固件会被更新至 APP 分区。</li><li>无须 deinit ： 我们知道，固件更新完毕后从 bootloader 跳转至 APP 前需要对所用的外设进行 deinit ，恢复至上电时的初始状态。本组件的 bootloader 包含了下载器的功能，当使用复杂的外设收取固件包时， deinit 也将变得复杂，甚至很难排除对 APP 的影响。为此，本组件采用了再入 bootloader 的方式，给 APP 提供一个相当于刚上电的外设环境，免去了 deinit 的代码。</li><li>功能可裁剪： 本组件通过功能裁剪可实现单分区、双分区、三分区的方案切换、是否配置解密组件、是否自动更新 APP 、是否检查 APP 完整性、 是否使用 SPI Flash （待实现） 。</li><li>固件存放至 SPI flash ： 本组件可通过 user_config.h 配置 download 分区和 factory 分区的所在位置为片内 flash 或 SPI flash ，使用了 SFUD (Serial Flash Universal Driver) 作为 SPI flash 的底层驱动库。若使用的 SPI flash 支持 SFDP (Serial Flash Discovable Parameters) ，则可在不修改任何源代码的情况下更换其它品牌型号的 SPI flash 。若不支持 SFDP ，SFUD 中已有对应 SPI flash 参数表的话，也可做到在不修改任何源代码的情况下更换其它品牌型号的 SPI flash 。</li></ul><h1 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h1><p><img src="/images/learn/ota/iK7gW0HHjiYsTV_5-wPY2g-001.png"></p><ul><li>硬件层描述的是运算器件和逻辑器件，如CPU、ADC、TIMER、各类IC等，是所有软件组件的硬件基础，是软件逻辑的最终底层实现。</li><li>硬件抽象层是位于驱动与硬件电路之间的接口层，将硬件抽象化。它隐藏了特定平台的硬件接口细节，为驱动层提供抽象化的硬件接口，使其具有硬件无关性。</li><li>驱动层通过调用硬件抽象层的开放接口，实现一定的逻辑功能后封装，提供给上层软件调用。</li><li>数据传输层负责收发数据，对外开放的是数据发送与接收相关的接口，屏蔽了通讯接口的逻辑代码，使其易于修改为其他类型的通讯接口。</li><li>协议析构层将调用数据传输层的数据收发接口进行封包发送与收包解析，通过实现用户的自定义协议，完成对数据的构造和解析。</li><li>应用层负责业务逻辑代码的实现，通过调用其他层封装的接口，完成顶层逻辑功能。</li></ul><p><img src="/images/learn/ota/iK7gW0HHjiYsTV_5-wPY2g-002.png"></p><h1 id="固件更新流程"><a href="#固件更新流程" class="headerlink" title="固件更新流程"></a>固件更新流程</h1><p>根据配置的分区方案不同，固件的更新流程会有些不同，此处仅展示简要的更新流程，便于快速理解固件更新的流程，因此屏蔽了很多细节，更详细的内容，请阅读《bootloader程序设计思路》文档和源代码。<br>本组件的目的是最大程度的减少 APP 的改动量以实现 OTA 的功能，从下图可知， bootloader 便完成了固件的下载、存放、校验、解密、更新等所有操作， APP 部分所需要做的有以下三件事。</p><ul><li>根据 bootloader 占用的大小和 flash 的最小擦除单位，重新设置 APP 的起始位置和中断向量表。</li><li>增加触发进入 bootloader 以开始固件更新的方式。（如：接收来自上位机的更新指令）</li><li>设置一个更新标志位，且这个标志位在 APP 软复位进入 bootloader 时仍能被读取到。（当固件更新的方式为上位机指令控制时，可以不执行此步骤）</li></ul><p><img src="/images/learn/ota/iK7gW0HHjiYsTV_5-wPY2g-003.png"></p><p>一般来说，通知 bootloader 需要进行固件更新的方式有以下两种：</p><ul><li>采用上位机指令控制的方式，优点是 APP 无须设置更新标志位，即便设备在收到更新指令后断电，也可以照常更新。缺点是设备在上电后， bootloader 需要等待几秒的时间（时间长短由通讯协议和上位机决定），以确认是否有来自上位机的更新指令，从而决定进入固件更新模式亦或跳转至 APP 。</li><li>APP 在软复位进入 bootloader 之前设置一个特殊的标志位，可以放置在 RAM 、备份寄存器或者外部的非易失性存储介质中（如：EEPROM）。此方式的优点是设备上电时 bootloader 无须等待和验证是否有固件更新的指令，通过标志位便可决定是否进入固件更新模式亦或跳转至 APP ，且利用再入 bootloader 的机制，可以给 APP 提供一个干净的外设环境。缺点则是 APP 和 bootloader 都要记录标志位所在的地址空间，且该地址空间不能被挪作他用，不能被意外修改，更不能被编译器初始化。相较于上个方案多了要专门指定该变量的地址并且不被初始化的步骤。若使用的是 RAM 作为记录标志位的介质，则还有断电后更新标志信息丢失的问题。</li></ul><p>综上所述，没有完美的方案。本组件支持上述方案二选一，根据实际需求进行选择和取舍即可。</p><h1 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h1><blockquote><p>可以自己从 gitee 仓库拉取下载。<br>附件下载 <a href="/downloads/code/mOTA-master.zip">mOTA-master.zip</a><br>附件下载 <a href="/downloads/code/mOTA-tools.zip">mOTA-tools.zip</a></p></blockquote><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><blockquote><p>文章来源于网络，版权归原作者所有，如有侵权，请联系删除。<br>原文：<a href="https://mp.weixin.qq.com/s/iK7gW0HHjiYsTV_5-wPY2g">https://mp.weixin.qq.com/s/iK7gW0HHjiYsTV_5-wPY2g</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OTA原理及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OTA </tag>
            
            <tag> BOOTLOAD </tag>
            
            <tag> 工程实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不升级版本也可以修复单片机的bug</title>
      <link href="/20230702/learn_ota/%E4%B8%8D%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BF%AE%E5%A4%8D%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84bug.html"/>
      <url>/20230702/learn_ota/%E4%B8%8D%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BF%AE%E5%A4%8D%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84bug.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在嵌入式产品开发中，难以避免地会因为各种原因导致最后出货的产品存在各种各样的BUG，通常会给产品进行固件升级来解决问题。</p><p>记得之前在公司维护一款BLE产品的时候，由于前期平台预研不足，OTA参数设置不当，导致少数产品出现不能OTA的情况，经过分析只需改变代码中的某个参数数值即可，但产品在用户手里，OTA是唯一能更新代码的方式，否则只能给用户重发产品。</p><p>后来再想，是否可以提前做好一个接口，支持动态地传输少量代码到产品中临时运行，通过修改特定位置的Flash代码数据来修复产品的棘手BUG？多留一个后门，有时候令产品出棘手问题的往往是那么一两行代码或者几个初始化的参数不对，那么这种方法也可以应应急，虽然操作比较骚。</p><h1 id="创建演示工程"><a href="#创建演示工程" class="headerlink" title="创建演示工程"></a>创建演示工程</h1><p>本文以STM32F103C8T6单片机为例创建演示工程，分为app和bootloader两个工程。即将mcu的Flash分为“app”和“bootloader”两个区域， bootloader放在0x8000000为起始的24KB区域内，app放在0x8006000为起始的后续区域。bootloader完成对app的Flash数据修改。</p><h2 id="app工程"><a href="#app工程" class="headerlink" title="app工程"></a>app工程</h2><p>注意app的工程需要在keil上修改ROM起始地址。<br><img src="/images/learn/ota/mnWV8tM0aKllddTf4HdoOw-001.jpg"><br>还要在app代码的开头设置向量偏移（调用一行代码）：<code>NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x6000);</code><br>app工程的逻辑为：先顺序执行3个不同速度的LED闪灯过程（20ms、200ms、500ms、切换亮灭），最后进入到一个循环状态每秒切换一次LED的状态闪烁。代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">init_led</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_All<span class="token punctuation">;</span>     GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>         GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>         <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">led_blings_1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">led_blings_2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">led_blings_3</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">NVIC_SetVectorTable</span><span class="token punctuation">(</span>NVIC_VectTab_FLASH<span class="token punctuation">,</span> <span class="token number">0x6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SysTick_Init</span><span class="token punctuation">(</span><span class="token number">72</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_led</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">led_blings_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">led_blings_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">led_blings_3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了分析汇编和查看bin文件数据，我们需要在keil中添加两条命令，分别生成.dis反汇编和.bin的代码文件。（具体的目录情况依葫芦画瓢）</p><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">fromelf --text -a -c --output&#x3D;all.dis Obj\Template.axffromelf --bin --output&#x3D;test.bin Obj\Template.axf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/learn/ota/mnWV8tM0aKllddTf4HdoOw-002.jpg"><br>先将app的代码烧写进单片机，注意烧写设置里面选择“Erase Sectors”只擦除需要烧写的地方。</p><h2 id="bootloader工程"><a href="#bootloader工程" class="headerlink" title="bootloader工程"></a>bootloader工程</h2><p>在bootloader中分为两部分，不变的代码部分和变动的代码部分（error_process函数）。初次编译的时候error_process写为空函数，当我们有需求对App进行修改的时候，我们重新编译工程对error_process函数进行填充。<br>为了重新编译工程的时候不影响之前函数的链接地址，特意将error_process函数放到代码区的最后0x8000800地址处，理由是原来工程大小是1.51KB，擦除页大小是2KB，所以需要2KB对齐，对齐处的地址就选择0x8000800为起始。<br>代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FLASH_PAGE_SIZE</span> <span class="token expression"><span class="token number">2048</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR_PROCESS_CODE_ADDR</span> <span class="token expression"><span class="token number">0x8000800</span></span></span><span class="token keyword">void</span> <span class="token function">error_process</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">section</span><span class="token punctuation">(</span><span class="token string">".ARM.__at_0x8000800"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init_led</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    <span class="token function">RCC_APB2PeriphClockCmd</span><span class="token punctuation">(</span>RCC_APB2Periph_GPIOB<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> GPIO_Pin_All<span class="token punctuation">;</span>     GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_Out_PP<span class="token punctuation">;</span>         GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>         <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token class-name">uint32_t</span> pageBuf<span class="token punctuation">[</span>FLASH_PAGE_SIZE <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">error_process</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">eraseErrorProcessCode</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">FLASH_Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FLASH_ClearFlag</span><span class="token punctuation">(</span>FLASH_FLAG_BSY <span class="token operator">|</span> FLASH_FLAG_EOP <span class="token operator">|</span>                     FLASH_FLAG_PGERR <span class="token operator">|</span> FLASH_FLAG_WRPRTERR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FLASH_ErasePage</span><span class="token punctuation">(</span>ERROR_PROCESS_CODE_ADDR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">FLASH_Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>boot_jump2App<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">boot_loadApp</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> addr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>vu32<span class="token operator">*</span><span class="token punctuation">)</span>addr<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x2FFE0000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0x20000000</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>        boot_jump2App <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>vu32<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>addr <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">__set_MSP</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>vu32<span class="token operator">*</span><span class="token punctuation">)</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            NVIC<span class="token operator">-></span>ICER<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">;</span>             NVIC<span class="token operator">-></span>ICPR<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>        <span class="token function">boot_jump2App</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> flag<span class="token punctuation">;</span>    <span class="token function">SysTick_Init</span><span class="token punctuation">(</span><span class="token number">72</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    flag <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>ERROR_PROCESS_CODE_ADDR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">!=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>flag <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">init_led</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span> GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">error_process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">eraseErrorProcessCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">boot_loadApp</span><span class="token punctuation">(</span><span class="token number">0x8006000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一进main函数就读取0x8000800地址处的32位数据，如果不是全F或者全0那么这个地方是有函数体存在需要执行的，那么将LED亮起2秒钟代表bootloader识别到有处理程序需要执行（当然这里还需要加一些error_process代码数据是否完整之类的判断机制，这里演示先略去）。<br>执行完处理程序后将处理程序擦除（数据变为全F），避免以后每次上电都重复擦写Flash。<br>error_process函数代码的数据由产品正常使用期间通过数据接口传入，直接写入到0x8000800处（这部分的demo略去），编译后查看生成的bin文件将error_process部分的代码截取出来传输到Flash地址0x8000800处。<br>bootloader的代码烧写进单片机时，注意烧写设置里面选择“Erase Sectors”只擦除需要烧写的地方。keil设置里ROM地址改回0x08000000。</p><h1 id="修改app的特定参数"><a href="#修改app的特定参数" class="headerlink" title="修改app的特定参数"></a>修改app的特定参数</h1><p>在app的工程中以“led_blings_1”函数为例，反汇编如下：</p><pre class="line-numbers language-MAP" data-language="MAP"><code class="language-MAP">$ti.led_blings_1led_blings_1    0x08006558:    b510        ..      PUSH     &#123;r4,lr&#125;    0x0800655a:    2400        .$      MOVS     r4,#0    0x0800655c:    e010        ..      B        0x8006580 ; led_blings_1 + 40    0x0800655e:    f44f6180    O..a    MOV      r1,#0x400    0x08006562:    4809        .H      LDR      r0,[pc,#36] ; [0x8006588] &#x3D; 0x40010c00    0x08006564:    f7fffea2    ....    BL       GPIO_SetBits ; 0x80062ac    0x08006568:    2014        .       MOVS     r0,#0x14    0x0800656a:    f7ffffaf    ....    BL       delay_ms ; 0x80064cc    0x0800656e:    f44f6180    O..a    MOV      r1,#0x400    0x08006572:    4805        .H      LDR      r0,[pc,#20] ; [0x8006588] &#x3D; 0x40010c00    0x08006574:    f7fffe98    ....    BL       GPIO_ResetBits ; 0x80062a8    0x08006578:    2014        .       MOVS     r0,#0x14    0x0800657a:    f7ffffa7    ....    BL       delay_ms ; 0x80064cc    0x0800657e:    1c64        d.      ADDS     r4,r4,#1    0x08006580:    2c0a        .,      CMP      r4,#0xa    0x08006582:    d3ec        ..      BCC      0x800655e ; led_blings_1 + 6    0x08006584:    bd10        ..      POP      &#123;r4,pc&#125;$d    0x08006586:    0000        ..      DCW    0    0x08006588:    40010c00    ...@    DCD    1073810432<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于led是20ms交替亮灭一次，如果我们觉得这个参数有问题想改成100ms，从汇编上来说就是要改变两行代码：</p><pre class="line-numbers language-MAP" data-language="MAP"><code class="language-MAP">0x08006568:    2014        .       MOVS     r0,#0x140x08006578:    2014        .       MOVS     r0,#0x14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>改为</code></pre><pre class="line-numbers language-MAP" data-language="MAP"><code class="language-MAP">0x08006568:    2064        2       MOVS     r0,#0x640x08006578:    2064        2       MOVS     r0,#0x64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>bootloader工程中error_process的函数实现如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void error_process(void)&#123;    #define MODIFY_FUNC_ADDR_START 0x08006558    uint32_t alignPageAddr &#x3D; MODIFY_FUNC_ADDR_START &#x2F; FLASH_PAGE_SIZE * FLASH_PAGE_SIZE;    uint32_t cnt, i;    &#x2F;&#x2F; 1. copy old code    memcpy(pageBuf, (void *)alignPageAddr, FLASH_PAGE_SIZE);    &#x2F;&#x2F; 2. change code.    &#x2F;&#x2F;由于Flash操作2KB页的特性，0x08006558不满2kb，因此偏移为0x558，0x558&#x2F;4&#x3D;342    pageBuf[90 + 256] &#x3D; (pageBuf[90 + 256] &amp; 0xFFFF0000) | 0x2064;    pageBuf[94 + 256] &#x3D; (pageBuf[94 + 256] &amp; 0xFFFF0000) | 0x2064;    &#x2F;&#x2F; 3. erase old code, copy new code.    FLASH_Unlock();    FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP |                     FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);    FLASH_ErasePage(alignPageAddr);    cnt &#x3D; FLASH_PAGE_SIZE &#x2F; 4;    for (i &#x3D; 0; i &lt; cnt; i++)    &#123;        FLASH_ProgramWord(alignPageAddr + i * 4, pageBuf[i]);    &#125;    FLASH_Lock();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于Flash的2KB页擦除特性，这里先将待修改代码区的Flash页数据拷贝到缓冲buffer里，然后修改buffer里的数据，之后擦除Flash相关页，最后将buffer里修改后的数据重新写回到Flash里去。error_process函数的反汇编如下：</p><pre class="line-numbers language-MAP" data-language="MAP"><code class="language-MAP">$t.ARM.__at_0x8000800error_process    0x08000800:    b570        p.      PUSH     &#123;r4-r6,lr&#125;    0x08000802:    4d1a        .M      LDR      r5,[pc,#104] ; [0x800086c] &#x3D; 0x8006000    0x08000804:    142a        *.      ASRS     r2,r5,#16    0x08000806:    4629        )F      MOV      r1,r5    0x08000808:    4819        .H      LDR      r0,[pc,#100] ; [0x8000870] &#x3D; 0x20000008    0x0800080a:    f7fffcbd    ....    BL       __aeabi_memcpy ; 0x8000188    0x0800080e:    4818        .H      LDR      r0,[pc,#96] ; [0x8000870] &#x3D; 0x20000008    0x08000810:    f8d00568    ..h.    LDR      r0,[r0,#0x568]    0x08000814:    f36f000f    o...    BFC      r0,#0,#16    0x08000818:    f2420164    B.d.    MOV      r1,#0x2064    0x0800081c:    4408        .D      ADD      r0,r0,r1    0x0800081e:    4914        .I      LDR      r1,[pc,#80] ; [0x8000870] &#x3D; 0x20000008    0x08000820:    f8c10568    ..h.    STR      r0,[r1,#0x568]    0x08000824:    4608        .F      MOV      r0,r1    0x08000826:    f8d00578    ..x.    LDR      r0,[r0,#0x578]    0x0800082a:    f36f000f    o...    BFC      r0,#0,#16    0x0800082e:    f2420164    B.d.    MOV      r1,#0x2064    0x08000832:    4408        .D      ADD      r0,r0,r1    0x08000834:    490e        .I      LDR      r1,[pc,#56] ; [0x8000870] &#x3D; 0x20000008    0x08000836:    f8c10578    ..x.    STR      r0,[r1,#0x578]    0x0800083a:    f7fffd53    ..S.    BL       FLASH_Unlock ; 0x80002e4    0x0800083e:    2035        5       MOVS     r0,#0x35    0x08000840:    f7fffcca    ....    BL       FLASH_ClearFlag ; 0x80001d8    0x08000844:    4628        (F      MOV      r0,r5    0x08000846:    f7fffccd    ....    BL       FLASH_ErasePage ; 0x80001e4    0x0800084a:    14ae        ..      ASRS     r6,r5,#18    0x0800084c:    2400        .$      MOVS     r4,#0    0x0800084e:    e007        ..      B        0x8000860 ; error_process + 96    0x08000850:    4a07        .J      LDR      r2,[pc,#28] ; [0x8000870] &#x3D; 0x20000008    0x08000852:    f8521024    R.$.    LDR      r1,[r2,r4,LSL #2]    0x08000856:    eb050084    ....    ADD      r0,r5,r4,LSL #2    0x0800085a:    f7fffd0d    ....    BL       FLASH_ProgramWord ; 0x8000278    0x0800085e:    1c64        d.      ADDS     r4,r4,#1    0x08000860:    42b4        .B      CMP      r4,r6    0x08000862:    d3f5        ..      BCC      0x8000850 ; error_process + 80    0x08000864:    f7fffcfe    ....    BL       FLASH_Lock ; 0x8000264    0x08000868:    bd70        p.      POP      &#123;r4-r6,pc&#125;$d    0x0800086a:    0000        ..      DCW    0    0x0800086c:    08006000    .&#96;..    DCD    134242304    0x08000870:    20000008    ...     DCD    536870920<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么这124个字节就是最终要传输到0x8000800处的函数数据。传输完毕后软复位mcu，bootloader将app的Flash数据进行篡改，达到改变程序功能的目的。<br>为什么要在bootloader运行时篡改app的数据？按理说在app运行时接收到error_process函数的更新数据后可以立刻运行，但是由于涉及到对app自身代码的修改，涉及Flash修改的一些相关函数有可能会被暂时破坏而导致代码运行崩溃。</p><h1 id="跳过app的某些函数"><a href="#跳过app的某些函数" class="headerlink" title="跳过app的某些函数"></a>跳过app的某些函数</h1><p>如果想跳过“led_blings_1”函数，有2种方法：</p><h2 id="函数内部跳过"><a href="#函数内部跳过" class="headerlink" title="函数内部跳过"></a>函数内部跳过</h2><p>即将以下汇编语句</p><pre class="line-numbers language-none"><code class="language-none">0x0800655a:    2400        .$      MOVS     r4,#0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>修改为</code></pre><pre class="line-numbers language-none"><code class="language-none">0x0800655a:    e013        .$      B             0x08006584<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在“led_blings_1”函数入口处指令修改直接跳转到函数出口处。至于汇编的机器码和用法文末有相关资料可以查阅。</p><p>因为修改处的字节偏移为0x55a，是pageBuf下标为342元素的高2Byte，需要在error_process函数中做如下修改：</p><pre class="line-numbers language-none"><code class="language-none">pageBuf[342] &#x3D; (pageBuf[342] &amp; 0x0000FFFF) | 0xe0130000;        <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="函数调用处跳过"><a href="#函数调用处跳过" class="headerlink" title="函数调用处跳过"></a>函数调用处跳过</h2><p>main函数汇编如下：</p><pre class="line-numbers language-MAP" data-language="MAP"><code class="language-MAP">$ti.mainmain    0x080065f8:    f44f41c0    O..A    MOV      r1,#0x6000    0x080065fc:    f04f6000    O..&#96;    MOV      r0,#0x8000000    0x08006600:    f7fffe5c    ..\.    BL       NVIC_SetVectorTable ; 0x80062bc    0x08006604:    2048        H       MOVS     r0,#0x48    0x08006606:    f7ffff01    ....    BL       SysTick_Init ; 0x800640c    0x0800660a:    f7ffff85    ....    BL       init_led ; 0x8006518    0x0800660e:    f7ffffa3    ....    BL       led_blings_1 ; 0x8006558    0x08006612:    f7ffffbb    ....    BL       led_blings_2 ; 0x800658c    0x08006616:    f7ffffd3    ....    BL       led_blings_3 ; 0x80065c0    0x0800661a:    e011        ..      B        0x8006640 ; main + 72    0x0800661c:    f44f6180    O..a    MOV      r1,#0x400    0x08006620:    4808        .H      LDR      r0,[pc,#32] ; [0x8006644] &#x3D; 0x40010c00    0x08006622:    f7fffe43    ..C.    BL       GPIO_SetBits ; 0x80062ac    0x08006626:    f44f707a    O.zp    MOV      r0,#0x3e8    0x0800662a:    f7ffff4f    ..O.    BL       delay_ms ; 0x80064cc    0x0800662e:    f44f6180    O..a    MOV      r1,#0x400    0x08006632:    4804        .H      LDR      r0,[pc,#16] ; [0x8006644] &#x3D; 0x40010c00    0x08006634:    f7fffe38    ..8.    BL       GPIO_ResetBits ; 0x80062a8    0x08006638:    f44f707a    O.zp    MOV      r0,#0x3e8    0x0800663c:    f7ffff46    ..F.    BL       delay_ms ; 0x80064cc    0x08006640:    e7ec        ..      B        0x800661c ; main + 36$d    0x08006642:    0000        ..      DCW    0    0x08006644:    40010c00    ...@    DCD    1073810432<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是调用语句：</p><pre class="line-numbers language-MAP" data-language="MAP"><code class="language-MAP">0x0800660e:    f7ffffa3    ....    BL       led_blings_1 ; 0x8006558<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接将此语句改为空语句nop（0xbf00）即可跳过调用，由于该命令占用4个字节，nop是两个字节的命令，所以替换为两个nop命令。</p><pre class="line-numbers language-MAP" data-language="MAP"><code class="language-MAP">0x0800660e:    bf00bf00    ....    NOP        <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为修改处的字节偏移为0x60e，是pageBuf下标为387元素的高2Byte和下标为388元素的低2Byte，需要在error_process函数中做如下修改：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">pageBuf<span class="token punctuation">[</span><span class="token number">387</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>pageBuf<span class="token punctuation">[</span><span class="token number">387</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x0000FFFF</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xbf000000</span><span class="token punctuation">;</span> pageBuf<span class="token punctuation">[</span><span class="token number">388</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>pageBuf<span class="token punctuation">[</span><span class="token number">388</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFF0000</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0x0000bf00</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><blockquote><p>文章来源于网络，版权归原作者所有，如有侵权，请联系删除。<br>来源： <a href="https://mp.weixin.qq.com/s/mnWV8tM0aKllddTf4HdoOw">https://mp.weixin.qq.com/s/mnWV8tM0aKllddTf4HdoOw</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OTA原理及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OTA </tag>
            
            <tag> BOOTLOAD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈单片机Boot的几种自刷新方式</title>
      <link href="/20230702/learn_ota/%E6%B5%85%E8%B0%88%E5%8D%95%E7%89%87%E6%9C%BABoot%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F.html"/>
      <url>/20230702/learn_ota/%E6%B5%85%E8%B0%88%E5%8D%95%E7%89%87%E6%9C%BABoot%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<p>汽车软件Boot程序的主要作用是刷新App程序。在一个具体客户项目中，Boot也是客户需求的一部分，跟随项目也有软件开发计划（有的为了和其它Boot区分，把项目上的Boot称作CB, Customer Boot）。<br>对于已经下线盒盖的控制器，无论是在供应商或者客户手里测试，只能通过CB刷新App。如果需要CB自刷新，就需要额外的方法。</p><h1 id="规范："><a href="#规范：" class="headerlink" title="规范："></a>规范：</h1><p>整车厂只有对App程序刷新的规范，没有对Boot自刷新的规范。因为规范是针对量产车的，售后只负责App程序的升级，不对Boot升级（也不允许Boot升级）。<br>所以，Boot的自刷新只存在于项目开发阶段，且由供应商自行提供方案。本文分析五种Boot自更新方式的优缺点。</p><h1 id="五种Boot自更新方式的分析"><a href="#五种Boot自更新方式的分析" class="headerlink" title="五种Boot自更新方式的分析"></a>五种Boot自更新方式的分析</h1><h2 id="方式一，SB更新CB："><a href="#方式一，SB更新CB：" class="headerlink" title="方式一，SB更新CB："></a>方式一，SB更新CB：</h2><p>如图1-a，有的软件架构是两级Boot：SB+CB，Start Boot只检查CPU最小系统，与具体项目的外围电路无关，它独立于客户需求，由供应商自行维护，在Pilot项目早期就应开发完成。因为程序启动顺序是SB-&gt;CB-&gt;App,这样在SB里增加刷新逻辑可以更新CB。通常情况下运行CB更新App程序，特殊情况下程序启动后一直停留在SB里，更新CB。</p><p><strong>优点</strong> ：</p><ol><li>逻辑结构简单清晰，软件分工明确。</li><li>一次刷新，操作简易。</li></ol><p><strong>缺点</strong> ：</p><ol><li>需要较大的Flash空间在SB里存放刷新逻辑，项目SOP后又要禁止这种刷新方式，造成额外的浪费。</li><li>软件分三级启动，结构复杂，开发和维护成本较高。对于不需要SB的控制器是一种负担。</li><li>万一SB也需要更新怎么办？按照这种策略，还得做个SSB？显然不现实。</li></ol><p><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-001.png"></p><h2 id="方式二、RAM-Flash-Reboot更新"><a href="#方式二、RAM-Flash-Reboot更新" class="headerlink" title="方式二、RAM+Flash Reboot更新"></a>方式二、RAM+Flash Reboot更新</h2><p>如图2-a，不存在SB情况下，程序启动顺序是CB-&gt;App。需要刷新Boot时，首先把Reboot程序下载到不用的RAM里（图2-b），然后在RAM环境下运行ReBoot,下载新的CB（图2-c）<br><strong>优点</strong> ：</p><ol><li>不需要额外的Flash空间，Boot程序运行只需要少量的RAM，因此为App设计的RAM临时可以保存Reboot程序。</li><li>RAM擦写速度很快，则下载ReBoot的速度会很快。</li></ol><p><strong>缺点</strong> ：</p><ul><li>在CB更新过程中万一CPU掉电，重新上电后Reboot内容全无，CB已经破损，程序不能正常启动，控制器瘫痪，只能开盖用JTAG烧写程序。</li></ul><p><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-002.png"></p><h2 id="方式三、RAM-RAM-ReBoot更新（对方式二的改进）"><a href="#方式三、RAM-RAM-ReBoot更新（对方式二的改进）" class="headerlink" title="方式三、RAM+RAM ReBoot更新（对方式二的改进）"></a>方式三、RAM+RAM ReBoot更新（对方式二的改进）</h2><p>首先把ReBoot（蓝色）+NewCB（紫色）一起都下载到RAM里（图3-a），然后运行ReBoot,擦除CB Flash区域，将RAM中NewCB复制到CB Flash区域（这一步内部完成）。最后，重新上电复位，RAM中的ReBoot和NewCB自动丢失，程序从新的CB开始运行。<br><strong>优点</strong> ：</p><ol><li>相比方式二少了一步刷新（因为ReBoot和CB是绑在一起的）。</li><li>相比方式二CB更新全部在CPU内部执行，不受外界干扰，耗时更短。</li></ol><p><strong>缺点</strong> ：</p><ol><li>相比方式二需要更大的RAM空间存储ReBoot+NewCB。</li><li>和方式二一样存在CB更新阶段掉电后控制器瘫痪的风险 。</li></ol><p><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-003.png"></p><h2 id="方式四、借助App程序Flash空间"><a href="#方式四、借助App程序Flash空间" class="headerlink" title="方式四、借助App程序Flash空间"></a>方式四、借助App程序Flash空间</h2><p>刷新分三步：1.图4-b运行CB，擦除App，把ReBoot下载到App区域。2.图4-c运行ReBoot,擦除旧CB，刷入新CB。3.图4-d运行新CB，刷回App。<br><strong>优点</strong> ：</p><ol><li>不需要额外的Flash和RAM资源。</li><li>稳定可靠，通过优化设计，可以保证在任何一个步骤突然掉电，上电后可以继续操作，控制器不会刷死。（详细设计方法请看附录）</li><li>对CB做稍微改造就可以成为Reboot程序，开发快速。</li></ol><p><strong>缺点</strong> ：</p><ol><li>步骤繁多，为了更新CB必须要先擦除App，最后恢复App，至少三次刷新。对不熟悉步骤的操作者容易搞混乱。</li><li>整体刷新时间会较长，两次Boot+一次App</li></ol><p><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-004.png"></p><h2 id="方式五、借助额外Flash空间"><a href="#方式五、借助额外Flash空间" class="headerlink" title="方式五、借助额外Flash空间"></a>方式五、借助额外Flash空间</h2><p>相比方式四，需要一块和CB一样大小的额外Flash空间，刷新分三步：</p><ul><li>图5-b, 运行CB，刷入ReBoot到额外Flash。</li><li>图5-c, 运行ReBoot，更新CB。</li><li>运行新的CB，破坏ReBoot（全部擦除，或只擦除ReBoot有效性标志）</li></ul><p><strong>优点</strong> ：</p><ul><li>相比方式四，不需要破坏App程序，也省去了这部分更新时间。</li></ul><p><strong>缺点</strong> ：</p><ul><li>相比方式四，需要额外的Flash空间，且必须是独立的Block。</li></ul><p><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-005.png"></p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>本质上只有三种：</p><ul><li>依赖启动程序SB（方式一），当CPU的Flash资源很富余且项目需要两级Boot时，用该方法最节省时间。</li><li>借助RAM（方式二、三）3.借助Flash（方式四、五）。只需要单级Boot（CB）时，可以容忍因Boot刷新瘫痪必须要给控制器开盖带来时间，人力，物力的成本损耗的情况下用方式二，三较方便。</li><li>只需要单级Boot（CB）时，不允许或不方便控制器开盖，但可以容忍Boot更新步骤繁多时间较长的情况下用方式四、五最可靠。</li></ul><p>综上，工程师需要根据整体软件架构，CPU资源，时间人力物料等成本因素综合考虑一种适合自己产品及项目的Boot自刷新方法。</p><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p>《Boot自刷新方式四（借助Flash）的具体实现方法》</p><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>对于方式四借助Flash刷新【不存在刷死风险，在任何一个步骤中控制器突然掉电，上电后可以继续操作。】的结论，是有条件的。笔者给出这个结论是从最理想的前提思考的，即只要控制器中至少有一个Boot存在（即使一个是坏的），程序就可以从任何一正常的Boot启动运行。这里就有一个问题，CPU怎么判断哪个Boot是好的，哪个是坏的？现在分析一下存在控制器刷死这种风险的情况和几种对策方案。</p><h1 id="两级启动地址介绍："><a href="#两级启动地址介绍：" class="headerlink" title="两级启动地址介绍："></a>两级启动地址介绍：</h1><p>如下图示，CPU上电后程序按地址顺序，检查BootSector的有效性，如果BOOT_ID合法则从指定的地址开始执行，否则检查下一个BootSector。<br><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-006.png"><br>考虑CPU至少具备两个启动地址的情况，如图1-a,当且仅当启动地址1有效时（App为空），程序启动后自动进入Boot。如图1-b,当且仅当启动地址2有效时（不带Boot测试），程序启动后自动进入App。如图1-c，当启动地址1，2都有效时，程序优先从地址1启动，在Boot里检查App程序有效时，再靠跳转指令Jump到启动地址2，开始运行App。<br><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-007.png"><br><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-008.png"></p><h1 id="方式四控制器刷死情况分析："><a href="#方式四控制器刷死情况分析：" class="headerlink" title="方式四控制器刷死情况分析："></a>方式四控制器刷死情况分析：</h1><p>如图 2-a，运行Reboot更新CB途中断电。重新上电后，如图2-b，由于启动地址1的内容是在刷新开始就被更新了是有效的，程序会进入CB运行，但是CB不完整，必然运行出错，程序不会跳入ReBoot里，从而不能再刷新（即刷死）。假设从擦除完旧CB开始到刷入新CB完成的时间有10S，在此期间掉电的可能性也不能忽略。<br><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-009.png"></p><h2 id="对策一、Boot有效性标志与启动地址重合"><a href="#对策一、Boot有效性标志与启动地址重合" class="headerlink" title="对策一、Boot有效性标志与启动地址重合"></a>对策一、Boot有效性标志与启动地址重合</h2><p>考虑最普遍情况，CPU只能整块（Block）的擦除（16K,32K,64K…），可以最少4字节单位写，没有顺序限制，现在CB只用了一个Block。现在调整刷新顺序：擦出成功后，先刷新橙色区域，最后一步刷新启动地址1有效性标志（灰色区域）。这样，即使在更新橙色区域过程中掉电。<br>重新上电后，程序依然从启动地址2开始运行，即重新运行Reboot继续等待刷新CB指令，如图3-a所示。具体操作时也不需要更改下载流程，使用$34,36服务按顺序从上位机传输数据到CPU中，先把启动地址1的有效性标志放到RAM里，当把橙色区域都下载到Flash后，再从RAM里把启动地址1的有效性标志写到Flash里（这一步10ms以内即可完成，完全可以忽略在此时间内掉电的可能性）<br>如果最后一步启动地址1刷新成功，再重新上电后，程序从启动地址1开始运行新的Boot。即启动地址1起了Boot有效性标志的作用（最先擦，最后写），如图3-b所示。<br><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-010.png"></p><h2 id="对策二、Boot有效性标志独立置尾，增加Boot有效性检查逻辑"><a href="#对策二、Boot有效性标志独立置尾，增加Boot有效性检查逻辑" class="headerlink" title="对策二、Boot有效性标志独立置尾，增加Boot有效性检查逻辑"></a>对策二、Boot有效性标志独立置尾，增加Boot有效性检查逻辑</h2><p>如图4-a,把Boot分成2个段，Sec1里仅存放少量的启动自检查逻辑，当它检测到置于Sec2末尾的CB_ValidFlg无效时，即认为Boot是不完整的，则程序控制跳转到启动地址2继续运行ReBoot，重新刷新Boot。<br>如图4-b,当Sec1的逻辑检测到CB_ValidFlg有效时，即认为Boot刷新完成，则程序控制跳转入Sec2里，此时由于App(ReBoot)末尾的App_ValidFlg是无效的，程序并不会跳转入ReBoot里，接下来就可以刷入新的App了。<br>这种方法只需要对CB的逻辑和段分配做一下调整，不需要更改刷新顺序。Sec1里的启动自检查逻辑可以做的尽量小，则只要保证刷新Sec1段的过程中不掉电，控制器就不会刷死，大大降低风险。但是对量产软件，检查CB_ValidFlg无效就直接跳转入App是不合理的，所以当Boot最终定型后，应该把这个跳转逻辑关闭。<br><img src="/images/learn/ota/2dmMb9acJ6jdK96gVWk7eA-011.png"></p><h2 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h2><p>对策一简单可靠，经过实际测试验证，完全可以满足稳定刷新ECU的要求。</p><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><blockquote><p>文章来源于网络，版权归原作者所有，如有侵权，请联系删除。<br>原文：<a href="https://mp.weixin.qq.com/s/2dmMb9acJ6jdK96gVWk7eA">https://mp.weixin.qq.com/s/2dmMb9acJ6jdK96gVWk7eA</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OTA原理及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OTA </tag>
            
            <tag> BOOTLOAD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机通过 UART 实现 OTA 升级的详细流程</title>
      <link href="/20230702/learn_ota/%E5%8D%95%E7%89%87%E6%9C%BA%E9%80%9A%E8%BF%87%20UART%20%E5%AE%9E%E7%8E%B0%20OTA%20%E5%8D%87%E7%BA%A7%E7%9A%84%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B.html"/>
      <url>/20230702/learn_ota/%E5%8D%95%E7%89%87%E6%9C%BA%E9%80%9A%E8%BF%87%20UART%20%E5%AE%9E%E7%8E%B0%20OTA%20%E5%8D%87%E7%BA%A7%E7%9A%84%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<p>OTA升级已经不是什么新鲜事，现在大多数物联网终端设备，基本具备这个功能。<br>之前分享过一篇 OTA 升级原理的文章：<a href="/20230702/learn_ota/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0OTA%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86.html">嵌入式设备实现OTA升级的原理</a>。<br>今天以 AT32 为例给大家分享一下 OTA 升级的详细流程。 </p><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>空中下载技术 OTA（Over-the-Air Technology）是用户自己的程序在运行过程中对 User Flash 的部分区域进行烧写，目的是为了在产品发布后可以方便地通过预留的通信口，对产品中的固件程序进行更新升级。</p></blockquote><p>通常实现 OTA 功能时，即用户程序运行中作自身的更新操作，需要在设计固件程序时编写两个项目代码，第一个项目程序为 Bootloader 区域，第二个项目程序 App 代码为真正的功能代码，执行应用和升级。这两部分项目代码同时烧录在 User Flash 中。<br><img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-001.jpg" alt="图1. OTA代码执行流程"></p><p>在上图所示流程中，MCU复位后，从 0x08000004 地址取出复位中断向量的地址，并跳转到复位中断服务程序，在运行完复位中断服务程序之后跳转到 Bootloader 的 main函数，如图标号①所示；<br>在执行完 Bootloader 以后（App 代码为图中 FLASH 灰底部分 App 程序的复位中断向量起始地址为 0x08000004+N+M），跳转至 App 程序的复位向量表，取出 App 程序的复位中断向量的地址，并跳转执行 App 程序的复位中断服务程序，随后跳转至 App 程序的main函数，如图标号②和③所示，同样 main 函数为一个死循环，并且注意到此时 AT32 的 FLASH，在不同位置上，共有两个中断向量表。<br>在 main 函数执行过程中，如果 CPU 得到一个中断请求，PC 指针仍强制跳转到地址0x08000004 中断向量表处，而不是 App 程序的中断向量表，如图标号④所示；<br>程序再根据我们设置的中断向量表偏移量，跳转到对应中断源的中断服务程序中，如图标号⑤所示；<br>在执行完中断服务程序后，程序返回 main 函数继续运行，如图标号⑥所示。<br>通过以上两个过程的分析，我们知道OTA程序必须满足两个要求：</p><ol><li>App 程序必须在 Bootloader 程序之后的某个偏移量为 x 的地址开始。</li><li>必须将 App 程序的中断向量表进行相应的移动，移动的偏移量为 x。</li></ol><hr><h1 id="AT32-USART-OTA-快速使用方法"><a href="#AT32-USART-OTA-快速使用方法" class="headerlink" title="AT32 USART OTA 快速使用方法"></a>AT32 USART OTA 快速使用方法</h1><h2 id="硬件资源"><a href="#硬件资源" class="headerlink" title="硬件资源"></a>硬件资源</h2><p>文档中是用 AT-START-AT32F403A 实验板的硬件条件为例，OTA demo 源代码还包括AT32 其他型号，用户只需编译对应型号工程烧录于 AT-START 实验板运行即可。</p><ul><li>指示灯 LED2/LED3/LED4</li><li>USART1（PA9/PA10）</li><li>AT-START 实验板</li></ul><h2 id="软件资源"><a href="#软件资源" class="headerlink" title="软件资源"></a>软件资源</h2><ul><li>tool_release<ul><li>IAP_Programmer.exe，PC 机 tool，用于演示 OTA 升级流程</li></ul></li><li>source_code<ul><li>Bootloader，Bootloader 源程序，运行 LED2 闪烁</li><li>App_led3_toggle，App1 源程序，运行 LED3 闪烁</li><li>App_led4_toggle，App2 源程序，运行 LED4 闪烁</li></ul></li></ul><blockquote><p>注：工程基于keil v5建立，若用户需要在其他编译环境上使用，请参考对应 BSP 目录<code>AT32F403A_407_Firmware_Library_V2.x.x\project\at_start_f403a\templates</code>中各种编译环境（例如IAR6/7/8,keil 4/5,eclipse_gcc）进行对应修改即可。 </p></blockquote><h2 id="OTA-Demo-使用"><a href="#OTA-Demo-使用" class="headerlink" title="OTA Demo 使用"></a>OTA Demo 使用</h2><p>本文档描述了两种常用的 OTA 应用 demo，template app 和 dual app，后面章节会分别介绍。</p><ol><li>打开 Bootloader 工程源程序，选择对应 MCU 型号的 target 编译后下载到实验板</li><li>打开 IAP_Programmer.exe</li><li>选择正确的串口、APP下载地址和 bin 文档，点击 Download 下载，如下图</li><li>观察 LED2/3/4 闪烁，LED2 闪烁-Bootloader 工作，LED3 闪烁-App1 工作，LED4 闪烁-App2 工作<br><img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-002.jpg" alt="图2. IAP demo上位机"></li></ol><hr><h1 id="Template-app-OTA-程序设置"><a href="#Template-app-OTA-程序设置" class="headerlink" title="Template app OTA 程序设置"></a>Template app OTA 程序设置</h1><h2 id="地址分布"><a href="#地址分布" class="headerlink" title="地址分布"></a>地址分布</h2><p><img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-003.jpg" alt="图3. Flash地址分配"></p><p>注：Bootloader区域最后一个扇区，用于存放防止升级过程出错（掉电等异常情况）的flag，用户编译修改Bootloader时，要保证不覆盖flag的地址。</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>OTA 分为 Bootloader、App 和 Template 三部分，应用在 App 中执行，Template 仅作为新 App 固件数据的临时存放空间。程序执行整体流程框图如下：<br><img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-004.jpg" alt="图4. 程序执行流程"></p><h2 id="Bootloader-project-设置"><a href="#Bootloader-project-设置" class="headerlink" title="Bootloader project 设置"></a>Bootloader project 设置</h2><h3 id="Keil-设置"><a href="#Keil-设置" class="headerlink" title="Keil 设置"></a>Keil 设置</h3><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-005.jpg" alt="图5. Bootloader project中address 1在Keil设置"></p><h3 id="Bootloader-源程序修改-ota-h-文件中"><a href="#Bootloader-源程序修改-ota-h-文件中" class="headerlink" title="Bootloader 源程序修改 ota.h 文件中"></a>Bootloader 源程序修改 ota.h 文件中</h3><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-006.jpg" alt="图6. Bootloader project中address 2在程序中设置"></p><h2 id="App-project-设置"><a href="#App-project-设置" class="headerlink" title="App project 设置"></a>App project 设置</h2><p>OTA demo 提供了 2 个 App 程序供测试用，皆以 address 2（0x800 4000）为起始地址。App1 LED3 闪烁，App2 LED4 闪烁。以 App1 为例，设计步骤如下：</p><h3 id="Keil工程设置"><a href="#Keil工程设置" class="headerlink" title="Keil工程设置"></a>Keil工程设置</h3><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-007.jpg" alt="图7. App project中address 2在Keil设置"></p><h3 id="App1-源程序设置"><a href="#App1-源程序设置" class="headerlink" title="App1 源程序设置"></a>App1 源程序设置</h3><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-008.jpg" alt="图8. App project向量表偏移在程序中设置"></p><h3 id="编译生成bin文件"><a href="#编译生成bin文件" class="headerlink" title="编译生成bin文件"></a>编译生成bin文件</h3><p>   通过 User 选项卡，设置编译后调用 fromelf.exe，根据 .axf 文件生成 .bin 文件，用于 OTA 更新。通过以上3个步骤，我们就可以得到一个 .bin 的 APP 程序，通过 Bootloader 程序即可实现更新。</p><h3 id="开启debug-app-code功能"><a href="#开启debug-app-code功能" class="headerlink" title="开启debug app code功能"></a>开启debug app code功能</h3><p>   如果在设计 App code 过程中需要对 App project 进行单独调试，请按照以下操作。<br>   先下载 Bootloader 工程, 再调试 App 工程</p><h1 id="Dual-app-OTA-与程序设置"><a href="#Dual-app-OTA-与程序设置" class="headerlink" title="Dual app OTA 与程序设置"></a>Dual app OTA 与程序设置</h1><p>地址分布<br><img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-009.jpg" alt="图9. Flash地址分配"></p><blockquote><p>注：Bootloader 区域最后2个扇区，用于存放 App 是否正常的 flag，用户编译修改Bootloader 时，要保证不覆盖 flag 的地址。 </p></blockquote><h2 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h2><p>OTA 分为 Bootloader、App1 和 App2 三部分，应用在 App1 或 App2 中执行。程序执行整体流程框图如下：<br><img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-010.jpg" alt="图10. 程序执行流程"></p><h2 id="Bootloader-project-设置-1"><a href="#Bootloader-project-设置-1" class="headerlink" title="Bootloader project 设置"></a>Bootloader project 设置</h2><h3 id="Keil-设置-1"><a href="#Keil-设置-1" class="headerlink" title="Keil 设置"></a>Keil 设置</h3><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-011.jpg" alt="图11. Bootloader project中address 1在Keil设置"></p><h3 id="Bootloader-源程序修改-ota-h-文件中-1"><a href="#Bootloader-源程序修改-ota-h-文件中-1" class="headerlink" title="Bootloader 源程序修改 ota.h 文件中"></a>Bootloader 源程序修改 ota.h 文件中</h3><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-012.jpg" alt="图12. Bootloader project中address 2在程序中设置"></p><h2 id="App-project-设置-1"><a href="#App-project-设置-1" class="headerlink" title="App project 设置"></a>App project 设置</h2><p>OTA demo 提供了 2 个 App 程序供测试用，app_led3_toggle 以 0x800 4000 为起始地址，app_led4_toggle 以 0x8080000 为起始地址。App1 LED3 闪烁，App2 LED4闪烁。以 App1 为例，设计步骤如下：</p><h3 id="Keil工程设置-1"><a href="#Keil工程设置-1" class="headerlink" title="Keil工程设置"></a>Keil工程设置</h3><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-013.jpg" alt="图13. App project中address 2在Keil设置"></p><h3 id="App1源程序设置"><a href="#App1源程序设置" class="headerlink" title="App1源程序设置"></a>App1源程序设置</h3><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-014.jpg" alt="图14. App project向量表偏移在程序中设置"></p><h3 id="编译生成bin文件-1"><a href="#编译生成bin文件-1" class="headerlink" title="编译生成bin文件"></a>编译生成bin文件</h3><p>   通过User选项卡，设置编译后调用fromelf.exe，根据.axf文件生成.bin文件，用于OTA更新。通过以上3个步骤，我们就可以得到一个.bin的APP程序，通过Bootloader程序即可实现更新。</p><h3 id="开启debug-App-code功能"><a href="#开启debug-App-code功能" class="headerlink" title="开启debug App code功能"></a>开启debug App code功能</h3><p>   如果在设计App code过程中需要对App project进行单独调试，请按照以下操作。</p><p>先下载Bootloader工程, 再调试App工程</p><hr><h1 id="Bootloader-App与上位机串口通信协议"><a href="#Bootloader-App与上位机串口通信协议" class="headerlink" title="Bootloader/App与上位机串口通信协议"></a>Bootloader/App与上位机串口通信协议</h1><p>程序与上位机通信，接收固件升级数据，上位机端和嵌入式端通信协议如下：</p><h2 id="上位机通信协议"><a href="#上位机通信协议" class="headerlink" title="上位机通信协议"></a>上位机通信协议</h2><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-015.png" alt="图15. 上位机通信协议"></p><h2 id="嵌入式端下位机通信协议"><a href="#嵌入式端下位机通信协议" class="headerlink" title="嵌入式端下位机通信协议"></a>嵌入式端下位机通信协议</h2><p>   <img src="/images/learn/ota/E02SuyeGwleLKnqi6CY6lA-016.png" alt="图16. 下位机通信协议"></p><p>注：</p><blockquote><p>ACK：0xCCDD<br>NACK：0xEEFF<br>Data：0x31+Addr+数据+chenksum（1byte）<br>Addr：4bytes，高位在前<br>2Kbytes，下载数据，不足2K内容填充0xFF<br>Checksum：1byte，4bytes的Addr+2KBytes数据的校验和的低八位</p></blockquote><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><blockquote><p>文章来源于网络，版权归原作者所有，如有侵权，请联系删除。<br>来源： <a href="https://mp.weixin.qq.com/s/E02SuyeGwleLKnqi6CY6lA">https://mp.weixin.qq.com/s/E02SuyeGwleLKnqi6CY6lA</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OTA原理及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OTA </tag>
            
            <tag> BOOTLOAD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式设备差分升级原理和实现</title>
      <link href="/20230702/learn_ota/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%B7%AE%E5%88%86%E5%8D%87%E7%BA%A7%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0.html"/>
      <url>/20230702/learn_ota/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%B7%AE%E5%88%86%E5%8D%87%E7%BA%A7%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是差分-增量升级"><a href="#什么是差分-增量升级" class="headerlink" title="什么是差分/增量升级"></a>什么是差分/增量升级</h1><p>借用网上的介绍：适合嵌入式的差分升级又叫增量升级，顾名思义就是通过差分算法将源版本与目标版本之间差异的部分提取出来制作成差分包，然后在设备端通过还原算法将差异部分在源版本上进行还原，从而升级成目标版本的过程。<br>差分升级方案不仅可以节省MCU内部的资源空间、还可以节省下载流程及下载和升级过程中的功耗。<br>也就是说，差分升级是拿以前旧设备内的bin，和当前新版本的bin用某种算法算出他们的差异部分，然后在借助压缩算法，生产一个极其小的差分包，然后将这个差分包下载到设备中，设备在根据解压算法、差分还原算法，生产一个完整的新版本bin，然后将这个新版本bin刷到执行区执行代码。<br>差分升级一般来说，可以极大的减少下载量，特别是对于嵌入式STM32等单片机来说，可以极大的减少维护成本，因为嵌入式设备的升级维护一般都是空中ota升级，比如蓝牙、红外等，下载速度受到波特率、包长等限制，更新固件包非常的慢，而差分升级可以让下载的过程极大的缩小。<br>正常的维护版本，即使改的再多，生成的差分包bin理论上在原bin的5%左右，比如一个300k的bin，改的很多的情况下差分包也不过15k左右，而我实际测试，版本维护平均都在5~10k左右。</p><h1 id="差分升级实现原理"><a href="#差分升级实现原理" class="headerlink" title="差分升级实现原理"></a>差分升级实现原理</h1><p>差分升级过程：<br>1 使用旧版本bin文件和新版本bin文件制作差分包<br>2 将差分包下载到设备内<br>3 设备使用差分算法还原出新版本bin<br>4 设备将新版本bin进行crc验证后刷到代码执行区<br>5 设备重启并以新版本运行</p><p>在过程中有2个关键点：<br>第一：如何使用旧版本bin文件和新版本bin文件制作差分包？</p><blockquote><p>该过程我们使用稳定的开源差分算法 bsdiff+lzma 生成差分包，该算法被大量使用，稳定安全，并且我们已在项目中批量使用，经过长时间的验证无任何问题。一般来说，该过程都是使用上位机来完成，嵌入式设备无需关心，我们已经做好了上位机软件，可以供大家随意使用，稍后会进行介绍。</p></blockquote><p>第二：设备收到差分包后如何还原出新版本的bin文件？</p><blockquote><p>该过程就是我们要讲解的重点过程，相对应的，嵌入式设备中，我们依然使用开源差分算法 bsdiff+lzma 来还原新版本文件，代码全开源，并且我已做成了库、抽象出了极简的接口，移植起来费不了多少功夫。</p></blockquote><p>基本是市场上所有的单片机如stm32、瑞萨、华大、复旦微等都可以使用，但是有内存限制，要求ram至少要10k以上，然后是该库本身的消耗大概是5k的rom。</p><h1 id="关键点一：差分包制作过程"><a href="#关键点一：差分包制作过程" class="headerlink" title="关键点一：差分包制作过程"></a>关键点一：差分包制作过程</h1><p>对于差分包的制作，我已经开发好了上位机软件，界面如下图所示：<br><img src="/images/learn/ota/BSw1jQvqVbaqk-T4Dn8QJg-001.png"><br>上位机这边主要实现使用开源算法bsdiff制作旧版本bin和新版本bin的差分包，然后在使用lzma压缩算法来压缩差分包，最终生成一个差分bin，使用方法上位机界面提示的很清楚，最终效果如下图所示：<br><img src="/images/learn/ota/BSw1jQvqVbaqk-T4Dn8QJg-002.png"></p><p>下载链接：</p><blockquote><p>链接: <code>https://pan.baidu.com/s/1nBpftim8OCUI3i32sP3eOA?pwd=diff</code><br>提取码：diff</p></blockquote><h1 id="关键点二：嵌入式设备中差分算法库的移植-还原差分包"><a href="#关键点二：嵌入式设备中差分算法库的移植-还原差分包" class="headerlink" title="关键点二：嵌入式设备中差分算法库的移植(还原差分包)"></a>关键点二：嵌入式设备中差分算法库的移植(还原差分包)</h1><h2 id="移植开关算法库代码"><a href="#移植开关算法库代码" class="headerlink" title="移植开关算法库代码"></a>移植开关算法库代码</h2><p>代码已开源，地址：</p><blockquote><p><code>https://gitee.com/qq791314247/mcu_bsdiff_upgrade</code></p></blockquote><p>整体代码如下图所示：<br><img src="/images/learn/ota/BSw1jQvqVbaqk-T4Dn8QJg-003.png"><br>如上图所示，99%的代码用户都不用去关心，用户只需要提供一个flash写入接口即可，也就是该库给定用户flash地址、数据内容指针、数据内容长度，用户将该段数据写入到flash即可，移植起来特别简单，花不了几分钟的功夫，这也是我花大力气抽象接口的原因。</p><h2 id="使用该库的流程"><a href="#使用该库的流程" class="headerlink" title="使用该库的流程"></a>使用该库的流程</h2><h3 id="使用库的接口"><a href="#使用库的接口" class="headerlink" title="使用库的接口"></a>使用库的接口</h3><p>对于整个库的代码，我们只需要关心一个接口iap_patch，iap_patch在文件”user_interface.h”中。<br><img src="/images/learn/ota/BSw1jQvqVbaqk-T4Dn8QJg-004.png"></p><p>该接口介绍也比较清晰，差分包的还原，只需要调用这一个接口即可。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;** * @brief 用户使用差分升级时唯一需要关心的接口 *  * @param old 设备中执行区代码所在的地址，用户可指定flash执行区的地址，方便算法读出来当前 *      运行中的代码 * @param oldsize 设备中执行区代码的长度，用户可在差分包bin头获取 * @param patch 设备中已经下载的差分包所在的flash地址，或者ram地址，只要能让算法读出来即可 *        注意，下载的差分包自带image_header_t格式的文件头，真正的差分包需要偏 *        移sizeof(image_header_t)的长度 * @param patchsize 设备中已经下载的差分包的长度，用户可在差分包bin头获取 * @param newfile 新文件的大小，用户需填入新版本bin的长度，用户亦可以差分包bin头获取 * @return int 然后错误码，0成功，1失败 *&#x2F;extern int iap_patch(const uint8_t* old, uint32_t oldsize, const uint8_t* patch, uint32_t patchsize, uint32_t newfile); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另外，使用该接口还原时所需要的一些信息可以在差分包文件头中获取，上位机在制作差分包时，会自动在差分包的bin头加上64字节的文件头，以便于告诉嵌入式设备旧/新版本bin文件的CRC校验、长度等信息。所以用户在收到差分包头时，偏移掉这64个字节的文件头的地址才是需要给到iap_patch接口的真正的bin文件。</p><p>文件头格式如下代码，用户只需要关心中文注释的部分，其余的都是预留的信息。</p><p>/* 差分包制作时自带的文件头信息，用户只需要关心中文注释的部分 */</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct image_header&#123;  uint32_t ih_magic; &#x2F;* Image Header Magic Number *&#x2F;  uint32_t ih_hcrc;  &#x2F;* Image Header CRC Checksum 差分包包头校验 *&#x2F;  uint32_t ih_time;  &#x2F;* Image Creation Timestamp *&#x2F;  uint32_t ih_size;  &#x2F;* Image Data Size 差分包的大小 *&#x2F;  uint32_t ih_load;  &#x2F;* Data Load Address 上一版本旧文件的大小 *&#x2F;  uint32_t ih_ep;   &#x2F;* Entry Point Address 要升级的新文件的大小 *&#x2F;  uint32_t ih_dcrc;  &#x2F;* Image Data CRC Checksum 新文件的CRC *&#x2F;  uint8_t ih_os;   &#x2F;* Operating System *&#x2F;  uint8_t ih_arch;  &#x2F;* CPU architecture *&#x2F;  uint8_t ih_type;  &#x2F;* Image Type *&#x2F;  uint8_t ih_comp;  &#x2F;* Compression Type *&#x2F;  uint8_t ih_name[IH_NMLEN]; &#x2F;* Image Name *&#x2F;  uint32_t ih_ocrc;  &#x2F;* Old Image Data CRC Checksum 上一版本旧文件的CRC *&#x2F;&#125; image_header_t; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> /* 差分包制作时自带的文件头信息，用户只需要关心中文注释的部分 */<br>4.2.2. 接口使用例子<br>我截取一段我工程中的代码来讲解如何使用该接口还原出新版本bin文件：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef BSDIFF_UPGRADE    image_header_t recv_head;    uint32_t recv_hcrc;  &#x2F;* 接收到的文件头CRC *&#x2F;    uint32_t calculation_crc;  &#x2F;* 计算出来的文件头CRC *&#x2F;    uint32_t spi_flash_addr &#x3D; UPGRADE_PROGRAM_ADDR;    memcpy(&amp;recv_head, (uint8_t *)APPLICATION_A, sizeof(image_header_t));    recv_hcrc &#x3D; BigtoLittle32(recv_head.ih_hcrc);    recv_head.ih_hcrc &#x3D; 0;    calculation_crc &#x3D; crc32((uint8_t *)&amp;recv_head, sizeof(image_header_t));    if (recv_hcrc &#x3D;&#x3D; calculation_crc)    &#123;      recv_head.ih_hcrc &#x3D; recv_hcrc;      recv_head.ih_time &#x3D; BigtoLittle32(recv_head.ih_time);      recv_head.ih_size &#x3D; BigtoLittle32(recv_head.ih_size);      recv_head.ih_dcrc &#x3D; BigtoLittle32(recv_head.ih_dcrc);      recv_head.ih_ocrc &#x3D; BigtoLittle32(recv_head.ih_ocrc);      &#x2F;* 差分升级包 *&#x2F;      recv_head.ih_hcrc &#x3D; calculation_crc;      if (crc32((uint8_t *)APPLICATION_RUN, recv_head.ih_load) !&#x3D; recv_head.ih_ocrc)      &#123;       APP_ERR_PRINT(&quot;file oldcrc err,calcrc:0X%08X, ih_oldbin_crc:0X%08X,&quot;,                     crc32((uint8_t *)APPLICATION_RUN,                     recv_head.ih_load), recv_head.ih_ocrc);       goto bsdiff_out;      &#125;      RTOS_LOCK();      disable_task_monitoring(ALL_TASK_RUNFLAG_BIT, true);      &#x2F;&#x2F; flash_erase_sector(UPGRADE_PROGRAM_ADDR, UPGRADE_PROGRAM_PAGE);      recv_hcrc &#x3D; iap_patch((uint8_t *)APPLICATION_RUN, recv_head.ih_load,                (uint8_t *)(APPLICATION_A + sizeof(image_header_t)),                 recv_head.ih_size, UPGRADE_PROGRAM_ADDR);      if (recv_hcrc !&#x3D; recv_head.ih_ep)      &#123;       APP_ERR_PRINT(&quot;iap_patch len err.&quot;);       APP_ERR_PRINT(&quot;iap_patch len: %lu, new_len: %lu&quot;, recv_hcrc, recv_head.ih_ep);       goto bsdiff_out;      &#125;      if (erase_program(APPLICATION_A))      &#123;       APP_ERR_PRINT(&quot;I erase program failed.&quot;);       goto bsdiff_out;      &#125;      current_flash_write_addr &#x3D; APPLICATION_A;      for (uint32_t i &#x3D; 0; i &lt; (recv_head.ih_ep &#x2F; 1024); i++)      &#123;       xmq25qxx_read(spi_flash_addr, spi_read_cache, 1024);       if (xflash_write(current_flash_write_addr, spi_read_cache, 1024))       &#123;         APP_ERR_PRINT(&quot;I write program failed.&quot;);         goto bsdiff_out;       &#125;       spi_flash_addr +&#x3D; 1024;       current_flash_write_addr +&#x3D; 1024;       APP_PRINT(&quot;current_flash_write_addr: 0X%08X&quot;, current_flash_write_addr);      &#125;      if (recv_head.ih_ep % 1024 !&#x3D; 0)      &#123;       memset(spi_read_cache, 0XFF, 1024);       xmq25qxx_read(spi_flash_addr, spi_read_cache, recv_head.ih_ep % 1024);       if (xflash_write(current_flash_write_addr, spi_read_cache, 1024))       &#123;         APP_ERR_PRINT(&quot;I write program failed.&quot;);         goto bsdiff_out;       &#125;      &#125;      if (crc32((uint8_t *)APPLICATION_A, recv_head.ih_ep) !&#x3D; recv_head.ih_dcrc)      &#123;       APP_ERR_PRINT(&quot;file newcrc err,calcrc:0X%08X, newcrc:0X%08X, len: %lu&quot;,                    crc32((uint8_t *)APPLICATION_A, recv_head.ih_ep),                    recv_head.ih_load, recv_head.ih_dcrc);       goto bsdiff_out;      &#125;      &#x2F;* 下载成功,开始升级 *&#x2F;      if (check_bin_file((bin_info_t *)(APPLICATION_A + BIN_INFO_OFFSET))) &#x2F;* bin文件非法 *&#x2F;      &#123;       APP_ERR_PRINT(&quot;check_bin_file err.&quot;);       goto bsdiff_out;      &#125;      recv_head.ih_dcrc &#x3D; CRT_CRC16_check(0, (uint8_t *)APPLICATION_A,                       recv_head.ih_ep);      readwrite_app_run_bin_info(0, &amp;recv_head.ih_ep, (uint16_t *)&amp;recv_head.ih_dcrc);      &#x2F;* 整体校验成功,确认升级 *&#x2F;      if (switch_program_stage(STAGE_1))      &#123;       APP_ERR_PRINT(&quot;I write switch_program_stage STAGE_0 failed.&quot;);  &#x2F;* 置位升级标志写失败 *&#x2F;       goto bsdiff_out;      &#125;      APP_PRINT(&quot;upgrade success.&quot;);  bsdiff_out:      SYSTEM_RESET();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>资源下载</p><blockquote><ul><li>可以通过文中的下载链接自行获取。</li><li>点击附件下载<blockquote><p><a href="/downloads/code/mcu_bsdiff_upgrade.zip">mcu_bsdiff_upgrade.zip</a></p></blockquote></li></ul></blockquote><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><blockquote><p>文章来源于网络，版权归原作者所有，如有侵权，请联系删除。<br>原文：<a href="https://mp.weixin.qq.com/s/BSw1jQvqVbaqk-T4Dn8QJg">https://mp.weixin.qq.com/s/BSw1jQvqVbaqk-T4Dn8QJg</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OTA原理及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OTA </tag>
            
            <tag> BOOTLOAD </tag>
            
            <tag> 工程实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式设备实现OTA升级的原理</title>
      <link href="/20230702/learn_ota/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0OTA%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86.html"/>
      <url>/20230702/learn_ota/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0OTA%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>OTA：Over-the-Air Technology，即空中下载技术。<br>OTA升级：通过OTA方式实现固件或软件的升级。<br>只要是通过无线通信方式实现升级的，都可以叫OTA升级，比如网络/蓝牙。<br>通过有线方式进行升级，叫本地升级，比如通过UART，USB或者SPI通信接口来升级设备固件。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>通过OTA方式，可以对分布在各地的设备进行软件升级，而不必让运维人员各地奔波。</li><li>物联网平台支持通过OTA方式进行设备固件升级，是智能设备修复系统漏洞、实现系统升级的手段。</li><li>在迅速变化和发展的物联网市场，新的产品需求不断涌现，因此对于智能硬件设备的更新需求就</li></ol><p>变得空前高涨，设备不再像传统设备一样一经出售就不再变更。通过固件升级用户提供更好的服务。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>核心流程：</p><ol><li>制作升级包</li><li>下载升级包</li><li>验签升级包</li><li>更新程序</li></ol><p><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-002.png"></p><h2 id="下载方式："><a href="#下载方式：" class="headerlink" title="下载方式："></a>下载方式：</h2><p>不管采用OTA方式还是有线通信方式升级，下载升级包的方式包括后台式下载和非后台式下载两种模式。</p><h3 id="后台式下载："><a href="#后台式下载：" class="headerlink" title="后台式下载："></a>后台式下载：</h3><p>在升级的时候，新固件在后台悄悄下载，即新固件下载属于应用程序功能的一部分，在新固件下载过程中，应用可以正常使用，也就是说整个下载过程对用户来说是无感的，下载完成后，系统再跳到BootLoader程序，由BootLoader完成新固件覆盖老固件的操作。<br>比如智能手机升级Android或者iOS系统都是采用后台式方式，新系统下载过程中，手机可以正常使用。<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-003.png"></p><h3 id="非后台式下载："><a href="#非后台式下载：" class="headerlink" title="非后台式下载："></a>非后台式下载：</h3><p>在升级的时候，系统需要先从应用程序跳入到BootLoader程序，由BootLoader进行新固件下载工作，下载完成后BootLoader继续完成新固件覆盖老固件的操作，至此升级结束。<br>早先的功能机就是采用非后台来升级操作系统的，即用户需要先长按某些按键进入bootloader模式，然后再进行升级，整个升级过程中手机正常功能都无法使用。<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-004.png"></p><h2 id="新旧固件覆盖模式："><a href="#新旧固件覆盖模式：" class="headerlink" title="新旧固件覆盖模式："></a>新旧固件覆盖模式：</h2><p>新固件替换老固件覆盖的两种方式：双区模式和单区模式。</p><h3 id="双区模式："><a href="#双区模式：" class="headerlink" title="双区模式："></a>双区模式：</h3><p>双区模式中老固件和新固件在flash中各占一块bank（存储区）。假设老固件放在bank0（运行区）中，新固件放在bank1（下载区）中，升级的时候，应用程序先把新固件下载到bank1中，只有当新固件下载完成并校验成功后，系统才会跳入BootLoader程序，然后擦除老固件所在的bank0区，并把bank1的新固件拷贝到bank0中。<br>后台式下载必须采用双区模式进行升级。<br>优点：升级过程中出现问题或者新固件有问题，它还可以选择之前的老固件老系统继续执行而不受其影响。<br>缺点：多占用flash空间的一个存储区，在系统资源比较紧张的时候较为困难。<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-005.png"></p><h3 id="单区模式："><a href="#单区模式：" class="headerlink" title="单区模式："></a>单区模式：</h3><p>单区模式的非后台式下载只有一个bank0（运行区），老固件和新固件共享这一个bank0。升级的时候，进入bootloader程序后先擦除老固件，然后直接把新固件下载到同一个bank中，下载完成后校验新固件的有效性，新固件有效升级完成，否则要求重来。<br>优点：</p><blockquote><p>跟双区模式相比，单区模式节省了Flash空间的一个bank，在系统资源比较紧张的时候，单区模式是一个不错的选择。</p></blockquote><p>缺点：</p><blockquote><p>如果升级过程中出现问题或者新固件有问题，单区模式碰到这种情况就只能一直待在bootloader中，然后等待再次升级尝试，此时设备的正常功能已无法使用，从用户使用这个角度来说，可以说此时设备已经“变砖”了。</p></blockquote><p>相比较，双区模式虽然牺牲了很多存储空间，但是换来了更好的升级体验。<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-006.png"></p><h1 id="MCU-OTA升级"><a href="#MCU-OTA升级" class="headerlink" title="MCU OTA升级"></a>MCU OTA升级</h1><p>以MCU（微控制器）固件升级为例，讲解嵌入式裸机程序的OTA升级。由于裸机固件是固化在设备的存储器（如flash）中，即存储器中保存的是机器码，对MCU进行OTA固件升级，也就是要实现通过OTA方式将存储器中旧固件的机器码替换为新固件的机器码。<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-007.png"></p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>签名：</p><blockquote><p>A给B发送消息，A先计算出消息的消息摘要，然后使用自己的私钥加密消息摘要，被加密的消息摘要就是签名。</p></blockquote><p>验签：</p><blockquote><p>B收到消息后,也会使用和A相同的方法计算消息摘要，然后用A的公钥解密签名，并与自己计算出来的消息</p></blockquote><p>摘要进行比较，如果相同则说明消息是A发送给B的，同时,A也无法否认自己发送消息给B的事实。<br>(B使用A的公钥解密签名文件的过程，叫做”验签”)<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-008.png"></p><h2 id="密码学基础概念："><a href="#密码学基础概念：" class="headerlink" title="密码学基础概念："></a>密码学基础概念：</h2><p>1.什么是消息摘要？<br>2.什么是非对称加解密？私钥与公钥？<br>3.什么是数字签名？</p><p>数字签名的作用：<br>保证数据完整性，机密性和发送方角色的不可抵赖性。</p><p>消息摘要函数：<br>MD4、MD5、SHA-1、SHA-256、SHA-384、SHA-512</p><p>数字签名算法：<br>RSA、Rabin方式、ElGamal方式、DSA</p><h2 id="制作升级包"><a href="#制作升级包" class="headerlink" title="制作升级包"></a>制作升级包</h2><p>通过签名工具使用签名算法对固件进行数字签名，签名后的文件即为升级包。<br>升级包的内容一般包括firmware、header和signature value。<br>Firmware:固件<br>Header:头部信息。存放配置信息，如版本号、产品类型等。<br>Signature value:签名值。对firmware和header签名后的值。<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-009.png"></p><p>签名工具：<br>上位机软件，能计算固件的签名值，并将固件打包为升级包的格式。</p><p>固件签名：<br>上位机软件先计算整个固件的消息摘要，使用非对称密码的私钥对摘要进行加密，<br>被加密后的消息摘要数据就是签名值。</p><p>固件签名的意义：<br>计算hash值可以识别固件是否被篡改和伪装，确保固件的完整性。<br>使用非对称秘钥签名方便后续验证升级包身份的合法性。</p><h2 id="下载升级包"><a href="#下载升级包" class="headerlink" title="下载升级包"></a>下载升级包</h2><p>根据上位机软件和MCU设备约定的通信协议，上位机软件将升级包通过OTA方式发送给MCU设备，<br>MCU设备收到数据后，根据通信协议解析出升级包的数据，并将升级包的数据保存到存储器中。</p><p>通信协议的作用：<br>通讯双方约定俗成地用于数据交流的格式。<br>下载的方式：</p><ol><li>在应用程序中下载：后台式</li><li>在BootLoader中下载：非后台式</li></ol><h2 id="验签升级包"><a href="#验签升级包" class="headerlink" title="验签升级包"></a>验签升级包</h2><p>MCU设备接收完所有的升级包后，先计算升级包中固件的摘要，然后使用非对称秘钥的<br>公钥解密升级包的签名值，如果解密出来的固件摘要与自己计算的摘要相同，则验签成功。</p><h2 id="更新固件"><a href="#更新固件" class="headerlink" title="更新固件"></a>更新固件</h2><p>验签成功保证了固件的完整性和合法性后，MCU设备从应用程序进入BootLoader程序，<br>在BootLoader程序中将flash中的新固件数据搬运到旧固件的存储区，将其覆盖。<br>然后BootLoader程序启动固件运行，此时固件为新固件。</p><p>flash固件数据更新：<br>擦除flash，写flash。</p><h1 id="Linux-OTA升级"><a href="#Linux-OTA升级" class="headerlink" title="Linux OTA升级"></a>Linux OTA升级</h1><p>Linux系统的组成：<br>主要由三大部分组成，包括uboot(引导启动程序)、kernel(内核)和rootfs(根文件系统)。<br>三者在flash中的分区如下：<br>应用程序存放于rootfs。<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-010.png"></p><p>Linux系统的启动流程：<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-011.png"></p><h2 id="系统升级"><a href="#系统升级" class="headerlink" title="系统升级"></a>系统升级</h2><p>Linux系统由uboot\kernel\rootfs三大部分组成，对Linux系统进行升级，也就是对flash中这三个分区的数据进行更新替换。<br>由于uboot\kernel\rootfs在flash分区中是以二进制数据存储的，与MCU固件在flash中存的是二进制数据一样，包括uboot\kernel\rootfs的升级文件也是以二进制数方式直接写入到对应的Flash分区。其升级方式与MCU固件的升级原理基本是一致的。<br>一般可在uboot中下载升级包来升级uboot\kernel\rootfs ，与MCU在BootLoader程序中完成升级类似。<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-012.png"></p><h2 id="应用程序升级"><a href="#应用程序升级" class="headerlink" title="应用程序升级"></a>应用程序升级</h2><p>在Linux系统中，应用程序是存放在文件系统中，并以可执行程序文件的方式存在，其在系统中就是文件，这与MCU固件存放在flash分区的方式不同。<br>应用程序的升级流程与MCU固件、Linux系统升级基本一致。应用程序的升级除了可以升级可执行文件外，还可以升级配置文件等。</p><p>应用程序升级流程：<br>制作升级包（打包签名工具）、下载升级包（下载工具）、升级包验签、程序更新</p><p>与MCU OTA升级区别：<br>制作升级包：将应用程序相关的文件（可执行程序、库文件、配置文件等）打包为压缩包，作为一个整体再进行签名。<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-013.png"></p><p>升级包下载和验签通过后，将压缩包解压，可以得到应用程序的相关文件。<br>应用程序的更新，可以通过启动应用程序的程序来更新，如启动脚本、启动程序，类似MCU升级的BootLoader程序作用。</p><p>更新方式：</p><ol><li>直接覆盖旧程序；</li><li>保留旧程序，执行新程序；</li></ol><p>直接覆盖旧程序：<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-014.png"><br>保留旧程序，执行新程序：<br>如ping\pong操作<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-015.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>OTA升级的核心：<br><img src="/images/learn/ota/zRs7WMhhL-LhfxiQssG2tA-016.png"></p><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><blockquote><p>文章来源于网络，版权归原作者所有，如有侵权，请联系删除。<br>来源： <a href="https://blog.csdn.net/bulebin/article/details/108428643">https://blog.csdn.net/bulebin/article/details/108428643</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OTA原理及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OTA </tag>
            
            <tag> BOOTLOAD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图文详解STM32单片机远程升级</title>
      <link href="/20230702/learn_ota/%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3STM32%E5%8D%95%E7%89%87%E6%9C%BA%E8%BF%9C%E7%A8%8B%E5%8D%87%E7%BA%A7.html"/>
      <url>/20230702/learn_ota/%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3STM32%E5%8D%95%E7%89%87%E6%9C%BA%E8%BF%9C%E7%A8%8B%E5%8D%87%E7%BA%A7.html</url>
      
        <content type="html"><![CDATA[<h1 id="需要两份程序"><a href="#需要两份程序" class="headerlink" title="需要两份程序"></a>需要两份程序</h1><p>BootLoader和App程序，两份程序均可以通过jlink下载，只需要将下载地址修改一下即可：<br><img src="/images/learn/ota/N0DADxo6E44b9HYEbcxAyQ_001.png" alt="图片"><br><img src="/images/learn/ota/N0DADxo6E44b9HYEbcxAyQ_002.png" alt="图片"></p><h1 id="在BootLoader中的跳转函数"><a href="#在BootLoader中的跳转函数" class="headerlink" title="在BootLoader中的跳转函数"></a>在BootLoader中的跳转函数</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define APP_FLASH_ADDR 0x8008000 iap_load_app(APP_FLASH_ADDR);&#x2F;&#x2F;#include &quot;include.h&quot;#include &quot;iap.h&quot;#include &quot;main.h&quot;typedef  void (*iapfun)(void);&#x2F;&#x2F;?¨ò?ò???oˉêyààDíμ?2?êy.iapfun jump2app; __asm void MSR_MSP(u32 addr) &#123;    MSR MSP, r0    &#x2F;&#x2F;set Main Stack value    BX r14&#125;&#x2F;****************************************************************************** *   Function name  ￡o iap_load_app *    Function describe     ￡o ì?×aμ?app3ìDò?￡ *    Input      ￡o appxaddr￡oapp3ìDòμ?μ??·?￡        *    Output      ￡o No *    Illustration     ￡o   *   Revise   ￡o *   Existing problems  :  No*****************************************************************************&#x2F;void iap_load_app(u32 appxaddr)&#123; if(((*(vu32*)appxaddr)&amp;0x2FFE0000)&#x3D;&#x3D;0x20000000) &#123;   jump2app&#x3D;(iapfun)*(vu32*)(appxaddr+4);  MSR_MSP(*(vu32*)appxaddr);  jump2app(); &#x2F;&#x2F;ì?×aμ?APP. &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="在app中修改中断向量表的偏移地址"><a href="#在app中修改中断向量表的偏移地址" class="headerlink" title="在app中修改中断向量表的偏移地址"></a>在app中修改中断向量表的偏移地址</h1><p><img src="/images/learn/ota/N0DADxo6E44b9HYEbcxAyQ_003.png" alt="图片"><br><img src="/images/learn/ota/N0DADxo6E44b9HYEbcxAyQ_004.png" alt="图片"><br><img src="/images/learn/ota/N0DADxo6E44b9HYEbcxAyQ_005.png" alt="图片"></p><h1 id="程序自动选择向量表的偏移地址"><a href="#程序自动选择向量表的偏移地址" class="headerlink" title="程序自动选择向量表的偏移地址"></a>程序自动选择向量表的偏移地址</h1><p>适用场景，一颗芯片里面有3个程序：</p><blockquote><ul><li>BootLoader程序，起始地址：0x08000000</li><li>APP1程序，起始地址：0x08008000</li><li>APP2程序，起始地址：0x08013000</li></ul></blockquote><p>这种情况就需要BootLoader程序自动选择往哪个地址跳转，这个地址再升级完以后会变，比如当前的跳转地址是app1，那么升级后跳转的地址就变为app1。<br>针对这种场景，做如下修改：<br><img src="/images/learn/ota/N0DADxo6E44b9HYEbcxAyQ_006.png" alt="图片"></p><h1 id="keil编译器中设置的程序起始地址会别写进bin文件"><a href="#keil编译器中设置的程序起始地址会别写进bin文件" class="headerlink" title="keil编译器中设置的程序起始地址会别写进bin文件"></a>keil编译器中设置的程序起始地址会别写进bin文件</h1><p><img src="/images/learn/ota/N0DADxo6E44b9HYEbcxAyQ_007.png" alt="图片"><br>上图中的地址会被写入到bin文件中，所以在编译APP1程序和APP2程序的时候，要记着修改这里的起始地址。</p><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><blockquote><p>文章来源于网络，版权归原作者所有，如有侵权，请联系删除。<br>原文：<a href="https://mp.weixin.qq.com/s/N0DADxo6E44b9HYEbcxAyQ">https://mp.weixin.qq.com/s/N0DADxo6E44b9HYEbcxAyQ</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OTA原理及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OTA </tag>
            
            <tag> BOOTLOAD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出讲解单片机的BootLoader</title>
      <link href="/20230702/learn_ota/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%B2%E8%A7%A3%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84BootLoader.html"/>
      <url>/20230702/learn_ota/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%B2%E8%A7%A3%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84BootLoader.html</url>
      
        <content type="html"><![CDATA[<p>对于一个复杂的单片机项目来说，有一个 BootLoader（以下简称BL）是非常重要的。它可以使得你的应用程序代码维护和升级更加便捷。<br>之前分享过一些软件升级的文章：<br>嵌入式设备实现OTA升级的原理<br>嵌入式设备差分升级原理和实现(附代码)<br>专为32位单片机开发的轻量级OTA组件(开源)<br>单片机通过 UART 实现 OTA 升级的详细流程</p><p>本篇文章，带你了解为什么要设计 Bootloader，以及如何设计 Bootloader。争取做到知其然、知其所以然。<br>通过对 BL 进行详细的讲解，希望让大家可以体会到它的重要性。</p><h1 id="烧录方式的更新迭代"><a href="#烧录方式的更新迭代" class="headerlink" title="烧录方式的更新迭代"></a>烧录方式的更新迭代</h1><h2 id="古老的烧录方式"><a href="#古老的烧录方式" class="headerlink" title="古老的烧录方式"></a>古老的烧录方式</h2><p>单片机诞生于20世纪80年代，以 51 为代表开始广泛应用于工业控制、家电等很多行业中。起初对于单片机的烧录，也就是将可执行的程序写入到其内部的ROM中，不是一件容易的事情，而且成本不低，因为需要依赖于专门的烧录设备。由于受到半导体技术与工艺的限制，对于ROM的烧写大多需要高压。这种境况一直持续到2000年左右，如图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-001.png"></p><h2 id="ISP与ICP烧录方式"><a href="#ISP与ICP烧录方式" class="headerlink" title="ISP与ICP烧录方式"></a>ISP与ICP烧录方式</h2><p>随着低压电可擦写ROM的成熟，单片机开始集成可通过数字电平直接读写的存储介质。<br>其最大的优势在于可实现在系统或在电路直接烧录程序，而无需像以前一样把单片机芯片从电路中拿出来，放到编程器上，这种烧录方式就是 ISP(In System Programming) 或 ICP(In Circuit Programming)，如图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-002.jpg"></p><p>有人问过这样一个问题：“ISP和ICP我都听说过，都说是可以在电路板上直接烧录程序，而无需拿下芯片，那ISP和ICP有什么区别？”<br>从广义上来说，两者没有区别，平时我们把其意义混淆也毫无问题。非要刨根问底的话，那可以这样来理解：<br>ISP要求单片机中驻留有专门的程序，用以与上位机进行通信，接收固件数据并烧录到自身的ROM中，很显然ISP的单片机是需要可运行的，即要具备基本的最小系统电路(时钟和复位)。<br>而 ICP 可以理解为 MCU 就是一块可供外部读写的存储电路，它不需要预置任何程序，也不需要单片机芯片处于可运行的状态。<br>支持 ISP 或 ICP 的芯片，以AT89S51最为经典，当时从 AT89C51 换成 S51，多少人因此不再依赖烧录器而大呼爽哉。这种并口下载线非常流行，如图3.3，网上还有各种ISP小软件，可以说它降低了很多人入门单片机的门槛，让单片机变得喜闻乐见。一台电脑、一个S51最小系统板、一条并口ISP下载线，齐了！<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-003.png"></p><h2 id="更方便的ISP烧录方式"><a href="#更方便的ISP烧录方式" class="headerlink" title="更方便的ISP烧录方式"></a>更方便的ISP烧录方式</h2><h3 id="串口ISP"><a href="#串口ISP" class="headerlink" title="串口ISP"></a>串口ISP</h3><p>后来我们发现带有并口的电脑越来越少。那是在2005年前后，STC单片机开始大量出现，在功能上其实与S51相差无几，甚至比同期的一些高端51单片机还要逊色。但是它凭借一个优势让人们对它爱不释手，进一步降低了单片机的学习门槛。<br>这个优势就是–串口ISP，这是真正意义上的 ISP，如图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-004.jpg"><br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-005.png"></p><p>再后来，9针串口都很少见了，只有USB。这促使一个烧录和调试神器炙手可热 – USB TTL串口。这下232转换芯片省掉了，直接通过USB进行烧录。这种方式造福了无数的单片机学习者和工程师。<br>多年来，在串口与单片机的交互上，我动了很多脑筋，这也是我乐于开发 Bootloader 的一个原因。我希望“USB串口在手，一切全有！”<br>STC 并不是第一个使用串口 ISP 烧录程序的，但它是最成功和最深入人心的。与之同期的很多单片机，包括时至今日仍然应用最广泛的 STM32 全系列也都支持了串口 ISP，它成为了一种标配的、非常普遍的程序烧录手段。</p><h3 id="各种USB-ISP"><a href="#各种USB-ISP" class="headerlink" title="各种USB ISP"></a>各种USB ISP</h3><p>串口ISP固然方便，但是下载速度是它的硬伤，当固件体积比较大的时候，比如一些大型嵌入式项目的固件动辄几百K，甚至几M，再用串口ISP就未免太慢了。所以一些单片机配有专门的USB ISP下载器。以下列举几种比较主流单片机及其USB ISP下载器。</p><ol><li><p>AVR<br>AVR 单片机曾经盛极一时，但经历了 2016 年的缺芯风波之后，加之 STM32 的冲击，开始变得一蹶不振，鲜有人用了。与之配套的USB ISP下载器非常多样，有些是官方发布的，更多的是爱好者开源项目的成果，如图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-006.png"></p></li><li><p>C8051F<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-007.png"></p></li><li><p>MSP430<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-008.png"></p></li></ol><p>我们会发现，一个具体良好生态的主流单片机，一定有配套的高效便捷的烧录下载工具。可见一种好的烧录方式，对单片机开发是多么重要。<br>不论是串口 ISP 还是各种专用的 ISP 下载器，都有一些共同的弊端。</p><ol><li>依赖于专门的上位机或下载器硬件，不能作到统型；</li><li>下载器价格仍然比较高，尤其是原厂的，这也是为什么有些单片机催生出很多第三方的下载器，比如 AVR；</li><li>下载的时候通常需要附加额外的操作，比如STC要重新上电、STM32需要设置BOOT引脚电平等等。这些额外的操作都增加了烧录的复杂性。尤其是在产品形态下要去重新烧录程序，比如嵌入式升级，就要打开外壳，或将附加信号引出到壳外。这都是非常不高效，不友好的作法。</li></ol><p>如果有一种烧录方法，对于任何一种单片机：</p><ol><li>通信方式统一（比如一律都用串口)）；</li><li>提供一个友好的操作界面（比如命令行方式）；</li><li>高效快速，没有附加操作，最好一键自动化烧录；</li><li>另外再增加一些嵌入式固件管理的功能（比如固件版本管理）。</li></ol><p>这一定会让我们事半功倍。Bootloader 就能实现上述的这一切！</p><h1 id="关于Bootloader"><a href="#关于Bootloader" class="headerlink" title="关于Bootloader"></a>关于Bootloader</h1><h2 id="Bootloader的基本形态"><a href="#Bootloader的基本形态" class="headerlink" title="Bootloader的基本形态"></a>Bootloader的基本形态</h2><p>直接看图<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-009.png"></p><p>可以看到BL就是一段存储在ROM中的程序，它主要实现4个功能：</p><ol><li>通过某种途径获取要烧录的固件数据；</li><li>将固件数据写入到ROM的APP区中；</li><li>跳转到APP区运行，将烧录进去的用户程序引导起来；</li><li>在此过程中，提供必要而友好的人机交互界面。</li></ol><p>这么说可能不好理解，我们还是通过实例来进行讲解。</p><h2 id="Bootloader的两个设计实例"><a href="#Bootloader的两个设计实例" class="headerlink" title="Bootloader的两个设计实例"></a>Bootloader的两个设计实例</h2><p>下面的两个实例，用于说明BL的实际应用形态，不涉及具体的实现细节，旨在让大家了解 BL 实际是如何运行的。<br>带Shell命令行的串口BL<br>基本的操作逻辑如下：</p><ol><li>通过超级终端、SecureCRT 或 Xshell 之类的串口终端输入命令 program；</li><li>BL 接收到命令后，开始等待接收固件文件数据；</li><li>串口终端通过某种文件数据传输协议（例如  X/Y/Zmodem协议）将固件数据传给BL；</li><li>BL 将固件数据写入到 ROM 的 APP 区中；</li><li>BL 将 APP 区中的程序引导运行起来。</li></ol><p>更具体的示意如图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-010.png"></p><p>这里把操作逻辑说得很简单，实际实现起来却并不容易，我们放在后面去细究其具体实现。</p><h2 id="插SD卡即烧录的BL"><a href="#插SD卡即烧录的BL" class="headerlink" title="插SD卡即烧录的BL"></a>插SD卡即烧录的BL</h2><p>基本的操作逻辑如下：</p><ol><li>将待烧录的固件拷贝到SD卡中；</li><li>将SD卡插入到卡槽中；</li><li>BL 检测到 SD 卡插入，搜索卡中 BIN 文件；</li><li>将 BIN 文件数据读出写入到 ROM 的 APP 区中；</li><li>BL 将 APP 区中的程序引导运行起来。</li></ol><p>如图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-011.png"></p><p>通过这两个设计实例，大家应该已经了解BL是什么了吧。有没有感受到 BL 是比 ISP 烧录器更通用、更灵活、更友好、功能更强大的固件烧录和管理手段呢？<br>有人可能知道 Linux 下的 Uboot，它就是一个强大的 BL，它提供非常强大的刷机（烧录操作系统镜像）的功能以及完备而灵活的Shell界面，如图所示。其实我们电脑的BIOS也是一种广义的BL。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-012.png"></p><p>那如何实现一个BL呢？别急，要实现BL是需要满足一些基本要求的。</p><h1 id="BL实现的要点"><a href="#BL实现的要点" class="headerlink" title="BL实现的要点"></a>BL实现的要点</h1><p>首先要说，并不是任何一个单片机都可以实现BL的，要满足几个要点。<br>芯片体系架构要支持<br>来看图<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-013.png"></p><p>我们知道单片机程序的最开头是中断向量表，包含了程序栈顶地址以及Reset程序入口，通过它才能把程序运行起来。很显然在从BL向APP跳转的时候，APP程序必须有自己的中断向量，并且而且单片机体系架构上要允许中断向量表的重定向。<br>传统51单片机的中断向量表只允许放到ROM开头，而不能有偏移量，所以传统51单片机是不能支持BL的。<br>有人要问“你这不是自相矛盾吗？你前面说STC的51单片机是支持串口ISP的，那它应该内置有ISP程序，我理解它应该和BL是一个道理。”<br>没错，它内置的 ISP 程序就是一种 BL。STC 之所以可以实现 BL 功能，是因为宏晶半导体公司对它的硬件架构进行了改进，请看图<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-014.png"></p><p>可以看到，STC51 单片机多出了一块专门存放 BL 的 ROM，称为 BOOTROM。<br>网上有一位叫 shaoziyang 的网友为 AVR 单片机写了一个 BL，还配套开发了一款叫 AVRUBD 的上位机，如图。（AVRUBD是很有用的，它可以让我们实现隔空烧录），实现了AVR单片机的串口烧录，让很多人摆脱了对USBISP之类ISP下载器的依赖（虽然ISP下载器已经很方便了，但它毕竟还需要银子嘛）。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-015.png"></p><p>AVR 在硬件架构上与 STC51 是一个套路，如图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-016.png"></p><p>通过配置AVR的熔丝位可以控制复位入口地址以及BOOT区的大小和开始地址，如图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-017.png"></p><p>讲到这里，有人会说：“那有没有一种单片机，程序放在ROM的任何位置都可以运行起来，也就是中断向量表可以重定位？”<br>当然有，这种单片机还很多，其中最典型的就是 STM32。它的程序之所以可以放之各地皆可运行，是因为在它的 NVIC 控制器中提供了中断向量表偏移量的相关配置，这个后面我们再详细说。<br>ROM 要支持 IAP<br>这也是需要单片机硬件支持的。很好理解，在 BL 获取到固件数据之后，需要将它写入到 ROM 的 APP 区中，所以说单片机需要支持 IAP 操作，所谓 IAP 就是 In Application Programming，即在应用烧录。也就是在程序运行过程中，可以对自身ROM进行擦除和编程操作。<br>大家仔细想想是不是这样？似乎支持串口ISP的单片机都支持IAP功能。STC还把这一功能包装成了它的一大特色，可以用内部ROM来充当EEPROM的功能，可以在运行时记录一些掉电不丢失的参数信息。<br>STM32 的 ROM 擦写在配套的固件库(标准库或HAL库)中已经有实现，大家可以参考或直接使用。<br>APP程序的配套修改<br>为了让BL可以顺利的将APP程序引导运行起来，APP 程序在开发的时候需要配合BL作出相应的修改。最重要的就是 APP 程序的开始地址（即中断向量表的开始地址）以及对中断控制器的相应配置。<br>对于51、AVR这类单片机APP程序不用修改，具体原因大家应该明白。这里主要对 STM32 APP程序如何修改进行详细讲解。<br>我们依然是结合实例，请看图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-018.png"></p><p>假设我们所使用的 STM32 的 ROM 总大小为 128KB，BL程序的体积是16K，APP程序紧邻BL，那么APP区的开始地址为<code>0X08004000</code>，也就是APP程序的中断向量表偏移地址为0X4000。<br>如果我们使用MDK作为开发环境的话，需要修改这里，如图所示。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-019.png"></p><p>而如果我们使用的是 gcc 的话，则需要对 link.ld 链接文件进行修改，如图3.18。<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-020.jpg"></p><p>然后我们还需要对NVIC的中断向量表相关参数进行配置，主要是中断向量表的偏移量，如下代码。<br><code>#define VECT_TAB_OFFSET 0x4000</code></p><p>OK，经过修改后的程序，我们把它放到 <code>ROM</code> 的 <code>0X08004000</code> 开始地址上，然后再让BL跳转到这个地址，我们的程序就能运行起来了。<br>有人又会问：“BL中的跳转代码怎么写？”别急，这是我们要讲的下一个要点。<br>BL中的跳转代码<br>跳转代码是 BL 要点中的关键，直接关系到 APP 程序能否正常运行，如图<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-021.png"></p><p>我直接给出 STM32 的 jump_app 函数代码。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void (*iapfun)(void);iapfun jump2app;void MSR_MSP(u32 addr)&#123;  __ASM volatile(&quot;MSR MSP, r0&quot;);   &#x2F;&#x2F;set Main Stack value*  __ASM volatile(&quot;BX r14&quot;);*&#125;void load_app(u32 appxaddr)&#123;  if(((*(vu32*)appxaddr)&amp;0x2FFE0000)&#x3D;&#x3D;0x20000000)&#x2F;&#x2F;**检查栈顶地址合法*  &#123;    &#x2F;&#x2F;**用户代码区第二个字为程序开始地址(**复位地址)    jump2app&#x3D;(iapfun)\*(vu32\*)(appxaddr+4);    &#x2F;&#x2F;**初始化APP**堆栈指针(**用户代码区的第一个字用于存放栈顶地址)    MSR_MSP(*(vu32*)appxaddr);      jump2app();   &#x2F;&#x2F;**跳转到APP.  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码大家自行研究，如果展开讲就属于赘述了。<br>到这里BL相关的要点就介绍完了，大家应该有能力去完成一个简单的BL了。基于 STM32 设计的一个小实验，大家有兴趣可以小试牛刀一下，如图<br><img src="/images/learn/stm32/rOjvERrcyfs4E9hfco5-pw-022.png"></p><p>我们将 BL 程序用 Jlink 烧录到 0X08000000 位置，而把 APP 程序烧录到 0X08002000 开始位置，然后复位，如果串口打印了 hello world 或流水灯亮起来了，就说明我们的 BL 成功了。</p><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><blockquote><p>文章来源于网络，版权归原作者所有，如有侵权，请联系删除。<br>原文：<a href="https://mp.weixin.qq.com/s/rOjvERrcyfs4E9hfco5-pw">https://mp.weixin.qq.com/s/rOjvERrcyfs4E9hfco5-pw</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OTA原理及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> OTA </tag>
            
            <tag> BOOTLOAD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何减轻CPU负担</title>
      <link href="/20230702/learn_skill/%E5%A6%82%E4%BD%95%E5%87%8F%E8%BD%BBCPU%E8%B4%9F%E6%8B%85.html"/>
      <url>/20230702/learn_skill/%E5%A6%82%E4%BD%95%E5%87%8F%E8%BD%BBCPU%E8%B4%9F%E6%8B%85.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_001.jpg"><br>「CPU运行时间是宝贵的资源，我们要把有限的CPU时间投入到更有意义的事情中去。」</p><blockquote><p>在我们进行嵌入式开发的过程中，你一定干过这几件事：用GPIO模拟某种通信接口，比如SPI等；用空循环来实现延时delay；空等寄存器的关键状态位。也许是出于无奈，比如所使用的芯片没有硬件SPI或通道不够，亦或者此时CPU除了空转并没有其它事情要作，但是我们一定要有这样的意识：这是在浪费CPU资源。<br>CPU是嵌入式系统的核心，但是它不必深入参与到每一个细节中去。记住：CPU是片上所有硬件资源的统领者，而非事必躬亲的苦力。我们要学会尽最大可能充分利用片上硬件资源，甚至在芯片外部扩展一些专门的硬件电路来完成功能设计。</p></blockquote><p>我们看看</p><p>本章我将通过几个实例来向大家说明如何减轻CPU负担，而用片内片外的硬件来实现我们想要的功能。</p><h1 id="石油测井仪器"><a href="#石油测井仪器" class="headerlink" title="石油测井仪器"></a>石油测井仪器</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>在我的职业生涯中，有5年多的时间在做石油仪器。这是一个很传统的行业，但也是非常综合性和吃技术的行业。</p><p>有人说：“你这一章似乎要讲的是CPU的利用率问题，怎么又讲起石油仪器来了？”别急，我自有用意。</p><p>请看图1.1。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_002.png" alt="图1.1 石油测井系统示意图"></p><p>上图所示为石油测井系统的简易拓扑示意图。工作时测井车通过轮盘拉动钢缆上提，与此同时仪器向外发射信号（电或超声），并接收返回信号经过计算将结果通过同轴以太网上传到地面系统，由上位机绘制出曲线。最终曲线将交给解释工程师，来判断油气储层的位置。<br>上提的速度是一定的，我们当然希望在某一个深度上多采集一些数据，即尽量提高采样率。这样最终的测井曲线上就能体现出更多的细节。<br>OK，这就是最基本的原理和背景。</p><h2 id="测井数据采传的实现"><a href="#测井数据采传的实现" class="headerlink" title="测井数据采传的实现"></a>测井数据采传的实现</h2><p>电路上比较清晰，如图1.2。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_003.png" alt="图1.2 测井仪器数据采传原理框图"></p><h3 id="最直接的初级方案"><a href="#最直接的初级方案" class="headerlink" title="最直接的初级方案"></a>最直接的初级方案</h3><p>最直接的方案是所有人都能想到的方案，就是采集、计算、发送按部就班的进行，如图1.3所示。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_004.png" alt="图1.3 测井数据采传最直接的实现方案"><br>每一个周期要作的事情就是：「ADC采集一段波形，然后进行计算，主要是一些数字滤波、FFT、DPSD之类的数字信号处理，最终将结果数据按协议格式打包通过McBSP（TI DSP专有的通信接口）发送给同轴以太网通信模块。我们当然希望这个周期越短越好，这需要将一些步骤优化压缩。」</p><h3 id="加入DMA的优化方案"><a href="#加入DMA的优化方案" class="headerlink" title="加入DMA的优化方案"></a>加入DMA的优化方案</h3><p>上面的方案，仔细看一下就会发现，它的所有操作都是需要CPU参与的，大量的时间都在等待外设。如何降低CPU的参与度，把其宝贵的时间不要浪费在空等上，而放在核心算法的计算上，请看图1.4所示。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_005.png" alt="图1.4 加入DMA的数据采传优化方案"><br>我们首先由CPU参与完成一次波形采集，然后开始针对采集数据进行计算，因为涉及大量浮点数据的数字信号处理，所以计算过程会比较花时间，一次计算大约需要花费10ms。与此同时，我们适时的不断启动ADC转换，在其转换的时间间隙里进行计算，然后直接启动SPI-DMA传输来读取ADC的转换数据，而CPU不用去等DMA传输完成，可以利用DMA传输的时间进行计算，最后回过头来立即进行下一次计算，因为此时新的波形已经准备好了。这样，一个周期的时间可以压缩到10ms，采样率比原来提高了一倍。<br>我是想通过这个实例来告诉大家：「CPU的运行时间是宝贵的，将片上的硬件资源充分的利用起来将可以释放出更多的CPU时间来作更有意义的事情。一些技巧和DMA的合理运用是行之有效的办法。」<br>其实很多时候能被用来发挥的硬件资源并不只限于片内，「我们自己设计一些简单的片外电路加以辅助，有时候可以达到意想不到的效果，」 请往下看。</p><hr><h1 id="巧驱摄像头"><a href="#巧驱摄像头" class="headerlink" title="巧驱摄像头"></a>巧驱摄像头</h1><h2 id="摄像头时序分析"><a href="#摄像头时序分析" class="headerlink" title="摄像头时序分析"></a>摄像头时序分析</h2><p>我知道很多人都对摄像头模块感兴趣，想用单片机驱动一下试试效果，但是作成功的并不多，如图2.1。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_006.png" alt="图2.1 比较盛行的OV7670摄像头模块和模组"><br>究其原因有几点：</p><ul><li>摄像头CMOS芯片的时序较为复杂；</li><li>SCCB通信及相关寄存器的配置；</li><li>时序过快，而且是按其固有频率主动输出，难于捕捉和采集数据。</li></ul><p>它的时序有多快，我们来看下图，如图2.2所示。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_007.png" alt="图2.2 OV7670的时序示意图"><br>OV7670在VGA模式下可达到的最高帧率30fps，即每秒钟产生30帧640X480尺寸的图像。从官方资料上得知VGA模式下实际输出的行数为510，每行输出的像素数为784（多出来的行数与像素数是多余的，其数据是无效的，我们只关注HREF为高电平期间的像素数据）。这样，PCLK的时钟周期为1/（30 * 510 * 784 * 2）=42.3ns。想要用一般单片机的GPIO来直接采集像素数据，几乎是不可能的，因为IO与CPU的速度都不够快。</p><h2 id="使用DCMI-DMA"><a href="#使用DCMI-DMA" class="headerlink" title="使用DCMI+DMA"></a>使用DCMI+DMA</h2><p>要读取摄像头如此高速的数据，必须要有专门的硬件。我们可以选用ST的STM32F4系列单片机，它内置了DCMI（数字摄像头模块接口），使用它将可以很轻松的完成图像获取的功能。它要配合DMA来工作，如图2.3。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_008.png" alt="图2.3 使用DCMI+DMA实现对摄像头的驱动"><br>DCMI获取摄像头数据，可以通过DMA直接将数据保存到内部RAM或外部的SDRAM，甚至直接写入到TFT中，实现图像的实时动态显示。而在整个过程中，CPU只不过在作一些配置性的工作，并没有参与图像数据采集和传输。所以，用高端芯片会使我们的开发工作如虎添翼，事半功倍。就是因为它有更强大的硬件外设来为我们完成特定的功能实现。当然，更强大的硬件也意味着更多的学习成本，我们需要仔细学习如何正确的使用它来达到想要的效果。<br>有些时候，硬件外设电路甚至比CPU内核更复杂，比如有些多媒体编解码SOC，CPU内核只是51或M0，片上更大的面积是诸如H.264之类的编解码电路。所以，作嵌入式开发的工程师，「首先要充分了解自己手上有哪些硬件资源，而不要所有功能都纯依靠CPU来实现。」</p><h2 id="自搭外部电路"><a href="#自搭外部电路" class="headerlink" title="自搭外部电路"></a>自搭外部电路</h2><p>本节的名字是“巧驱摄像头”，上面所介绍的方案都不算不上一个“巧”字。上述方案中必须要求单片机有DCMI之类的专用硬件，那不用DCMI可不可以？比如拿普通的51或低端的M0单片机，可不可以实现对摄像头的驱动。答案是肯定的，不过这需要我们在外部电路上作些手脚，如图2.4所示。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_009.png" alt="图2.4 通过片外并行FIFO+时序调理实现图像采集"><br>配合下面的流程图，大家就知道其巧妙之处了，如图2.5。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_010.png" alt="图2.5 通过片外并行FIFO实现一帧数据的获取"><br>程序按上图描述的逻辑运行之后，一帧图像就存到FIFO中了。此时单片机可以慢慢从读取端（并行FIFO分为写入端与读取端，分别对应的有写指针与读指针）读到图像数据了。这样CPU和IO的速度就再也不是瓶颈。通过这样的机制，任何单片机都可以轻松实现图像采集了。<br>在此过程中，CPU都干了什么？似乎只有等待帧同步信号VSYNC和操作几个IO。这种方式比DCMI+DMA更省CPU（DMA实际上会占用一半的片内数据总线带宽，使CPU的运行效率降低），而且更灵活，对单片机硬件的依赖更小。</p><hr><h1 id="单片机巧驱7寸大液晶屏"><a href="#单片机巧驱7寸大液晶屏" class="headerlink" title="单片机巧驱7寸大液晶屏"></a>单片机巧驱7寸大液晶屏</h1><p>通过上面几个实例，大家应该知道我所谓“巧驱”的路数了吧，对，就是多让硬件说话，我们要作“软硬兼施”的工程师。<br>OK，如果我问大家：“我能用51或M0单片机，驱动7寸大屏液晶（800 * 480），如图2.6，并且流畅播放视频，你信不信？”你一定会说：“不太可能吧，刷屏速率不够。”但我既然这么问，那我一定是已经实现了，这里我就把实现过程给大家讲一下。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_011.png" alt="图2.6 7寸TFT液晶模块"></p><p>先来看原理图，如图2.7~10。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_012.png" alt="图2.7 巧驱7寸液晶屏原理图之MCU部分"></p><p><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_013.png" alt="图2.8 巧驱7寸液晶屏原理图之74HC595串转并部分"></p><p><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_014.png" alt="图2.9 巧驱7寸液晶屏原理图之八8进制计数与时序调理部分"></p><p><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_015.png" alt="图2.10 巧驱7寸液晶屏原理图之spiFlash与7寸TFT接口部分"></p><p>基本的实现逻辑如图2.16所示。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_016.png" alt="图2.16 巧驱7寸液晶屏之基本实现逻辑框图"></p><p>仔细观察上面的原理图与逻辑框图，估计很多人已经明白了我的意思，我再给出配套的流程图，逻辑就更清晰了，如图2.17所示。<br><img src="/images/learn/stm32/lYnSWl3Cl8Fy9Nwjg2kijQ_017.png" alt="图2.17 巧驱7寸液晶屏的基本流程图"></p><p>两片74HC595用于将16位串行数据转换为并行，与TFT液晶的16位数据接口相连。74HC595的串行数据输入同时与MCU的两个GPIO以及spiFlash的两个串行数据端口相连。当spiFlash失能时（即CS置高），其数据端口呈现高阻，此时74HC595可由MCU操作；而当MCU的GPIO设置为高阻时，两片74HC595可分别接收来自spiFlash的双位串行数据。这样的复用设计，「可以使MCU对TFT液晶进行预先的初始化，使其工作在纯像素数据写入的模式；而在高速数据写入的阶段，MCU退出而让TFT接收来自spiFlash的数据。」<br>两片74HC595实现串转并的要点在于LC锁存信号的产生，每产生8个SCK脉冲，则自动产生一个LC上上升沿，这是时序生成与理调逻辑的一部分。实现的根本在于74HC161与74HC27的组合运用，如图6.13。首先对74HC161复位清零，此时[Q2:Q0]=000，74HC27是三输入或非门，其输出1Y，即595-LC为1；时钟的输入后[Q2:Q0]随之自增001、010 …… 在000之前595-LC均为0，而8个时钟之后，595-LC将变为1，即产生了上升沿。这里我给595-LC增加了两级74HC1G32作为缓冲，为的是增加一些延时，以使74HC595的存锁数据输出更稳定。<br>然后是液晶的WR信号的产生：从图6.12中可以看到，WR信号是一个GPIO与八位计数器输出最高位Q2的或非非（没错，是或非非）。当Q2为0时，WR受控于GPIO，此时可用于MCU对TFT预先进行初始化操作。当GPIO为0时，WR受控于Q2，每8个时钟会产生一个下降沿（前面那个或非非是为了推迟一下这个下降沿，以使16位并行数据写入液晶更稳定），并维持4个时钟周期。<br>基本的要点已经描述清楚了。至于时钟的产生，唯一的要求是要产生特定数量的时钟，而不能是连续不断的。比如一帧图像的数据量为800 * 480半字，我们要输出3072000个时钟才能让一帧图像显示到液晶上。所以我们不能用MCO或者是PWM，而要用SPI，如果是8位SPI，要写384000次，如果是16位SPI，则要写192000次。「当然，为了节省更多的CPU资源，我们可以使用DMA。当时钟不断的产生，一帧帧的图像显示到液晶上时，视频就流畅的播放出来了。」<br>我曾经把我这个“巧驱大屏”的实验讲给了我的同事听，他们在赞叹的同时，还说：“你不作FPGA真是浪费了！”其实我是作过一段时间的FPGA的，那还是在2007年在Intel中国研究院实习工作的时候。<br>好了，本章用3个实例阐述了本章最开头的那句话：「CPU时间是宝贵的，我们要把有限的CPU时间投入到更有意义的事情中去。」<br>实际开发中，充分地利用硬件资源，自行灵活扩展一些硬件电路，通常可以达到意想不到的效果，甚至可以化不可能为可能。</p><p>A「永远记住：我们很多时候作的是嵌入式软件的工作，但归根结底我们搞的还是硬件。」</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 奇淫巧技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式中实现应用层和硬件层分层管理</title>
      <link href="/20230701/learn_skill/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E5%B1%82%E5%92%8C%E7%A1%AC%E4%BB%B6%E5%B1%82%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86.html"/>
      <url>/20230701/learn_skill/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E5%B1%82%E5%92%8C%E7%A1%AC%E4%BB%B6%E5%B1%82%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以STM32为例，打开网络上下载的例程或者是购买开发板自带的例程，都会发现应用层中会有stm32f10x.h或者stm32f10x_gpio.h，这些文件严格来时属于硬件层的，如果软件层出现这些文件会显得很乱。<br>使用过Linux的童鞋们肯定知道linux系统无法直接操作硬件层，打开linux或者rt_thread代码会发现代码中都会有device的源文件，没错，这就是驱动层。<br><img src="/images/learn/stm32/BIS09V0LeY10fzezB3zmCA_001.png" alt="图片"></p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>原理就是将硬件操作的接口全都放到驱动链表上，在驱动层实现device的open、read、write等操作。当然这样做也有弊端，就是驱动find的时候需要遍历一遍驱动链表，这样会增加代码运行时间。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>国际惯例，写代码先写头文件。rt_thread中使用的是双向链表，为了简单在这我只用单向链表。有兴趣的可以自行研究rt_thread</p><h2 id="头文件接口"><a href="#头文件接口" class="headerlink" title="头文件接口:"></a>头文件接口:</h2><p>本次只实现如下接口，device_open  和device_close等剩下的接口可以自行研究。这样就可以在应用层中只调用如下接口可实现：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*    驱动注册*/</span><span class="token keyword">int</span> <span class="token function">cola_device_register</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*    驱动查找*/</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span><span class="token function">cola_device_find</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*    驱动读*/</span><span class="token keyword">int</span> <span class="token function">cola_device_read</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>  <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*    驱动写*/</span><span class="token keyword">int</span> <span class="token function">cola_device_write</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*    驱动控制*/</span><span class="token keyword">int</span> <span class="token function">cola_device_ctrl</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>  <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="头文件cola-device-h"><a href="#头文件cola-device-h" class="headerlink" title="头文件cola_device.h"></a>头文件cola_device.h</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_COLA_DEVICE_H_</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_COLA_DEVICE_H_</span></span> <span class="token keyword">enum</span> <span class="token class-name">LED_state</span><span class="token punctuation">&#123;</span>    LED_OFF<span class="token punctuation">,</span>    LED_ON<span class="token punctuation">,</span>    LED_TOGGLE<span class="token punctuation">,</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">cola_device</span>  <span class="token class-name">cola_device_t</span><span class="token punctuation">;</span> <span class="token keyword">struct</span> <span class="token class-name">cola_device_ops</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>  <span class="token punctuation">(</span><span class="token operator">*</span>init<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  <span class="token punctuation">(</span><span class="token operator">*</span>close<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span>  <span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>  <span class="token punctuation">(</span><span class="token operator">*</span>control<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">struct</span> <span class="token class-name">cola_device</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> name<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">cola_device_ops</span> <span class="token operator">*</span>dops<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">cola_device</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">/*    驱动注册*/</span><span class="token keyword">int</span> <span class="token function">cola_device_register</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*    驱动查找*/</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span><span class="token function">cola_device_find</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*    驱动读*/</span><span class="token keyword">int</span> <span class="token function">cola_device_read</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>  <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*    驱动写*/</span><span class="token keyword">int</span> <span class="token function">cola_device_write</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*    驱动控制*/</span><span class="token keyword">int</span> <span class="token function">cola_device_ctrl</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>  <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="源文件cola-device-c"><a href="#源文件cola-device-c" class="headerlink" title="源文件cola_device.c"></a>源文件cola_device.c</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cola_device.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdbool.h></span></span>  <span class="token keyword">struct</span> <span class="token class-name">cola_device</span> <span class="token operator">*</span>device_list <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">/*    查找任务是否存在*/</span><span class="token keyword">static</span> bool <span class="token function">cola_device_is_exists</span><span class="token punctuation">(</span> <span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">cola_device_t</span><span class="token operator">*</span> cur <span class="token operator">=</span> device_list<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> cur <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>name<span class="token punctuation">,</span>dev<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">device_list_inster</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">cola_device_t</span> <span class="token operator">*</span>cur <span class="token operator">=</span> device_list<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> device_list<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        device_list <span class="token operator">=</span> dev<span class="token punctuation">;</span>        dev<span class="token operator">-></span>next   <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> cur<span class="token operator">-></span>next<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur<span class="token operator">-></span>next <span class="token operator">=</span> dev<span class="token punctuation">;</span>        dev<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">/*    驱动注册*/</span><span class="token keyword">int</span> <span class="token function">cola_device_register</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> dev<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token function">cola_device_is_exists</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> dev<span class="token operator">-></span>name<span class="token punctuation">)</span> <span class="token operator">||</span>  <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> dev<span class="token operator">-></span>dops<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">device_list_inster</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">/*    驱动查找*/</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span><span class="token function">cola_device_find</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">cola_device_t</span><span class="token operator">*</span> cur <span class="token operator">=</span> device_list<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span> cur <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>name<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> cur<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*    驱动读*/</span><span class="token keyword">int</span> <span class="token function">cola_device_read</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>  <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dev<span class="token operator">-></span>dops<span class="token operator">-></span>read<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> dev<span class="token operator">-></span>dops<span class="token operator">-></span><span class="token function">read</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*    驱动写*/</span><span class="token keyword">int</span> <span class="token function">cola_device_write</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dev<span class="token operator">-></span>dops<span class="token operator">-></span>write<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> dev<span class="token operator">-></span>dops<span class="token operator">-></span><span class="token function">write</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*    驱动控制*/</span><span class="token keyword">int</span> <span class="token function">cola_device_ctrl</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span>  <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dev<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dev<span class="token operator">-></span>dops<span class="token operator">-></span>control<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> dev<span class="token operator">-></span>dops<span class="token operator">-></span><span class="token function">control</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span> cmd<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="硬件注册方式"><a href="#硬件注册方式" class="headerlink" title="硬件注册方式"></a>硬件注册方式</h2><p>以LED为例，初始化接口void led_register(void)，需要在初始化中调用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stm32f0xx.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"led.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cola_device.h"</span></span>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PORT_GREEN_LED</span>                 <span class="token expression">GPIOC                   </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PIN_GREENLED</span>                   <span class="token expression">GPIO_Pin_13              </span></span> <span class="token comment">/* LED亮、灭、变化 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_GREEN_OFF</span>                  <span class="token expression"><span class="token punctuation">(</span>PORT_GREEN_LED<span class="token operator">-></span>BSRR <span class="token operator">=</span> PIN_GREENLED<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_GREEN_ON</span>                   <span class="token expression"><span class="token punctuation">(</span>PORT_GREEN_LED<span class="token operator">-></span>BRR  <span class="token operator">=</span> PIN_GREENLED<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_GREEN_TOGGLE</span>               <span class="token expression"><span class="token punctuation">(</span>PORT_GREEN_LED<span class="token operator">-></span>ODR <span class="token operator">^=</span> PIN_GREENLED<span class="token punctuation">)</span></span></span>  <span class="token keyword">static</span> <span class="token class-name">cola_device_t</span> led_dev<span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">led_gpio_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    GPIO_InitTypeDef GPIO_InitStructure<span class="token punctuation">;</span>    <span class="token function">RCC_AHBPeriphClockCmd</span><span class="token punctuation">(</span>RCC_AHBPeriph_GPIOC<span class="token punctuation">,</span> ENABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Pin <span class="token operator">=</span> PIN_GREENLED<span class="token punctuation">;</span>                                GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Mode <span class="token operator">=</span> GPIO_Mode_OUT<span class="token punctuation">;</span>                         GPIO_InitStructure<span class="token punctuation">.</span>GPIO_Speed <span class="token operator">=</span> GPIO_Speed_50MHz<span class="token punctuation">;</span>                      GPIO_InitStructure<span class="token punctuation">.</span>GPIO_OType <span class="token operator">=</span> GPIO_OType_PP<span class="token punctuation">;</span>                         GPIO_InitStructure<span class="token punctuation">.</span>GPIO_PuPd <span class="token operator">=</span> GPIO_PuPd_NOPULL<span class="token punctuation">;</span>                      <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>PORT_GREEN_LED<span class="token punctuation">,</span> <span class="token operator">&amp;</span>GPIO_InitStructure<span class="token punctuation">)</span><span class="token punctuation">;</span>    LED_GREEN_OFF<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">led_ctrl</span><span class="token punctuation">(</span><span class="token class-name">cola_device_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>LED_TOGGLE <span class="token operator">==</span> cmd<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        LED_GREEN_TOGGLE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>     <span class="token punctuation">&#123;</span>            <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">cola_device_ops</span> ops <span class="token operator">=</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span>control <span class="token operator">=</span> led_ctrl<span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">led_register</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">led_gpio_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    led_dev<span class="token punctuation">.</span>dops <span class="token operator">=</span> <span class="token operator">&amp;</span>ops<span class="token punctuation">;</span>    led_dev<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"led"</span><span class="token punctuation">;</span>    <span class="token function">cola_device_register</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>led_dev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="应用层app代码"><a href="#应用层app代码" class="headerlink" title="应用层app代码"></a>应用层app代码</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"app.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"config.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cola_device.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cola_os.h"</span></span> <span class="token keyword">static</span> <span class="token class-name">task_t</span> timer_500ms<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token class-name">cola_device_t</span> <span class="token operator">*</span>app_led_dev<span class="token punctuation">;</span> <span class="token comment">//led每500ms状态改变一次</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">timer_500ms_cb</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">cola_device_ctrl</span><span class="token punctuation">(</span>app_led_dev<span class="token punctuation">,</span>LED_TOGGLE<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">app_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    app_led_dev <span class="token operator">=</span> <span class="token function">cola_device_find</span><span class="token punctuation">(</span><span class="token string">"led"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>app_led_dev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cola_timer_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_500ms<span class="token punctuation">,</span>timer_500ms_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cola_timer_start</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer_500ms<span class="token punctuation">,</span>TIMER_ALWAYS<span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样app.c文件中就不需要调用led.h头文件了，rtt就是这样实现的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这样就可以实现软硬件分层了，是不是非常好用！</p><h1 id="代码下载链接"><a href="#代码下载链接" class="headerlink" title="代码下载链接"></a>代码下载链接</h1><p><a href="/downloads/code/cola_os-master.zip">cola_os-master.zip</a><br><a href="https://gitee.com/schuck/cola_os">gitee.cola_os</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 奇淫巧技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用三种优雅的方式实现嵌入式状态机</title>
      <link href="/20230701/learn_skill/%E7%94%A8%E4%B8%89%E7%A7%8D%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8A%B6%E6%80%81%E6%9C%BA.html"/>
      <url>/20230701/learn_skill/%E7%94%A8%E4%B8%89%E7%A7%8D%E4%BC%98%E9%9B%85%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8A%B6%E6%80%81%E6%9C%BA.html</url>
      
        <content type="html"><![CDATA[<p>状态机的实现无非就是三个要素：状态、事件、响应。</p><p>转换成具体的行为，其实就三句话：</p><ul><li>发生了什么事？</li><li>现在系统处在什么状态？</li><li>在这样的状态下发生了这样的事，系统要干什么？</li></ul><p>用C语言实现状态机，主要有三种方法：<code>switch—case</code> 法、表格驱动法、函数指针法。下面给大家详细介绍一下。</p><h1 id="switch—case-法"><a href="#switch—case-法" class="headerlink" title="switch—case 法"></a><code>switch—case</code> 法</h1><p>状态用 <code>switch—case</code> 组织起来， 将事件也用<code>switch—case</code> 组织起来， 然后让其中一个 <code>switch—case</code> 整体插入到另一个 <code>switch—case</code> 的每一个 case 项中  。</p><p>「程序清单 List1  ：」</p><pre class="line-numbers language-none"><code class="language-none">switch(StateVal)&#123;    case S0:  switch(EvntID)  &#123;   case E1:    action_S0_E1(); &#x2F;*S0 状态下 E1 事件的响应*&#x2F;    StateVal &#x3D; new state value;&#x2F;*状态迁移，不迁移则没有此行*&#x2F;    break;   case E2:    action_S0_E2(); &#x2F;*S0 状态下 E2 事件的响应*&#x2F;    StateVal &#x3D; new state value;    break;   ......   case Em:    action_S0_Em(); &#x2F;*S0 状态下 Em 事件的响应*&#x2F;    StateVal &#x3D; new state value;    break;   default:    break;  &#125;  break;    case S1:  ......  break;    ......    case Sn:  ......  break;    default:  break;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的伪代码示例只是通用的情况，实际应用远没有这么复杂。虽然一个系统中事件可能有很多种，但在实际应用中，许多事件可能对某个状态是没有意义的。<br>例如在程序清单 List1中，如果 <code>E2、……</code> Em 对处在 S0 状态下的系统没有意义，那么在 S0 的 case 下有关事件E2、······ Em 的代码根本没有必要写,状态 S0 只需要考虑事件 E1 的处理就行了。<br>既然是两个 <code>switch—case</code> 之间的嵌套， 那么就有一个谁嵌套谁的问题， 所以说 <code>switch—case</code>法有两种写法：状态嵌套事件和事件嵌套状态。这两种写法都可以， 各有利弊， 至于到底选用哪种方式就留给设计人员根据具体情况自行决断吧。<br>关于 <code>switch—case</code> 法还有最后一点要说明， 因为 <code>switch—case</code> 的原理是从上到下挨个比较，越靠后，查找耗费的时间就越长，所以要注意状态和事件在各自的 switch 语句中的安排顺序，不推荐程序清单 List1 那样按顺序号排布的方式。出现频率高或者实时性要求高的状态和事件的位置应该尽量靠前。</p><hr><h1 id="表格驱动法"><a href="#表格驱动法" class="headerlink" title="表格驱动法"></a>表格驱动法</h1><p>如果说** <code>switch—case</code> 法是线性的<strong>，那么</strong>表格驱动法则是平面**的。表格驱动法的实质就是将状态和事件之间的关系固化到一张二维表格里， 把事件当做纵轴，把状态当做横轴，交点[Sn , Em]则是系统在 Sn 状态下对事件 Em 的响应  。</p><blockquote><p>表1 - 表格驱动法示例 </p><table><thead><tr><th align="left"></th><th align="left">S0</th><th align="left">S1</th><th align="left">S2</th></tr></thead><tbody><tr><td align="left">E2</td><td align="left">Node_S0E2</td><td align="left">Node_S1E2</td><td align="left">Node_S2E2</td></tr><tr><td align="left">E1</td><td align="left">Node_S0E1</td><td align="left">Node_S1E1</td><td align="left">Node_S2E1</td></tr><tr><td align="left">E0</td><td align="left">Node_S0E0</td><td align="left">Node_S1E0</td><td align="left">Node_S2E0</td></tr></tbody></table></blockquote><p>如表1， 我把表格中的 Node_SnEm 叫做状态机节点， 状态机节点 Node_SnEm 是系统在 Sn状态下对事件 Em 的响应。这里所说的响应包含两个方面：输出动作和状态迁移。状态机节点一般是一个类似程序清单 List2 中的结构体变量 。</p><pre class="line-numbers language-none"><code class="language-none">struct fsm_node&#123;    void (*fpAction)(void* pEvnt);    INT8U u8NxtStat;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序清单 List2 中的这个结构体有两个成员：fpAction 和 u8NxtStat。fpAction 是一个函数指针， 指向一个形式为 void func(void * pEvnt)的函数， func 这个函数是对状态转移中动作序列的标准化封装。<br>也就是说， 状态机在状态迁移的时候， 不管输出多少个动作、操作多少个变量、调用多少个函数，这些行为统统放到函数 func 中去做。<br>把动作封装好了之后，再把封装函数 func 的地址交给函数指针 fpAction，这样，想要输出动作，只需要调用函数指针 fpAction 就行了。<br>再看看上面的 func 函数，会发现函数有一个形参 pEvnt，这是一个类型为 void * 的指针， 在程序实际运行时指向一个能存储事件的变量，通过这个指针我们就能获知关于事件的全部信息，这个形参是很有必要的。<br>事件一般包括两个属性：事件的类型和事件的内容。<br>例如一次按键事件，我们不仅要知道这是一个按键事件，还要知道按下的到底是哪个键。<br>事件的类型和状态机当前的状态可以让我们在表1 的表格中迅速定位，确定该调用哪个动作封装函数， 但是动作封装函数要正确响应事件还需要知道事件的内容是什么， 这也就是形参pEvnt 的意义。<br>由于事件的多样性，存储事件内容的数据格式不一定一样，所以就把 pEvnt 定义成了 void * 型，以增加灵活性。<br>有关 fpAction 的最后一个问题：如果事件 Em 对状态 Sn 没有意义，那么状态机节点Node_SnEm 中的 fpAction 该怎么办？<br>我的答案是：那就让它指向一个空函数呗！前面不是说过么，什么也不干也叫响应。<br>u8NxtStat 存储的是状态机的一个状态值。我们知道， 状态机响应事件要输出动作， 也就是调用函数指针 fpAction 所指向的那个封装函数， 函数调用完毕后程序返回主调函数， 状态机对事件的响应就算结束了， 下一步就要考虑状态迁移的问题了。<br>可能要保持本状态不变， 也可能要迁移到一个新的状态，该如何抉择呢？u8NxtStat 存储的状态就是状态机想要的答案！<br>表1 的这张表格反映在 C 语言代码里就是一个二维数组，第 1 维就是状态机的状态，第 2维就是统一分类的事件，而数组的元素则是程序清单 List2 中的结构体常量。<br>如果程序中使用表格驱动法，还需要注意一些特别的事项。要将状态当做表格的横轴，那么就要求状态值集合必须满足以下条件：</p><blockquote><p>(1) 该集合是一个递增的等差整数数列<br>(2) 该数列初值为 0<br>(3) 该数列等差值为 1</p></blockquote><p>“事件” 作为纵轴，其特点和要求与用来做横轴的“状态” 完全一致。在 C 语言提供的数据类型中， 没有比枚举更符合以上要求的可选项了， 极力推荐将状态集合和事件类型集合做成枚举常量。表格驱动法的优点：调用接口统一 ，定位快速。<br>表格驱动法屏蔽了不同状态下处理各个事件的差异性，因此可以将处理过程中的共性部分提炼出来，做成标准统一的框架式代码，形成统一的调用接口。<br>根据程序清单 List2 中的状态机节点结构体，做成的框架代码如程序清单 List3 所示。<br>表格驱动法查找目标实际上就是一次二维数组的寻址操作，所以它的平均效率要远高于<code>switch—case</code> 法。</p><p>「程序清单 List3  ：」</p><pre class="line-numbers language-none"><code class="language-none">extern struct fsm_node g_arFsmDrvTbl[][]; &#x2F;*状态机驱动表格*&#x2F;INT8U u8CurStat &#x3D; 0; &#x2F;*状态暂存*&#x2F;INT8U u8EvntTyp &#x3D; 0; &#x2F;*事件类型暂存*&#x2F;void* pEvnt &#x3D; NULL; &#x2F;*事件变量地址暂存*&#x2F;struct fsm_node stNodeTmp &#x3D; &#123;NULL, 0&#125;; &#x2F;*状态机节点暂存*&#x2F;u8CurStat &#x3D; get_cur_state(); &#x2F;*读取当前状态*&#x2F;u8EvntTyp &#x3D; get_cur_evnt_typ(); &#x2F;*读取当前触发事件类型*&#x2F;pEvnt &#x3D; (void*)get_cur_evnt_ptr(); &#x2F;*读取事件变量地址*&#x2F;stNodeTmp &#x3D; g_arFsmDrvTbl[u8CurStat ][u8EvntTyp ];&#x2F;*定位状态机节点*&#x2F;stNodeTmp.fpAction(pEvnt ); &#x2F;*动作响应*&#x2F;set_cur_state(stNodeTmp.u8NxtStat); &#x2F;*状态迁移*&#x2F;.....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表格驱动法好则好矣，但用它写出来的程序还有点儿小问题，我们先来看看按照表格驱动法写出来的程序有什么特点 。<br>前面说过，表格驱动法可以把状态机调度的部分做成标准统一的框架代码，这个框架适用性极强， 不管用状态机来实现什么样的应用， 框架代码都不需要做改动， 我们只需要根据实际应用场合规划好状态转换图，然后将图中的各个要素（状态、事件、动作、迁移，有关“条件”要素一会儿再说）用代码实现就行了，我把这部分代码称作应用代码。<br>在应用代码的.c 文件中， 你会看到一个声明为 const 的二维数组， 也就是表1 所示的状态驱动表格， 还会看到许多彼此之间毫无关联的函数， 也就是前面提到的动作封装函数。<br>这样的一份代码， 如果手头上没有一张状态转换图， 让谁看了也会一头雾水， 这样的格式直接带来了代码可读性差的问题。<br>如果我们想给状态机再添加一个状态，反映到代码上就是给驱动表格再加一列内容，同时也要新添加若干个动作封装函数。<br>如果驱动表格很大， 做这些工作是很费事儿的， 而且容易出错。如果不小心在数组中填错了位置， 那么程序跑起来就和设计者的意图南辕北辙了，<br>远没有在 <code>switch—case</code> 法中改动来得方便、安全。Extended State Machine 的最大特点就是状态机响应事件之前先判断条件，根据判定结果选择执行哪些动作，转向哪个状态。<br>也就是说，系统在状态 Sn 下发生了事件 Em 后，转向的状态不一定是唯一的，这种灵活性是 Extended State Machine 的最有价值的优点。<br>回过头来看看程序清单 List2 中给出的状态机节点结构体，如果系统在状态 Sn 下发生了事件 Em， 状态机执行完 fpAction 所给出的动作响应之后， 必须转到 u8NxtStat 指定的状态。<br>表格驱动法的这个特性直接杜绝了 Extended State Machine 在表格驱动法中应用的可能性， 所以表格驱动法的代码实现中不存在“条件” 这个状态机要素。ESM，你是如此的优秀，我怎么舍得抛弃你 ？！<br>再看表1 所示的表格驱动法示例图，如果我们把表格中的代表事件的纵轴去掉，只留下代表状态的横轴，将一列合并成一格，前文提到的问题是不是能得到解决呢？不错！这就是失传江湖多年的《葵花宝典》 ——阉割版表格驱动法 ！！<br>阉割版表格驱动法，又名压缩表格驱动法，一维状态表格与事件 <code>switch—case</code> 的合体。压缩表格驱动法使用了一维数组作为驱动表格，数组的下标即是状态机的各个状态。<br>表格中的元素叫做压缩状态机节点， 节点的主要内容还是一个指向动作封装函数的函数指针， 只不过这个动作封装函数不是为某个特定事件准备的， 而是对所有的事件都有效的。<br>节点中不再强制指定状态机输出动作完毕后所转向的状态， 而是让动作封装函数返回一个状态， 并把这个状态作为状态机新的状态。<br>压缩表格驱动法的这个特点， 完美的解决了 Extended State Machine 不能在表格驱动法中使用的问题 。<br>程序清单 List4 中的示例代码包含了压缩状态机节点结构体和状态机调用的框架代码。<br>「程序清单 List4：」</p><pre class="line-numbers language-none"><code class="language-none">struct fsm_node &#x2F;*压缩状态机节点结构体*&#x2F;&#123; INT8U (*fpAction)(void* pEvnt); &#x2F;*事件处理函数指针*&#x2F; INT8U u8StatChk; &#x2F;*状态校验*&#x2F;&#125;;......u8CurStat &#x3D; get_cur_state(); &#x2F;*读取当前状态*&#x2F;......if(stNodeTmp.u8StatChk &#x3D;&#x3D; u8CurStat )&#123; u8CurStat &#x3D; stNodeTmp.fpAction(pEvnt ); &#x2F;*事件处理*&#x2F; set_cur_state(u8CurStat ); &#x2F;*状态迁移*&#x2F;&#125;else&#123; state_crash(u8CurStat ); &#x2F;*非法状态处理*&#x2F;&#125;.....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对照程序清单 List2，就会发现程序清单 List4 中 struct fsm_node 结构体的改动之处。首先， fpAction 所指向函数的函数形式变了，动作封装函数 func 的模样成了这样的了：<br><code>INT8U func(void * pEvnt);</code><br>现在的动作封装函数 func 是要返回类型为 INT8U 的返回值的，这个返回值就是状态机要转向的状态， 也就是说， 压缩表格驱动法中的状态机节点不负责状态机新状态的确定， 而把这项任务交给了动作封装函数 func， func 返回哪个状态， 状态机就转向哪个状态。<br>新状态由原来的常量变成了现在的变量，自然要灵活许多。上面说到现在的动作封装函数 func 要对当前发生的所有的事件都要负责， 那么 func 怎么会知道到底是哪个事件触发了它呢？看一下 func 的形参 void * pEvnt 。<br>在程序清单 List2 中我们提到过，这个形参是用来向动作封装函数传递事件内容的，但是从前文的叙述中我们知道， pEvnt 所指向的内存包含了事件的所有信息， 包括事件类型和事件内容 ， 所以通过形参 pEvnt ， 动作封装函数 func 照样可以知道事件的类型。<br>程序清单 List4 中 struct fsm_node 结构体还有一个成员 u8StatChk ， 这里面存储的是状态机 的一个状态，干什么用的呢？<br>玩 C 语言数组的人都知道，要严防数组寻址越界。<br>要知道，压缩表格驱动法的驱动表格是一个以状态值为下标的一维数组， 数组元素里面最重要的部分就是一个个动作封装函数的地址。<br>函数地址在单片机看来无非就是一段二进制数据， 和内存中其它的二进制数据没什么两样，不管程序往单片机 PC 寄存器里塞什么值，单片机都没意见。假设程序由于某种意外而改动了存储状态机当前状态的变量，使变量值变成了一个非法状态。<br>再发生事件时， 程序就会用这个非法的状态值在驱动表格中寻址， 这时候就会发生内存泄露，程序拿泄露内存中的未知数据当函数地址跳转，不跑飞才怪！<br>为了防止这种现象的发生， 压缩状态机节点结构体中又添加了成员 u8StatChk 。u8StatChk中存储的是压缩状态机节点在一维驱动表格的位置， 例如某节点是表格中的第 7 个元素， 那么这个节点的成员 u8StatChk 值就是 6。<br>看一下程序清单 List4 中的框架代码示例， 程序在引用函数指针 fpAction 之前， 先检查当前状态和当前节点成员 u8CurStat 的值是否一致，一致则认为状态合法，事件正常响应，如果不一致，则认为当前状态非法，转至意外处理，最大限度保证程序运行的安全。<br>当然，如果泄露内存中的数据恰好和 u8CurStat 一致，那么这种方法真的就回天乏力了。<br>还有一个方法也可以防止状态机跑飞，如果状态变量是枚举，那么框架代码就可以获知状态值的最大值， 在调用动作封装函数之前判断一下当前状态值是否在合法的范围之内， 同样能保证状态机的安全运行。<br>压缩表格驱动法中动作封装函数的定义形式我们已经知道了，函数里面到底是什么样子的呢？程序清单 List5 是一个标准的示例。<br>「程序清单List8：」</p><pre class="line-numbers language-none"><code class="language-none">INT8U action_S0(void* pEvnt)&#123; INT8U u8NxtStat &#x3D; 0; INT8U u8EvntTyp &#x3D; get_evnt_typ(pEvnt); switch(u8EvntTyp ) &#123;  case E1:   action_S0_E1(); &#x2F;*事件 E1 的动作响应*&#x2F;   u8NxtStat &#x3D; new state value; &#x2F;*状态迁移，不迁移也必须有本行*&#x2F;   break;   ......  case Em:   action_S0_Em(); &#x2F;*事件 Em 的动作响应*&#x2F;   u8NxtStat &#x3D; new state value; &#x2F;*状态迁移，不迁移也必须有本行*&#x2F;   break;  default:   ; &#x2F;*不相关事件处理*&#x2F;   break; &#125; return u8NxtStat ; &#x2F;*返回新状态*&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从程序清单 List5 可以看出， 动作封装函数其实就是事件 <code>switch—case</code> 的具体实现。函数根据形参 pEvnt 获知事件类型， 并根据事件类型选择动作响应， 确定状态机迁移状态， 最后将新的状态作为执行结果返回给框架代码。<br>有了这样的动作封装函数， Extended State Machine 的应用就可以完全不受限制了！到此，有关压缩表格驱动法的介绍就结束了。<br>个人认为压缩表格驱动法是相当优秀的，它既有表格驱动法的简洁、高效、标准，又有 <code>switch—case</code> 法的直白、灵活、多变，相互取长补短，相得益彰。</p><hr><h1 id="函数指针法"><a href="#函数指针法" class="headerlink" title="函数指针法"></a>函数指针法</h1><p>上面说过，用 C 语言实现状态机主要有 3 种方法(<code>switch—case</code> 法、表格驱动法、函数指针法)， 其中函数指针法是最难理解的， 它的实质就是把动作封装函数的函数地址作为状态来看待。不过，有了之前压缩表格驱动法的铺垫，函数指针法就变得好理解了，因为两者本质上是相同的。<br>压缩表格驱动法的实质就是一个整数值(状态机的一个状态)到一个函数地址(动作封装函数)的一对一映射， 压缩表格驱动法的驱动表格就是全部映射关系的直接载体。在驱动表格中通过状态值就能找到函数地址，通过函数地址同样能反向找到状态值。<br>我们用一个全局的整型变量来记录状态值，然后再查驱动表格找函数地址，那干脆直接用一个全局的函数指针来记录状态得了，还费那劳什子劲干吗？！这就是函数指针法的前世今生。<br>用函数指针法写出来的动作封装函数和程序清单 List5 的示例函数是很相近的， 只不过函数的返回值不再是整型的状态值， 而是下一个动作封装函数的函数地址， 函数返回后， 框架代码再把这个函数地址存储到全局函数指针变量中。<br>相比压缩表格驱动法，在函数指针法中状态机的安全运行是个大问题，我们很难找出一种机制来检查全局函数指针变量中的函数地址是不是合法值。如果放任不管， 一旦函数指针变量中的数据被篡改，程序跑飞几乎就不可避免了。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有关状态机的东西说了那么多，相信大家都已经感受到了这种工具的优越性，状态机真的是太好用了！其实我们至始至终讲的都是有限状态机(Finite State Machine 现在知道为什么前面的代码中老是有 fsm 这个缩写了吧！)， 还有一种比有限状态机更 NB 更复杂的状态机， 那就是层次状态机(Hierarchical State Machine 一般简写为 HSM)。<br>通俗的说，系统中只存在一个状态机的叫做有限状态机，同时存在多个状态机的叫做层次状态机(其实这样解释层次状态机有些不严谨， 并行状态机也有多个状态机， 但层次状态机各个状态机之间是上下级关系，而并行状态机各个状态机之间是平级关系)。<br>层次状态机是一种父状态机包含子状态机的多状态机结构，里面包含了许多与面向对象相似的思想， 所以它的功能也要比有限状态机更加强大， 当一个问题用有限状态机解决起来有些吃力的时候， 就需要层次状态机出马了。<br>层次状态机理论我理解得也不透彻， 就不在这里班门弄斧了，大家可以找一些有关状态机理论的专业书籍来读一读。要掌握状态机编程，理解状态机(主要指有限状态机)只是第一步，也是最简单的一步，更重要的技能是能用状态机这个工具去分析解剖实际问题：划分状态、 提取事件、 确定转换关系、规定动作等等，形成一张完整的状态转换图，最后还要对转换图进行优化，达到最佳。<br>把实际问题变成了状态转换图， 工作的一大半就算完成了， 这个是具有架构师气质的任务，剩下的问题就是按照状态图编程写代码了，这个是具有代码工特色的工作。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 奇淫巧技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32F30x的串口不定长DMA接收和发送史诗级例子</title>
      <link href="/20230630/learn_skill/GD32F30x%E7%9A%84%E4%B8%B2%E5%8F%A3%E4%B8%8D%E5%AE%9A%E9%95%BFDMA%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81%E5%8F%B2%E8%AF%97%E7%BA%A7%E4%BE%8B%E5%AD%90.html"/>
      <url>/20230630/learn_skill/GD32F30x%E7%9A%84%E4%B8%B2%E5%8F%A3%E4%B8%8D%E5%AE%9A%E9%95%BFDMA%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81%E5%8F%B2%E8%AF%97%E7%BA%A7%E4%BE%8B%E5%AD%90.html</url>
      
        <content type="html"><![CDATA[<p>虽然串口是单片机最常用的一种外设，今天就由我来给大家展示一个最好用的串口接收发送例子解说吧。DMA不定长接收和DMA发送。<br>GD32单片机自带串口发送接收有三种方式，下面就简单介绍一下三种处理数据的方式：</p><ul><li>轮询方式（Polling）：使用轮询方式发送和接收数据。在发送数据时，检查串口的状态寄存器，确认发送缓冲区为空后将数据写入发送寄存器。在接收数据时，检查状态寄存器的接收缓冲区非空标志位，然后读取接收寄存器中的数据。这种方式简单易懂，但需要不断检查状态寄存器，可能会浪费处理器的时间。</li><li>中断方式（Interrupt）：配置串口为中断模式，在数据发送或接收完成时触发中断。当数据准备就绪时，触发发送或接收中断，在中断处理程序中处理数据的发送和接收。这种方式相对于轮询方式来说，减少了处理器的负载，但需要正确配置中断和编写中断处理程序。</li><li>DMA 方式（Direct Memory Access）：使用 DMA 控制器来完成数据的传输。DMA 可以在不依赖处理器的情况下直接从内存复制数据到串口发送寄存器，或从串口接收寄存器复制数据到内存。这种方式能够大大减轻处理器的负担，并且适用于大量数据的传输。</li></ul><p>前面的两种方式就不做详细的例程了，直接第三种方式开干，废话不多说下面直接上干货。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 串口初始化void gd_usart_init(uint32_t com_id)&#123;  &#x2F;* enable_gpio_clock *&#x2F;  rcu_periph_clock_enable(COM_GPIO_CLK[com_id]);  &#x2F;* enable_usart_clock *&#x2F;  rcu_periph_clock_enable(COM_CLK[com_id]);  &#x2F;* connect_port_to_usarTxTx *&#x2F;  qpio_init(COM_GPIO_PORT[com_id], GPIO_MODE_AF_PP, GPIO_OSPEED_50MHZ, COM_TX_PIN[com_id]);  &#x2F;* connect_port_to_usarTxRx *&#x2F;  gpio_init(COM_GPIO_PORT[com_id], GPIO_MODE_IN_FLOATING, GPIO_OSPEED_50MHZ, COM_RX_PIN[com_id]);   &#x2F;* USART_configure *&#x2F;  usart_disable(COM_NUM[com_id]);  usart_deinit(COM_NUM[com_id]);  usart_baudrate_set(COM_NUM[com_id], COM_BAUD[com_id]);              &#x2F;&#x2F; 配置波特率  usart_parity_confiq(COM_NUM[com_id], USART_PMNONE);                 &#x2F;&#x2F; 配置奇偶校验  usart_word_lenath_set(COM_NUM[com_id], USART_W8BTT);                &#x2F;&#x2F; 西管数据付  usart_stop_bit_set(COM_NUM[com_id], USART_STB_1BIT);                &#x2F;&#x2F; 配置停止位  usart_hardware_flow_rts_confiq(COM_NUM[com_id], USARTRTS_DISABLE);  &#x2F;&#x2F; 配置RTS  usart_hardware_flow_cts_config(COM_NUM[com_id], USART_CTS_DISABLE); &#x2F;&#x2F; 配置CTS  &#x2F;&#x2F; usart_data_first_confia(comUSART_MSBF_LSB);&#x2F;&#x2F; 数据首先由LSB&#x2F;MSB发送&#x2F;接收  usart_receive_config(COM_NUM[com_id], USART_RECEIVE_ENABLE);   &#x2F;&#x2F; 使能接收  usart_transmit_config(COM_NUM[com_id], USART_TRANSMIT_ENABLE); &#x2F;&#x2F; 使能发送  usart_enable(COM_NUM[com_id]);                                 &#x2F;&#x2F; 使能串口  usart_dma_receive_config(COM_NUM[com_id], USART_DENR_ENABLE);  &#x2F;&#x2F; 使能DMA接收  usart_dma_transmit_config(COM_NUM[com_id], USART_DENT_ENABLE); &#x2F;&#x2F; 使能DMA发送  usart_flag_clear(COM_NUM[com_id], USART_FLAG_TC);              &#x2F;&#x2F; 清除发送完成标志  usart_interrupt_enable(COM_NUM[com_id], USART_INT_IDLE);       &#x2F;&#x2F; 使用串口空闲中断  &#x2F;&#x2F; usart_interrupt_enable(COM_NUM[com_id], USART_INT_RBNE);&#x2F;&#x2F; 使能串口接收中新  &#x2F;&#x2F; usart_interrupt_enable(COM_NUM[com_id], USART_INT_TBE);&#x2F;&#x2F; 使能串口发送中断&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 串口中断函数配置void usart_dma_nvic_init()&#123;  &#x2F;&#x2F; UARTO配置中断  nvic_irg_enable(USARTO_IRQn, 2, 1);  &#x2F;&#x2F; 串口中断  nvic_irg_enable(DMAO_Channel3_IRQn, 6, 1); &#x2F;&#x2F; DMA接收中断  nvic_irg_enable(DMAO_Channel4_IRQn, 6, 1); &#x2F;&#x2F; DMA接收中断  &#x2F;&#x2F; UART1配置中断  nvic_irq_enable(USART1_IRQn, 2, 2);  &#x2F;&#x2F; 串口中断  nvic_irg_enable(DMAO_Channe15_IRQn, 6, 2); &#x2F;&#x2F; DMA接收中断  nvic_irq_enable(DMAO_Channe16_IRQn, 6, 2); &#x2F;&#x2F; DMA接收中断&#125;&#x2F;&#x2F; 串口发送DMA配置void usart_dma_tx_config(uint32_t_com_id)&#123;  dma_parameter_struct dma_init_struct;  &#x2F;* enable_DMA0 *&#x2F;  rcu_periph_clock_enable(COM_DMA_CLK[com_id]); &#x2F;&#x2F; 时钟配置  dma_deinit(COM_DMAx[com_id], COM_DMA_CHTx[com_id]);  dma_init_struct.direction &#x3D; DMA_MEMORY_TO_PERIPHERAL;                           &#x2F;&#x2F; 数据从内存(缓存)到外设  dma_init_struct.memory_addr &#x3D; (uint32_t)(&amp;usart_task_data[com_id].snd.snd_buf); &#x2F;&#x2F; 缓存BUE  dma_init_struct.memory_inc &#x3D; DMA_MEMORY_INCREASE_ENABLE;                        &#x2F;&#x2F; 内存(缓存)地址怎加开启  dma_init_struct.memory_width &#x3D; DMA_MEMORY_WIDTH_8BIT;                           &#x2F;&#x2F; 内存数据宽度8bit，1字节存储  dma_init_struct.number &#x3D; USART1_SND_BUF_SIZE;  &#x2F;&#x2F; 缓存大小  dma_init_struct.periph_addr &#x3D; (uint32_t)(&amp;USART_DATA(COM_NUM[com_id])); &#x2F;&#x2F; 传输数据外设地址  dma_init_struct.periph_inc &#x3D; DMA_PERIPH_INCREASE_DISABLE;               &#x2F;&#x2F; 禁止外设地址增加  dma_init_struct.periph_width &#x3D; DMA_PERIPHERAL_WIDTH_8BIT;               &#x2F;&#x2F; 外设宽度  dma_init_struct.priority &#x3D; DMA_PRIORITY_ULTRA_HIGH;                     &#x2F;&#x2F; MDA动作优先级(最高)  dma_init(COM_DMAx[com_id], COM_DMA_CHTx[com_id], &amp;dma_init_struct);     &#x2F;&#x2F; 初始化  &#x2F;*_configure_DMA_mode_*&#x2F;  dma_memory_to_memory_disable(COM_DMAx[com_id], COM_DMA_CHTx[com_id]); &#x2F;&#x2F; 关闭内存到内存方式  &#x2F;&#x2F; dma_channel_enable(COM_DMAx[com_id], COM_DMA_CHTX[com_id]);          &#x2F;&#x2F; DMA开启  dma_interrupt_enable(COM_DMAx[com_id], COM_DMA_CHTX[com_id], DMA_INT_FLAG_FTF); &#x2F;&#x2F; DMA传输完成中断  dma_circulation_disable(COM_DMAx[com_id], COM_DMA_CHTX[com_id]);                &#x2F;&#x2F; 禁止循环接收&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 串口接收DMA配置void usart_dma_rx_config(uint32_t_com_id)&#123;  dma_parameter_struct dma_init_struct;  &#x2F;* enable_DMA0*&#x2F;  rcu_periph_clock_enable(COM_DMA_CLK[comid]); &#x2F;&#x2F; 时钟配置  &#x2F;* deinitialize_DMA_channel3(USARTO_tx) *&#x2F;  dma_deinit(COM_DMAx[com_id], COM_DMA_CHRX[comid]);  dma_init_struct.direction &#x3D; DMA_PERIPHERAL_TO_MEMORY;                   &#x2F;&#x2F; 数据从外设到内存(缓存)  dma_init_struct.memory_addr &#x3D; (uint32_t)(&amp;usart_task_data[comid].rec.buf[usart_task_data[com_id].rec.index]); &#x2F;&#x2F; 缓存BUE  dma_init_struct.memory_inc &#x3D; DMA_MEMORY_INCREASE_ENABLE;                &#x2F;&#x2F; 内存(绣存)地址怎加开启  dma_init_struct.memory_width &#x3D; DMA_MEMORY_WIDTH_8BIT;                   &#x2F;&#x2F; 内存数据宽度8bit，1字节存储  dma_init_struct.number &#x3D; USART1_REC_BUFSIZE;                            &#x2F;&#x2F; 缓存大小  dma_init_struct.periph_addr &#x3D; (uint32_t)(&amp;USART_DATA(COM_NUM[com_id])); &#x2F;&#x2F; 数据入口地址  dma_init_struct.periph_inc &#x3D; DMA_PERIPH_INCREASE_DISABLE;               &#x2F;&#x2F; 禁止外设地址增加  dma_init_struct.periph_width &#x3D; DMA_PERIPHERAL_WIDTH_8BIT;               &#x2F;&#x2F; 外设宽度  dma_init_struct.priority &#x3D; DMA_PRIORITY_UTRA_HIGH;                      &#x2F;&#x2F; MDA动作优先级(最高)  dma_init(COM_DMAx[com_id] _COM_DMA_CHRx[com_id], &amp;dma_init_struct);     &#x2F;&#x2F; 初始化  &#x2F;*_confiqure_dMA_mode_*&#x2F;  dma_circulation_disable(COM_DMAx[com_id], COM_DMA_CHRx[comid]);         &#x2F;&#x2F; 禁止循环接收  dma_memory_to_memory_disable(COM_DMAx[com_id], COM_DMACHRx[comid]);     &#x2F;&#x2F; 关闭内存到内存方式  dma_channel_enable(COM_DMAx[com_id], COM_DMA_CHRx[com_id]);             &#x2F;&#x2F; DMA开启  dma_interrupt_enable(COM_DMAx[com_id] COM_DMA_CHRx[comid], DMA_INTFTF); &#x2F;&#x2F; DMA传输完成中断&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; DMA发送缓存uint8_t load_usart_dma_send(uint8_t com_id, uint8_t *src, uint16_t len)&#123;  if (TRUE &#x3D;&#x3D; usart_task_data[com_id].snd.snd_ok) &#123;    &#x2F;&#x2F; 必须加上此判断，否则会导致usart1_task_data.snd.snd_ok为FALSE，而不会产生DMA发送完成中断，导致snd_ok永远锁死为FALSE    if (len &lt;&#x3D; 0) &#123;      return FALSE;    &#125;    if (len &gt;&#x3D; USART1_SND_BUF_SIZE) &#123;      len &#x3D; USART1_SND_BUF_SIZE;    &#125;    memcpy(usart_task_data[com_id].snd.snd_bufsrclen);    dma_memory_address_config(DMA0, DMA_CH6(uint32_t)(usart_task_data[com_id].snd.snd_buf));    usart_task_data[com_id].snd.sndlen &#x3D; len;    return_usart_dma_send(com_id);  &#125;  return FALSE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; DMA发送uint8_t usart_dma_send(uint8_t com_id)&#123;  if (TRUE &#x3D;&#x3D; usart_task_data[com_id].snd.snd_ok) &#123;    &#x2F;&#x2F; 必须加上此判断，否则会导致snd_ok为FALSE，而不会产生DMA发送完成中断，导致snd_ok永远锁死为FALSE    if (usart_task_data[com_id].snd.snd_len &lt;&#x3D; 0) &#123;      return FALSE;    &#125;    usart_task_data[com_id].snd.snd_ok &#x3D; FALSE;    &#x2F;&#x2F; TDO:执行DMA发送    usart_flag_clear(COM_NUM[com_id], USART_FLAG_TC);    dma_channel_disable(COM_DMAx[com_id], COM_DMA_CHTx[com_id]);    dma_flag_clear(COM_DMAx[com_id], COM_DMA_CHTx[com_id], DMA_FLAG_FTF);    &#x2F;&#x2F; dma_memory_address_config    dma_transfernumberconfig(COM_DMAx[com_id], COM_DMA_CHTx[com_id], usart_task_data[com_id].snd.snd_len);    dma_channel_enable(COM_DMAx[com_id], COM_DMA_CHTx[com_id]);    return TRUE;  &#125;  return FALSE;&#125;&#x2F;&#x2F; 发生USART1的DMA接收中断，回调void usart_dma_rec_ok_call_back(uint8_t com_id)&#123;  int i;  for (i &#x3D; 0; i &lt; USART1_REC_MUL_NUM; i++) &#123;    if (usart_task_data[com_id].rec.rec_ok[i] &#x3D;&#x3D; TRUE) &#123;      load_usart_dma_send(com_id, (uint8_t*)(&amp;usart_task_data[com_id].rec.buf[i]), usart_task_data[com_id].rec.len[i]);      usart_task_data[com_id].rec.rec_ok[i] &#x3D; FALSE;      break;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 串口数据处理void usart_manu_rec_ok(uint8_t com_id)&#123;  int len &#x3D; 0;  &#x2F;&#x2F; uart_rtimer_t *ptmr;  &#x2F;&#x2F; OS_ENTER_CRITICAL;  dma_channel_disable(COM_DMAx[com_id], COM_DMA_CHRx[com_id]);  dma_interrupt_flag_clear(COM_DMAx[com_id], COM_DMA_CHRx[com_id], DMA_INT_FLAG_FTF);  &#x2F;&#x2F; ptmr&#x3D;&amp;uart_timer_recv_data.timer[UART1_T_RECV];  &#x2F;&#x2F; 取消时间间隔接收，避免这里DMA和串口定时模块同时处理  &#x2F;&#x2F; ptmr-&gt;last_index&#x3D;0;  &#x2F;&#x2F; ptmr-&gt;cnt&#x3D;0;  usart_task_data[com_id].rec.rec_ok[usart_task_data[com_id].rec.index] &#x3D; TRUE;  &#x2F;&#x2F; 获取数据长度  usart_task_data[com_id].rec.len[usart_task_data[com_id].rec.index] &#x3D; usart_curr_rec_counter(com_id);  if (0 &#x3D;&#x3D; usart_task_data[com_id].rec.len[usart_task_data[com_id].rec.index]) &#123;    &#x2F;&#x2F; 此时说明DMA接收已经溢出了，导致DMA又重新开始循环计数    usart_task_data[com_id].rec.len[usart_task_data[com_id].rec.index] &#x3D; USART1_REC_BUF_SIZE;    usart_task_data[com_id].rec.rec_ok[usart_task_data[com_id].rec.index] &#x3D; FALSE;  &#125;  &#x2F;&#x2F; 更换下一个BUF接收  usart_task_data[com_id].rec.index++;  usart_task_datai[com_id].rec.index &#x3D; usart_task_datai[com_id].rec.index % USARTI_REC_MUL_NUM; &#x2F;&#x2F; 2  &#x2F;&#x2F; 配置DMA  usart_dma_rx_config(com_id);  usart_dma_rec_ok_call_back(com_id); &#x2F;&#x2F; DMA回调函数  &#x2F;&#x2F;_OS_EXIT_CRITICAL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 空闲中断处理void usart_IDLE_DMA_read(uint8_t com_id)&#123;  if (usart_interrupt_flag_get(COM_NUM[com_id], USART_INT_FLAG_IDLE) !&#x3D; RESET) &#123; &#x2F;&#x2F;_空闲中断标记被置位    usart_interrupt_flag_clear(COM_NUM[com_id], USART_INT_FLAG_IDLE);    usart_manu_rec_ok(com_id);    &#x2F;&#x2F; 注意GD32F303DMA_接空闲中个寄器，清完成标志，要不然会无限进入中断死机。    USART_DATA(COM_NUM[com_id]);  &#125;&#125;&#x2F;&#x2F; 发生USART1的DMA发送中断，回调void usart_dma_snd_ok_call_back(uint8_t com_id)&#123;  dma_interrupt_flag_clear(COM_DMAx[com_id], COM_DMA_CHTx[com_id], DMA_INT_FLAG_FTF);  usart_task_data[com_id].snd.snd_ok &#x3D; TRUE;           &#x2F;&#x2F; 发送完成，表明发送缓存是空闲的  dma_channel_disable(COM_DMAx[com_id], COM_DMA_CHTx[com_id]); &#125; &#x2F;&#x2F; 发送DMA函数void DMAX_CHx_Tx_IRQHandler(uint8_t com_id)&#123;  usart_flag_clear(COM_NUM[com_id], USART_FLAG_TC);  dma_flag_clear(COM_DMAx[com_id], COM_DMA_CHRx[com_id], DMA_FLAG_FTF);  usart_dma_snd_ok_call_back(com_id);  dma_channel_disable(COM_DMAx[com_id], COM_DMA_CHRx[com_id]);&#125;&#x2F;&#x2F; 接收DMA函数void DMAx_CHx_Rx_IRQHandler(uint8_tcom_id)&#123;  if (dma_interrupt_flag_qet(COM_DMAx[com_id], COM_DMA_CHRx[com_id], DMA_INT_FLAG_FTF) &#x3D;&#x3D; _SET) &#123;    usart_manu_rec_ok(com_id);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>此例程就算两串口接起来无限对发也不影响主程序正常跑。上面所有的配置都是GD32F303配置。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 通讯传输 </tag>
            
            <tag> 工程实例 </tag>
            
            <tag> 奇淫巧技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现 MCU软件中多个模块初始化函数的优雅调用</title>
      <link href="/20230629/learn_skill/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-MCU%E8%BD%AF%E4%BB%B6%E4%B8%AD%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E9%9B%85%E8%B0%83%E7%94%A8.html"/>
      <url>/20230629/learn_skill/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-MCU%E8%BD%AF%E4%BB%B6%E4%B8%AD%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E9%9B%85%E8%B0%83%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><blockquote><p>做嵌入式开发的需要把需要把板载的每一个外围设备都进行初始化，有时候我们为了代码的可读性、易移植性会把每个模块单独封装，使用不同的.c和.h文件进行管理，在模块对应的.h文件中会把向外开放的API接口申明出来，方便上层调用，其中模块的初始化代码就包含在开放的API中，这样就使得上层的软件需要依赖于底层的接口，当底层变化时或头文件依赖更改时，需要重新修改代码，模块少还好点，模块多的时候就非常痛苦了。同时也带来另一个问题，软件中每增加一个模块都要在主函数中增加模块的初始化代码，每删减一个模块，都要在主函数的初始化代码中删减一个模块，这样无疑是不友好的。<br>那Linux中我新写的模块为什么不需要这样操作呢？单片机的开发中能不能也同样实现这样的功能呢？<br>答案肯定是可以的，怎么做下面我们一起来看下。</p></blockquote><h1 id="一般的模块化开发"><a href="#一般的模块化开发" class="headerlink" title="一般的模块化开发"></a>一般的模块化开发</h1><p>假如我现在开发的系统中有3个模块，分别是GPS、陀螺仪、触摸屏，正常我们在软件设计中会分别建立以下文件用于初始化这些模块的硬件接口以及驱动代码如下：<br><img src="/images/learn/stm32/qVdRNPHRLzvJIFbC-PL0DQ-1.png"></p><blockquote><ul><li>硬件接口层：<br>  实现硬件接口的初始化，如串口、I2C、SPI等，配置GPIO模式以及中断优先级等。</li><li>驱动层：<br>  实现外围模块内部寄存器的配置或初始化模块的工作模式等。</li><li>应用层：<br>  业务逻辑处理。</li></ul></blockquote><p>按照这个逻辑就是下层向上层提供一个接口用于初始化，最终在APP程序中调用初始化程序。而主函数中可能是这样的代码结构：</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;main.h&quot;#include &quot;drv_gps.h&quot;#include &quot;drv_lcd.h&quot;#include &quot;drv_mpu6050.h&quot;int main(void)&#123;  &#x2F;* GPS模块初始化 *&#x2F;  drv_gps_init();  &#x2F;* LCD初始化 *&#x2F;  drv_lcd_init();  &#x2F;* 陀螺仪初始化 *&#x2F;  drv_mpu6050_init();  for(;;)  &#123;    &#x2F;* ... *&#x2F;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中每增加一个模块都需要包含对应的头文件，在main函数中也要修改初始化的代码，去掉一个模块也是这样的，增加了软件的耦合度，无疑不是明智的，下面就来探索下怎么自动的实现模块的初始化，在不修改main函数的代码的前提下，同时优雅的初始化模块。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><blockquote><p>把每个模块的初始化代码用C拓展语法中的<code>__attribute__</code>设置其属性，定义在某一个段(section)中，这样我们只要在初始化的时候把这个段中所有的函数执行一遍就可以了。<br>新问题来了，为什么放在某一段中就能运行呢？<br>我们知道，函数名本身就是一个地址，用指针指向这个地址时，调用这个指针去运行这段代码就可以了，而我们把函数放在这个段中，我们是可以获取段的起始和终止地址的，有了这些条件，就能把段中的每个函数都遍历运行一遍了。</p></blockquote><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>有了上述思路后，我们先来看下我的main函数的代码实现。</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;main.h&quot;int main(void)&#123;    &#x2F;* System module initialization *&#x2F;  System_Config();&#125;    不管新增或删减什么模块都不要改main函数，关键就在于System_Config()函数的实现，下面就来分析下：&#x2F;** @ brief : Initialization of each module.* @ param : None.* @ return: None.* @ author: bagy* @ modify: None.*&#x2F;void System_Config(void)&#123;  volatile const init_func *index;  for(index &#x3D; &amp;_init_System_InitSectionStart_func; index &lt; &amp;_init_System_InitSectionEnd_func; index++)  &#123;    (*index)();  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怎么样，看到这个代码是不是人傻了，啥玩意这是？<br>假如我离职，交接给下一任工程师，我相信他也是崩溃的，马上提桶的心都有了，其实，对于懂的人来说并不难，所以为了你交接工作时看到这样的代码不慌，还要耐心看完这篇文章啊。<br>结合上面分析的代码思路可以更好的理解上面的代码，本质就是把段表里的函数全部遍历、运行。<br>再深入分析上述代码，看下init_func是怎么定义的。</p><pre class="line-numbers language-none"><code class="language-none">typedef  void (*init_func)(void);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就是定义了一个函数指针，这里要注意，模块的初始化代码要遵循这个函数指针的定义，这个因人而异，想怎么修改都是没问题的。</p><p>下面再看下怎么获取段表的起始和结束的地址的，这里定义两个函数，把这两个函数分别导出到段表的起始和结束地址，通过这两个函数就能获取起止地址了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** @ brief : Initialize the start function of the segment, used to mark the start address.* @ param : None.* @ return: None.* @ author: bagy* @ modify: None.*&#x2F;static void System_InitSectionStart(void)&#123;  return;&#125;INIT_EXPORT(System_InitSectionStart, &quot;0&quot;);&#x2F;** @ brief : Initialize the end function of the segment to mark the end address.* @ param : None.* @ return: None.* @ author: bagy* @ modify: None.*&#x2F;static void System_InitSectionEnd(void)&#123;  return;&#125;INIT_EXPORT(System_InitSectionEnd, &quot;z&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数很简单，但是INIT_EXPORT有是啥东西，里面的两个参数又是啥意思？</p><p>这里INIT_EXPORT只是一个宏定义，来看下这个宏的真面目吧</p><pre class="line-numbers language-none"><code class="language-none">#define  INIT_SECTION(x)      __attribute__((section(x))) #define  INIT_USED            __attribute__((used)) #define  INIT_EXPORT(fn, level)    INIT_USED init_func _init_##fn##_func INIT_SECTION(&quot;.init_fn.&quot;level) &#x3D; fn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>fn<br>  表示到导出的函数。</li><li>level<br>  表示等级，数值越小Keil就会把对应的函数放在段表的靠前的位置。因此上面获取起始段表的地址哪里后面的等级是0，也就是段表中的第一个函数。</li></ul></blockquote><p>思维发散一下，还可以通过这个level参数，控制函数先后调用的顺序。这点是很有必要的，在设计过程中可能会涉及模块的依赖问题，比如A模块的初始化成功要依赖于B模块，因此要先运行B模块的初始化函数，使用这个参数就能很好的解决这个问题了。</p><p>这样在每个模块中就只要用INIT_EXPORT这个宏导出即可，增加或删减一个模块的时候是不是初始化的代码都不用修改。这种体验就是：爽！</p><h2 id="map文件分析"><a href="#map文件分析" class="headerlink" title="map文件分析"></a>map文件分析</h2><p>接手了这样的代码后怎么更快的确认函数的调用关系呢？.map文件来帮忙。下面来查看下我的项目中的map文件。<br><img src="/images/learn/stm32/qVdRNPHRLzvJIFbC-PL0DQ-2.png"></p><p>这样函数的先后调用关系就非常清楚了。<br>到此优雅、简单的调用就实现了，目的就是增删模块尽可能的少修改代码，果然懒才是人类进步的阶梯啊！    </p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 奇淫巧技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32汇编指令笔记</title>
      <link href="/20230628/learn_asm/STM32%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0.html"/>
      <url>/20230628/learn_asm/STM32%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><h2 id="IT"><a href="#IT" class="headerlink" title="IT"></a>IT</h2><blockquote><p>条件执行体，指令包含有IT、ITT、 ITTT、 ITTTT、ITE、 ITEE、ITEEE, 该指令包括的意义为IF-THEN-ELSE<br>IT{x{y{z}}}&lt;q&gt; &lt;firstcond&gt;<br>   &lt;x&gt; Specifies the condition for the second instruction in the IT block.<br>   &lt;y&gt; Specifies the condition for the third instruction in the IT block.<br>   &lt;z&gt; Specifies the condition for the fourth instruction in the IT block.<br>   &lt;q&gt; See Standard assembler syntax fields on page A7-177.<br>   &lt;firstcond&gt; Specifies the condition for the first instruction in the IT block.<br>Each of &lt;x&gt;, &lt;y&gt;, and &lt;z&gt; can be either:<br>T Then. The condition attached to the instruction is &lt;firstcond&gt;.<br>E Else. The condition attached to the instruction is the inverse of &lt;firstcond&gt;. The condition code is the same as &lt;firstcond&gt;, except that the least significant bit is inverted. E must not be specified if &lt;firstcond&gt; is AL.<br>程序范例</p><pre class="line-numbers language-none"><code class="language-none">            PRESERVE8            THUMB;           &#x2F;* reset Vector Mapped to at Address 0 *&#x2F;            AREA    RESET, DATA, READONLY            DCD  0X20001000__Vectors   DCD  main            AREA    |.text|, CODE, READONLYmain            MOVS    R0, #0            MOVS    R5, #0X22            CMP     R1, #0            ITTT    EQ             MOVEQ   R1, #1             MOVEQ   R1, #0x41             CMPEQ   R1, #0x41             ITTTE   EQ             CMPEQ   R5, 0X22             MOVEQ   R2, R1             MOVEQ   R1, #0             MOVNE   R1, #1             B       .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果条件成立则执行，否则不执行。指令占用执行周期<br>IT块的长度与后面影响指令行等长<br>T标记表示条件成立执行，E标记表不条件不成立时将得到执行，E或T标记在有执行条件时影响标志位的而后续程序有根据标志位跳转的根据新条件执行</p></blockquote><h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><h2 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h2><blockquote><p>数据赋值<br>| MOV instruction           | Canonical form        |<br>| :—                      | :—                  |<br>| MOV{S} <Rd>,<Rm>,ASR #<n> | ASR{S} <Rd>,<Rm>,#<n> |<br>| MOV{S} <Rd>,<Rm>,LSL #<n> | LSL{S} <Rd>,<Rm>,#<n> |<br>| MOV{S} <Rd>,<Rm>,LSR #<n> | LSR{S} <Rd>,<Rm>,#<n> |<br>| MOV{S} <Rd>,<Rm>,ROR #<n> | ROR{S} <Rd>,<Rm>,#<n> |<br>| MOV{S} <Rd>,<Rm>,ASR <Rs> | ASR{S} <Rd>,<Rm>,<Rs> |<br>| MOV{S} <Rd>,<Rm>,LSL <Rs> | LSL{S} <Rd>,<Rm>,<Rs> |<br>| MOV{S} <Rd>,<Rm>,LSR <Rs> | LSR{S} <Rd>,<Rm>,<Rs> |<br>| MOV{S} <Rd>,<Rm>,ROR <Rs> | ROR{S} <Rd>,<Rm>,<Rs> |<br>| MOV{S} <Rd>,<Rm>,RRX      | RRX{S} <Rd>,<Rm>      | </p><p>{S}包含时，将影响Z标志位</p></blockquote><h1 id="N"><a href="#N" class="headerlink" title="N"></a>N</h1><h1 id="O"><a href="#O" class="headerlink" title="O"></a>O</h1><h1 id="P"><a href="#P" class="headerlink" title="P"></a>P</h1><h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1><h1 id="T"><a href="#T" class="headerlink" title="T"></a>T</h1><h2 id="TST"><a href="#TST" class="headerlink" title="TST"></a>TST</h2><blockquote><p>Test (register) performs a logical AND operation on a register value and an optionally-shifted register value. It updates the condition flags based on the result, and discards the result.<br><code>TST&lt;c&gt;&lt;q&gt; &lt;Rn&gt;, &lt;Rm&gt; &#123;,&lt;shift&gt;&#125;</code><br><code>&lt;c&gt;&lt;q&gt; See Standard assembler syntax fields on page A7-177.</code><br><code>&lt;Rn&gt; Specifies the register that contains the first operand.</code><br><code>&lt;Rm&gt; Specifies the register that is optionally shifted and used as the second operand.</code><br><code>&lt;shift&gt; Specifies the shift to apply to the value read from &lt;Rm&gt;. If &lt;shift&gt; is omitted, no shift is applied and both encodings are permitted. If &lt;shift&gt; is specified, only encoding T2 is permitted. The possible shifts and how they are encoded are described in Shifts applied to a register on page A7-182.</code></p><p>程序范例<br><code>if(0&amp;0xFE) goto loc_1FFFD18E</code> </p><pre class="line-numbers language-none"><code class="language-none">MOV     R0, #0MOVS    R2, #0x7F TST     R0, R2BNE     loc_1FFFD18E<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h1 id="U"><a href="#U" class="headerlink" title="U"></a>U</h1><h2 id="UXTH"><a href="#UXTH" class="headerlink" title="UXTH"></a>UXTH</h2><blockquote><p>将寄存器的16位数据扩展成32位的数据，高位补0<br><code>UXTH&lt;c&gt;&lt;q&gt; &lt;Rd&gt;, &lt;Rm&gt; &#123;, &lt;rotation&gt;&#125;</code><br><code>&lt;c&gt;&lt;q&gt;</code> See Standard assembler syntax fields on page A7-177.<br><code>&lt;Rd&gt;</code> Specifies the destination register.<br><code>&lt;Rm&gt;</code> Specifies the register that contains the second operand.<br><code>&lt;rotation&gt;</code> This can be any one of:</p><ul><li>ROR #8 Encoded as rotate = ’01’.</li><li>ROR #16 Encoded as rotate = ’10’.</li><li>ROR #24 Encoded as rotate = ’11’.</li><li>omitted Encoded as rotate = ’00’.</li></ul></blockquote><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><h1 id="W"><a href="#W" class="headerlink" title="W"></a>W</h1><h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><h1 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h1><h1 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h1>]]></content>
      
      
      <categories>
          
          <category> OTA原理及实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 原创 </tag>
            
            <tag> STM32 </tag>
            
            <tag> 杂谈闲语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32文件归档</title>
      <link href="/20230628/datus_base/STM32%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3.html"/>
      <url>/20230628/datus_base/STM32%E6%96%87%E4%BB%B6%E5%BD%92%E6%A1%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h1><table><thead><tr><th align="left">简写</th><th align="left">文件名称</th></tr></thead><tbody><tr><td align="left">RM</td><td align="left">Reference Manual</td></tr><tr><td align="left">PM</td><td align="left">Programming Manual</td></tr><tr><td align="left">AN</td><td align="left">Application Note</td></tr></tbody></table><hr><h1 id="ARM调试接口协议说明"><a href="#ARM调试接口协议说明" class="headerlink" title="ARM调试接口协议说明"></a>ARM调试接口协议说明</h1><blockquote><p>ARM Debug Interface Architecture Specification ADIv5.0 to ADIv5.2(ID080813)<br><a href="/downloads/datus/ID080813.pdf">ARM IHI 0031C 调试接口协议说明 &lt;点击下载 ID080813.pdf&gt;</a></p></blockquote><h2 id="About-this-book"><a href="#About-this-book" class="headerlink" title="About this book"></a>About this book</h2><blockquote><p>This is the Architecture Specification for the ARM Debug Interface v5, ADIv5.0 to ADIv5.2 (ADIv5). </p></blockquote><h2 id="Intended-audience"><a href="#Intended-audience" class="headerlink" title="Intended audience"></a>Intended audience</h2><blockquote><p>This specification is written for system designers and engineers who are specifying, designing or implementing a debug interface to the ADIv5 architecture specification. This includes system designers and engineers who are specifying, designing or implementing a System-on-Chip (SoC) that incorporates a debug interface that complies with the ADIv5 specification.<br>This specification is also intended for engineers who are working with a debug interface that conforms to the ADIv5 specification. This includes designers and engineers who are:</p><ul><li>Specifying, designing or implementing hardware debuggers.</li><li>Specifying, designing or writing debug software.</li></ul><p>These engineers have no control over the design decisions made in the ADIv5 interface implementation to which they are connecting, but must be able to identify the ADIv5 interface components present, and understand how they operate.<br>This specification provides an architectural description of an ADIv5 interface. It does not describe how to implement the interface.</p></blockquote><hr><h1 id="ARM指令手册"><a href="#ARM指令手册" class="headerlink" title="ARM指令手册"></a>ARM指令手册</h1><h2 id="Armv7-M-Architecture-Reference-Manual-DDI0403E"><a href="#Armv7-M-Architecture-Reference-Manual-DDI0403E" class="headerlink" title="Armv7-M Architecture Reference Manual(DDI0403E)"></a>Armv7-M Architecture Reference Manual(DDI0403E)</h2><blockquote><p><a href="/downloads/datus/DDI0403E_armv7m.pdf">ARM V7-M指令手册 &lt;点击下载 DDI0403E.pdf&gt;</a></p></blockquote><h2 id="About-this-manual"><a href="#About-this-manual" class="headerlink" title="About this manual"></a>About this manual</h2><blockquote><p>This manual documents the Microcontroller profile of version 7 of the Arm® Architecture, the Armv7-Marchitecture profile. For short definitions of all the Armv7 profiles see About the Armv7 architecture, andarchitecture profiles on page A1-20.<br>The manual has the following parts:</p><ul><li>Part A The application level programming model and memory model information along with theinstruction set as visible to the application programmer.<blockquote><p>This is the information required to program applications or to develop the toolchain components(compiler, linker, assembler and disassembler) excluding the debugger. For Armv7-M, this is almostentirely a subset of material common to the other two profiles. Instruction set details that differbetween profiles are clearly stated.</p></blockquote></li></ul></blockquote><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><blockquote><p>All Armv7 profiles support a common procedure calling standard, the Arm Architecture ProcedureCalling Standard (AAPCS).</p><ul><li><p>Part B The system level programming model and system level support instructions required for systemcorrectness. The system level supports the Armv7-M exception model. It also provides features forconfiguration and control of processor resources and management of memory access rights.</p><blockquote><p>This is the information in addition to Part A required for an operating system (OS) and/or systemsupport software. It includes details of register banking, the exception model, memory protection(management of access rights) and cache support.<br>Part B is profile specific. Armv7-M introduces a new programmers’ model and as such has somefundamental differences at the system level from the other profiles. As Armv7-M is amemory-mapped architecture, the system memory map is documented here.</p></blockquote></li><li><p>Part C The debug features to support the Armv7-M debug architecture and the programming interface tothe debug environment.</p><blockquote><p>This is the information required in addition to Parts A and B to write a debugger. Part C coversdetails of the different types of debug:</p><ul><li>Halting debug and the related Debug state.</li><li>Exception-based monitor debug.</li><li>Non-invasive support for event generation and signalling of the events to an external agent.</li></ul><p>This part is profile specific and includes several debug features that are supported only in theArmv7-M architecture profile.</p></blockquote></li></ul><p>Appendices The appendices give information that relates to, but is not part of, the Armv7-M architecture profilespecification.</p></blockquote><h2 id="ARMv7-A-and-ARMv7-R-Architecture-Reference-Manual-DDI0406C"><a href="#ARMv7-A-and-ARMv7-R-Architecture-Reference-Manual-DDI0406C" class="headerlink" title="ARMv7-A and ARMv7-R Architecture Reference Manual(DDI0406C)"></a>ARMv7-A and ARMv7-R Architecture Reference Manual(DDI0406C)</h2><blockquote><p><a href="/downloads/datus/DDI0406C_armv7a_armv7r.pdf">ARM V7-A/R指令手册 &lt;点击下载 DDI0406C.pdf&gt;</a></p></blockquote><h2 id="About-this-manual-1"><a href="#About-this-manual-1" class="headerlink" title="About this manual"></a>About this manual</h2><blockquote><p>This manual describes the A and R profiles of the ARM® architecture v7, ARMv7. It includes descriptions of:</p><ul><li><p>The processor instruction sets:</p><ul><li>the original ARM instruction set</li><li>the high code density Thumb® instruction set</li><li>the ThumbEE instruction set, that includes specific support for Just-In-Time (JIT) or Ahead-Of-Time(AOT) compilation.</li></ul></li><li><p>The modes and states that determine how a processor operates, including the current execution privilege and security.</p></li><li><p>The exception model.</p></li><li><p>The memory model, that defines memory ordering and memory management:</p><ul><li>the ARMv7-A architecture profile defines a Virtual Memory System Architecture (VMSA)</li><li>the ARMv7-R architecture profile defines a Protected Memory System Architecture (PMSA).</li></ul></li><li><p>The programmers’ model, and its use of a coprocessor interface to access system control registers that control most processor and memory system features.</p></li><li><p>The optional Floating-point (VFP) Extension, that provides high-performance floating-point instructions that support:</p><ul><li>single-precision and double-precision operations</li><li>conversions between double-precision, single-precision, and half-precision floating-point values.</li></ul></li><li><p>The optional Advanced SIMD Extension, that provides high-performance integer and single-precision floating-point vector operations.</p></li><li><p>The optional Security Extensions, that facilitate the development of secure applications.</p></li><li><p>The optional Virtualization Extensions, that support the virtualization of Non-secure operation.</p></li><li><p>The Debug architecture, that provides software access to debug features in the processor</p></li></ul></blockquote><hr><h1 id="STM32F10xxx参考手册"><a href="#STM32F10xxx参考手册" class="headerlink" title="STM32F10xxx参考手册"></a>STM32F10xxx参考手册</h1><blockquote><p>STM32 Reference Manual (RM0008)<br><a href="/downloads/datus/RM0008.pdf">STM32F10xxx中文参考手册 &lt;点击下载 RM0008.pdf&gt;</a></p><blockquote><p>本参考手册针对应用开发，提供关于如何使用STM32F101xx、STM32F102xx、STM32F103和STM32F105xx/STM32F107xx 微控制器的存储器和外设的详细信息。在本参考手册中STM32F101xx 、 STM32F102xx 、 STM32F103 和 STM32F105xx/STM32F107xx 被统称为STM32F10xxx。<br>STM32F10xxx系列拥有不同的存储器容量、封装和外设配置。<br>关于订货编号、电气和物理性能参数，请参考小容量、中容量和大容量的STM32F101xx和STM32F103xx的数据手册，小容量和中容量的STM32F102xx数据手册和STM32F105xx/STM32F107xx互联型产品的数据手册。<br>STM32F10xxx闪存编程手册参照2009年12月 RM0008 Reference Manual 英文第10版关于芯片内部闪存的编程，擦除和保护操作，请参考 。<br>关于ARM Cortex™-M3内核的具体信息，请参考Cortex™-M3技术参考手册。</p></blockquote></blockquote><hr><h1 id="STM32F10xxx闪存编程手册"><a href="#STM32F10xxx闪存编程手册" class="headerlink" title="STM32F10xxx闪存编程手册"></a>STM32F10xxx闪存编程手册</h1><h2 id="STM32F10xxx-Flash-memory-microcontrollers-PM0075"><a href="#STM32F10xxx-Flash-memory-microcontrollers-PM0075" class="headerlink" title="STM32F10xxx Flash memory microcontrollers(PM0075)"></a>STM32F10xxx Flash memory microcontrollers(PM0075)</h2><blockquote><p>  <a href="/downloads/datus/PM0075.pdf">STM32F10xxx闪存编程手册 &lt;点击下载 PM0075.pdf&gt;</a></p></blockquote><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><blockquote><p>This programming manual describes how to program the Flash memory of STM32F101xx, STM32F102xx, STM32F103xx, STM32F105xx and STM32F107xx microcontrollers. For convenience, these will be referred to as STM32F10xxx in the rest of this document unless otherwise specified.<br>The STM32F10xxx embedded Flash memory can be programmed using in-circuit programming or in-application programming.<br>The in-circuit programming (ICP) method is used to update the entire contents of the Flash memory, using the JTAG, SWD protocol or the boot loader to load the user application into the microcontroller. ICP offers quick and efficient design iterations and eliminates unnecessary package handling or socketing of devices.<br>In contrast to the ICP method, in-application programming (IAP) can use any communication interface supported by the microcontroller (I/Os, USB, CAN, UART, I2C, SPI, etc.) to download programming data into memory. IAP allows the user to re-program the Flash memory while the application is running. Nevertheless, part of the application has to have been previously programmed in the Flash memory using ICP.<br>The Flash interface implements instruction access and data access based on the AHB protocol. It implements a prefetch buffer that speeds up CPU code execution. It also implements the logic necessary to carry out Flash memory operations (Program/Erase).<br>Program/Erase operations can be performed over the whole product voltage range.<br>Read/Write protections and option bytes are also implemented.<br>Table 1 lists the microcontrollers and evaluation tool concerned by this programming manual.</p></blockquote><h3 id="Table-1-Applicable-products"><a href="#Table-1-Applicable-products" class="headerlink" title="Table 1. Applicable products"></a>Table 1. Applicable products</h3><table><thead><tr><th align="left">Type</th><th align="left">Applicable products</th></tr></thead><tbody><tr><td align="left">Microcontrollers</td><td align="left">STM32F101xx, STM32F102xx, STM32F103xx, STM32F105xx and STM32F107xx microcontrollers</td></tr><tr><td align="left">Evaluation tool</td><td align="left">STM3210C-EVAL evaluation board</td></tr></tbody></table><h2 id="STM32F10xxx-XL-density-Flash-programming-PM0068"><a href="#STM32F10xxx-XL-density-Flash-programming-PM0068" class="headerlink" title="STM32F10xxx XL-density Flash programming(PM0068)"></a>STM32F10xxx XL-density Flash programming(PM0068)</h2><blockquote><p>  <a href="/downloads/datus/PM0068.pdf">STM32F10xxx XL-density闪存编程手册 &lt;点击下载 PM0068.pdf&gt;</a></p></blockquote><hr><h1 id="STM32单片机系统内存启动方式"><a href="#STM32单片机系统内存启动方式" class="headerlink" title="STM32单片机系统内存启动方式"></a>STM32单片机系统内存启动方式</h1><blockquote><p>STM32F10xxx 自举程序应用笔记<br><a href="/downloads/datus/AN2606.pdf">STM32单片机系统内存启动方式 &lt;点击下载 AN2606.pdf&gt;</a></p><blockquote><p>自举程序存储在STM32器件的内部自举ROM（系统存储器）中，由ST在生产期间进行编程。其主要任务是通过一种可用的串行外设（如USART、CAN、USB、I2C）将应用程序下载到内部Flash中。每种串行接口都定义了相应的通信协议，其中包含兼容的命令集和序列。本文档适用于表 1中列出的产品，这些产品在文档中统称为STM32。该文档描述了使用STM32器件的自举程序时支持的外设以及需要考虑的硬件要求</p></blockquote><p><a href="/downloads/datus/AN3155.pdf">STM32单片机自举程序中使用的 USART 协议 &lt;点击下载 AN3155.pdf&gt;</a></p><blockquote><p>本应用笔记将介绍 USART 协议在 STM32 微控制器自举程序中的应用，还将详细介绍支持的每个命令。要详细了解器件自举程序的 USART 硬件资源和要求，请参见“STM32 系统存储器自举模式”（应用笔记 AN2606）。</p></blockquote></blockquote><hr><h1 id="STM32单片机软件开发说明"><a href="#STM32单片机软件开发说明" class="headerlink" title="STM32单片机软件开发说明"></a>STM32单片机软件开发说明</h1><blockquote><p>STM32F10xxx/20xxx/21xxx/L1xxxx Cortex®-M3 programming manual<br><a href="/downloads/datus/PM0056.pdf">STM32单片机软件开发说明 &lt;PM0056.pdf&gt;</a></p></blockquote><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>This programming manual provides information for application and system-level software developers. It gives a full description of the STM32F10xxx/20xxx/21xxx/L1xxxx Cortex®-M3 processor programming model, instruction set and core peripherals.<br>The STM32F10xxx/20xxx/21xxx/L1xxxx Cortex®-M3 processor is a high performance 32-bit processor designed for the microcontroller market. It offers significant benefits to developers, including:</p><ul><li>Outstanding processing performance combined with a fast interrupt handling</li><li>Enhanced system debug with extensive breakpoint and trace capabilities</li><li>Efficient processor core, system and memories</li><li>Ultra-low-power consumption with integrated sleep modes</li><li>Platform security</li></ul></blockquote><hr><h1 id="STM32F10x-使用FLASH模拟EEPROM"><a href="#STM32F10x-使用FLASH模拟EEPROM" class="headerlink" title="STM32F10x 使用FLASH模拟EEPROM"></a>STM32F10x 使用FLASH模拟EEPROM</h1><blockquote><p>EEPROM emulation in STM32F10x microcontrollers<br><a href="/downloads/datus/AN2594.pdf">STM32F10x 使用FLASH模拟EEPROM &lt;点击下载 AN2594.pdf&gt;</a></p></blockquote><h2 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>Many applications require EEPROM (electrically erasable programmable read-only memory) for non-volatile data storage. For low-cost purposes, the STM32F10x devices do not use EEPROM. Instead, they implement EEPROM emulation using the embedded Flash memory.<br>This application note explains the differences between external EEPROM and embedded Flash memory, and it describes a software method for emulating EEPROM using the on-chip Flash memory of the STM32F10x devices.<br>This document also focuses on some embedded aspects in emulated EEPROM data storage, that the reader is assumed to know.</p></blockquote><h2 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h2><blockquote><p>Low-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers where the Flash memory density ranges between 16 and 32 Kbytes.<br>Medium-density devices are STM32F10x and STM32F103xx microcontrollers where the Flash memory density ranges between 32 and 128 Kbytes.<br>High-density devices are STM32F10x and STM32F103xx microcontrollers where the Flash memory density ranges between 256 and 512 Kbytes.<br>Connectivity line devices are STM32F105xx and STM32F107xx microcontrollers.</p></blockquote><hr><p>超级链接<br><a href="https://developer.arm.com/search#q=RM0008">ARM开发者中心</a></p>]]></content>
      
      
      <categories>
          
          <category> 文件归档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> STM32 </tag>
            
            <tag> 杂谈闲语 </tag>
            
            <tag> 文件归档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32的内部FLASH是如何划分的</title>
      <link href="/20230627/flm_cmsis/STM32%E7%9A%84%E5%86%85%E9%83%A8FLASH%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84.html"/>
      <url>/20230627/flm_cmsis/STM32%E7%9A%84%E5%86%85%E9%83%A8FLASH%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84.html</url>
      
        <content type="html"><![CDATA[<p>因为STM32的内部FLASH大小不一，不同的大小划分是不一样的，但是大同小异这里是以STM32F103C8T6为例进行说明。</p><h1 id="基础知识补充"><a href="#基础知识补充" class="headerlink" title="基础知识补充"></a>基础知识补充</h1><blockquote><p>1 字节       = 8 位（bit）<br>1 千字节（KB）= 1024 字节<br>1 兆字节（MB）= 1024 千字节（KB）<br>1 吉字节（GB）= 1024 兆字节（MB）<br>1 太字节（TB）= 1024 吉字节（GB）</p></blockquote><p>下面是关于STM32F103C8T6内部Flash划分的详细说明</p><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>STM32F103C8T6的内部Flash容量为64KB，即64*1024字节,属于小容量产品。<br>以下是针对STM32F1系列芯片的常见型号，按照容量范围划分的示例：</p><table><thead><tr><th align="left">容量范围</th><th align="left">芯片型号</th><th align="left">Flash大小</th><th align="left">容量大小</th></tr></thead><tbody><tr><td align="left">小容量</td><td align="left">STM32F103C8T6</td><td align="left">64 KB</td><td align="left">64 * 1024 字节</td></tr><tr><td align="left"></td><td align="left">STM32F103RCT6</td><td align="left">256 KB</td><td align="left">256 * 1024 字节</td></tr><tr><td align="left">中容量</td><td align="left">STM32F103RBT6</td><td align="left">128 KB</td><td align="left">128 * 1024 字节</td></tr><tr><td align="left"></td><td align="left">STM32F103RET6</td><td align="left">512 KB</td><td align="left">512 * 1024 字节</td></tr><tr><td align="left">大容量</td><td align="left">STM32F103VET6</td><td align="left">512 KB</td><td align="left">512 * 1024 字节</td></tr><tr><td align="left"></td><td align="left">STM32F103ZET6</td><td align="left">1024 KB</td><td align="left">1024 * 1024 字节</td></tr></tbody></table><h2 id="扇区划分"><a href="#扇区划分" class="headerlink" title="扇区划分"></a>扇区划分</h2><p>内部Flash存储器被划分为多个扇区，每个扇区的大小为2KB或4KB，具体划分取决于具体的芯片型号。</p><table><thead><tr><th align="left">Flash大小</th><th align="left">地址范围</th><th align="left">扇区大小</th><th align="left">最后扇区地址</th></tr></thead><tbody><tr><td align="left">64KB</td><td align="left">0x08000000~0x08010000-1</td><td align="left">1KB=0x400</td><td align="left">0x0800FC00</td></tr><tr><td align="left">128K</td><td align="left">0x08000000~0x08020000-1</td><td align="left">1KB=0x400</td><td align="left">0x0801FC00</td></tr><tr><td align="left">256K</td><td align="left">0x08000000~0x08040000-1</td><td align="left">2KB=0x800</td><td align="left">0x0803F800</td></tr><tr><td align="left">512K</td><td align="left">0x08000000~0x08080000-1</td><td align="left">2KB=0x800</td><td align="left">0x0807F800</td></tr></tbody></table><h2 id="STM32F103C8T6-64KB的扇区划分"><a href="#STM32F103C8T6-64KB的扇区划分" class="headerlink" title="STM32F103C8T6(64KB的扇区划分)"></a>STM32F103C8T6(64KB的扇区划分)</h2><table><thead><tr><th align="left">扇区编号</th><th align="left">起始地址</th><th align="left">结束地址</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">扇区0</td><td align="left">0x08000000</td><td align="left">0x080003FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区1</td><td align="left">0x08000400</td><td align="left">0x080007FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区2</td><td align="left">0x08000800</td><td align="left">0x08000BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区3</td><td align="left">0x08000C00</td><td align="left">0x08000FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区4</td><td align="left">0x08001000</td><td align="left">0x080013FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区5</td><td align="left">0x08001400</td><td align="left">0x080017FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区6</td><td align="left">0x08001800</td><td align="left">0x08001BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区7</td><td align="left">0x08001C00</td><td align="left">0x08001FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区8</td><td align="left">0x08002000</td><td align="left">0x080023FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区9</td><td align="left">0x08002400</td><td align="left">0x080027FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区10</td><td align="left">0x08002800</td><td align="left">0x08002BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区11</td><td align="left">0x08002C00</td><td align="left">0x08002FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区12</td><td align="left">0x08003000</td><td align="left">0x080033FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区13</td><td align="left">0x08003400</td><td align="left">0x080037FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区14</td><td align="left">0x08003800</td><td align="left">0x08003BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区15</td><td align="left">0x08003C00</td><td align="left">0x08003FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区16</td><td align="left">0x08004000</td><td align="left">0x080043FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区17</td><td align="left">0x08004400</td><td align="left">0x080047FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区18</td><td align="left">0x08004800</td><td align="left">0x08004BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区19</td><td align="left">0x08004C00</td><td align="left">0x08004FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区20</td><td align="left">0x08005000</td><td align="left">0x080053FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区21</td><td align="left">0x08005400</td><td align="left">0x080057FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区22</td><td align="left">0x08005800</td><td align="left">0x08005BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区23</td><td align="left">0x08005C00</td><td align="left">0x08005FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区24</td><td align="left">0x08006000</td><td align="left">0x080063FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区25</td><td align="left">0x08006400</td><td align="left">0x080067FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区26</td><td align="left">0x08006800</td><td align="left">0x08006BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区27</td><td align="left">0x08006C00</td><td align="left">0x08006FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区28</td><td align="left">0x08007000</td><td align="left">0x080073FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区29</td><td align="left">0x08007400</td><td align="left">0x080077FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区30</td><td align="left">0x08007800</td><td align="left">0x08007BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区31</td><td align="left">0x08007C00</td><td align="left">0x08007FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区32</td><td align="left">0x08008000</td><td align="left">0x080083FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区33</td><td align="left">0x08008400</td><td align="left">0x080087FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区34</td><td align="left">0x08008800</td><td align="left">0x08008BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区35</td><td align="left">0x08008C00</td><td align="left">0x08008FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区36</td><td align="left">0x08009000</td><td align="left">0x080093FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区37</td><td align="left">0x08009400</td><td align="left">0x080097FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区38</td><td align="left">0x08009800</td><td align="left">0x08009BFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区39</td><td align="left">0x08009C00</td><td align="left">0x08009FFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区40</td><td align="left">0x0800A000</td><td align="left">0x0800A3FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区41</td><td align="left">0x0800A400</td><td align="left">0x0800A7FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区42</td><td align="left">0x0800A800</td><td align="left">0x0800ABFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区43</td><td align="left">0x0800AC00</td><td align="left">0x0800AFFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区44</td><td align="left">0x0800B000</td><td align="left">0x0800B3FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区45</td><td align="left">0x0800B400</td><td align="left">0x0800B7FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区46</td><td align="left">0x0800B800</td><td align="left">0x0800BBFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区47</td><td align="left">0x0800BC00</td><td align="left">0x0800BFFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区48</td><td align="left">0x0800C000</td><td align="left">0x0800C3FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区49</td><td align="left">0x0800C400</td><td align="left">0x0800C7FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区50</td><td align="left">0x0800C800</td><td align="left">0x0800CBFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区51</td><td align="left">0x0800CC00</td><td align="left">0x0800CFFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区52</td><td align="left">0x0800D000</td><td align="left">0x0800D3FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区53</td><td align="left">0x0800D400</td><td align="left">0x0800D7FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区54</td><td align="left">0x0800D800</td><td align="left">0x0800DBFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区55</td><td align="left">0x0800DC00</td><td align="left">0x0800DFFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区56</td><td align="left">0x0800E000</td><td align="left">0x0800E3FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区57</td><td align="left">0x0800E400</td><td align="left">0x0800E7FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区58</td><td align="left">0x0800E800</td><td align="left">0x0800EBFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区59</td><td align="left">0x0800EC00</td><td align="left">0x0800EFFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区60</td><td align="left">0x0800F000</td><td align="left">0x0800F3FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区61</td><td align="left">0x0800F400</td><td align="left">0x0800F7FF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区62</td><td align="left">0x0800F800</td><td align="left">0x0800FBFF</td><td align="left">1 KB</td></tr><tr><td align="left">扇区63</td><td align="left">0x0800FC00</td><td align="left">0x0800FFFF</td><td align="left">1 KB</td></tr></tbody></table><p>请注意，以上表格中的地址是以十六进制表示。每个扇区的大小为1KB（0x400字节）。最后一个扇区地址为0x0800FC00，范围为0x0800FC00-0x0800FFFF，大小为1KB。</p><h1 id="STM32的内部FLASH是干什么用的？"><a href="#STM32的内部FLASH是干什么用的？" class="headerlink" title="STM32的内部FLASH是干什么用的？"></a>STM32的内部FLASH是干什么用的？</h1><p>STM32的内部Flash主要用于存储程序代码（固件）和只读数据。</p><ul><li>程序代码（固件）：内部Flash是存储微控制器的程序代码的主要地方。它包含了应用程序的指令集，包括启动代码、中断处理程序、函数和其他执行代码。这些代码定义了系统的功能和行为。通常是编译生成的HEX文件或者BIN文件。</li><li>只读数据：内部Flash还可以用于存储只读数据，如常量、配置信息和校准数据等。这些数据在程序执行期间是只读的，不会被修改。</li><li>Bootloader：一些STM32芯片内置了Bootloader，它是一个特殊的程序，用于在启动时加载和更新应用程序的固件。Bootloader通常存储在内部Flash的特定区域，并负责固件的升级和管理。</li></ul><h1 id="STM32的内部FLASH该如何读写数据呢？"><a href="#STM32的内部FLASH该如何读写数据呢？" class="headerlink" title="STM32的内部FLASH该如何读写数据呢？"></a>STM32的内部FLASH该如何读写数据呢？</h1><h2 id="读写内部FLASH的一般步骤"><a href="#读写内部FLASH的一般步骤" class="headerlink" title="读写内部FLASH的一般步骤"></a>读写内部FLASH的一般步骤</h2><p>在STM32微控制器中，内部Flash的读写操作通常通过以下步骤进行：</p><ol><li>启用Flash访问：在进行Flash读写之前，需要先启用对Flash的访问权限。这可以通过设置Flash控制寄存器（FLASH_CR）中的特定位来实现。例如，将FLASH_CR的PG位设置为1，表示启用对Flash的编程访问。</li><li>解锁Flash：在进行Flash编程之前，需要解锁Flash以允许对其进行写操作。通过向FLASH_KEYR寄存器写入特定值来解锁Flash。要解锁Flash，首先写入0x45670123，然后立即写入0xCDEF89AB到FLASH_KEYR寄存器。</li><li>检查Flash状态：在进行Flash编程之前，需要检查Flash是否处于忙碌状态。可以通过读取FLASH_SR寄存器中的BSY位来判断Flash是否处于忙碌状态。如果BSY位为1，表示Flash正在执行操作，需要等待。</li><li>执行Flash编程：Flash编程可以通过直接写入特定地址处的数据来实现。要编程Flash，将要写入的数据写入Flash目标地址。请注意，写入操作是按字进行的，即每次写入4个字节。可以使用特定的函数或指针访问要编程的Flash地址。</li><li>等待Flash操作完成：在执行Flash编程后，需要等待编程操作完成。可以通过轮询FLASH_SR寄存器中的BSY位来检查Flash是否仍处于忙碌状态。当BSY位为0时，表示Flash操作已完成。</li><li>锁定Flash：完成Flash编程后，应该锁定Flash以防止意外修改。通过将FLASH_CR寄存器中的LOCK位设置为1，可以锁定Flash。<br>请注意，进行Flash编程时需要小心，因为不正确的操作可能会导致Flash数据的损坏。建议在编程Flash之前仔细阅读相关的芯片参考手册，并按照手册中提供的准确步骤和注意事项进行操作。需要注意的是可以使用官方提供的库和API函数来简化Flash读写的操作。</li></ol><h1 id="库函数接口操作内部FLASH接口解析"><a href="#库函数接口操作内部FLASH接口解析" class="headerlink" title="库函数接口操作内部FLASH接口解析"></a>库函数接口操作内部FLASH接口解析</h1><h2 id="解锁Flash代码解析"><a href="#解锁Flash代码解析" class="headerlink" title="解锁Flash代码解析"></a>解锁Flash代码解析</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  * @brief  Unlocks the FLASH Bank1 Program Erase Controller.  * @note   This function can be used for all STM32F10x devices.  *         - For STM32F10X_XL devices this function unlocks Bank1.  *         - For all other devices it unlocks Bank1 and it is   *           equivalent to FLASH_Unlock function.  * @param  None  * @retval None  *&#x2F;void FLASH_UnlockBank1(void)&#123;  &#x2F;* Authorize the FPEC of Bank1 Access *&#x2F;  FLASH-&gt;KEYR &#x3D; FLASH_KEY1;  FLASH-&gt;KEYR &#x3D; FLASH_KEY2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这段代码是用于解锁STM32的Bank1程序擦除控制器（Program Erase Controller）。以下是该代码的解释：<br>该函数用于解锁STM32的Bank1程序擦除控制器，适用于所有STM32F10x系列的设备。对于STM32F10X_XL系列的设备，该函数解锁Bank1。对于其他设备，它解锁Bank1并等效于FLASH_Unlock函数。<br>该函数没有参数。<br>函数的返回值为None。<br>函数内部的操作是通过向FLASH-&gt;KEYR寄存器写入特定值来实现解锁。具体来说，两次写入FLASH_KEY1（宏定义的值）到FLASH-&gt;KEYR寄存器，以解锁Bank1的访问权限。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  * @brief  Unlocks the FLASH Bank2 Program Erase Controller.  * @note   This function can be used only for STM32F10X_XL density devices.  * @param  None  * @retval None  *&#x2F;void FLASH_UnlockBank2(void)&#123;  &#x2F;* Authorize the FPEC of Bank2 Access *&#x2F;  FLASH-&gt;KEYR2 &#x3D; FLASH_KEY1;  FLASH-&gt;KEYR2 &#x3D; FLASH_KEY2;&#125;&#x2F;**  * @brief  Unlocks the FLASH Program Erase Controller.  * @note   This function can be used for all STM32F10x devices.  *         - For STM32F10X_XL devices this function unlocks Bank1 and Bank2.  *         - For all other devices it unlocks Bank1 and it is equivalent   *           to FLASH_UnlockBank1 function..   * @param  None  * @retval None  *&#x2F;void FLASH_Unlock(void)&#123;  &#x2F;* Authorize the FPEC of Bank1 Access *&#x2F;  FLASH-&gt;KEYR &#x3D; FLASH_KEY1;  FLASH-&gt;KEYR &#x3D; FLASH_KEY2;#ifdef STM32F10X_XL  &#x2F;* Authorize the FPEC of Bank2 Access *&#x2F;  FLASH-&gt;KEYR2 &#x3D; FLASH_KEY1;  FLASH-&gt;KEYR2 &#x3D; FLASH_KEY2;#endif &#x2F;* STM32F10X_XL *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：FLASH_Unlock包括 FLASH_UnlockBank1和 FLASH_UnlockBank2取决于芯片类型</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* FLASH Keys *&#x2F;#define RDP_Key                  ((uint16_t)0x00A5)#define FLASH_KEY1               ((uint32_t)0x45670123)#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>RDP_Key：<br>这是用于设置读保护(RDP)级别的密钥。读保护是一种保护机制，用于防止未授权的读取对Flash的访问。通过将RDP_Key写入特定的Flash寄存器，可以设置读保护级别。0x00A5是预定义的RDP_Key值。</li><li>FLASH_KEY1和FLASH_KEY2：<br>这两个密钥是用于解锁Flash的访问权限的。当需要对Flash进行编程、擦除等操作时，需要先解锁Flash。FLASH_KEY1和FLASH_KEY2是两个32位的特定值，通过连续写入这两个值到FLASH-&gt;KEYR寄存器，可以解锁Flash的访问权限。FLASH_KEY1的值为0x45670123，FLASH_KEY2的值为0xCDEF89AB。</li></ul></blockquote><h2 id="上锁Flash代码解析"><a href="#上锁Flash代码解析" class="headerlink" title="上锁Flash代码解析"></a>上锁Flash代码解析</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  * @brief  Locks the FLASH Bank1 Program Erase Controller.  * @note   this function can be used for all STM32F10x devices.  *         - For STM32F10X_XL devices this function Locks Bank1.  *         - For all other devices it Locks Bank1 and it is equivalent   *           to FLASH_Lock function.  * @param  None  * @retval None  *&#x2F;void FLASH_LockBank1(void)&#123;  &#x2F;* Set the Lock Bit to lock the FPEC and the CR of  Bank1 *&#x2F;  FLASH-&gt;CR |&#x3D; CR_LOCK_Set;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这段代码是用于锁定STM32的Bank1程序擦除控制器（Program Erase Controller）。以下是该代码的解释：<br>该函数用于锁定STM32的Bank1程序擦除控制器，适用于所有STM32F10x系列的设备。对于STM32F10X_XL系列的设备，该函数锁定Bank1。对于其他设备，它锁定Bank1并等效于FLASH_Lock函数。<br>该函数没有参数。<br>函数的返回值为None。<br>函数内部的操作是通过将CR_LOCK_Set（宏定义的值）设置到FLASH-&gt;CR寄存器的LOCK位，从而锁定Bank1的访问权限。具体来说，使用按位或操作符将CR_LOCK_Set设置到FLASH-&gt;CR寄存器的LOCK位，以锁定Flash的访问权限。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  * @brief  Locks the FLASH Bank2 Program Erase Controller.  * @note   This function can be used only for STM32F10X_XL density devices.  * @param  None  * @retval None  *&#x2F;void FLASH_LockBank2(void)&#123;  &#x2F;* Set the Lock Bit to lock the FPEC and the CR of  Bank2 *&#x2F;  FLASH-&gt;CR2 |&#x3D; CR_LOCK_Set;&#125;&#x2F;**  * @brief  Locks the FLASH Program Erase Controller.  * @note   This function can be used for all STM32F10x devices.  *         - For STM32F10X_XL devices this function Locks Bank1 and Bank2.  *         - For all other devices it Locks Bank1 and it is equivalent   *           to FLASH_LockBank1 function.  * @param  None  * @retval None  *&#x2F;void FLASH_Lock(void)&#123;  &#x2F;* Set the Lock Bit to lock the FPEC and the CR of  Bank1 *&#x2F;  FLASH-&gt;CR |&#x3D; CR_LOCK_Set;#ifdef STM32F10X_XL  &#x2F;* Set the Lock Bit to lock the FPEC and the CR of  Bank2 *&#x2F;  FLASH-&gt;CR2 |&#x3D; CR_LOCK_Set;#endif &#x2F;* STM32F10X_XL *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：FLASH_Lock包括 FLASH_LockBank1和 FLASH_LockBank2取决于芯片类型</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* Flash Control Register bits *&#x2F;#define CR_PG_Set                ((uint32_t)0x00000001)#define CR_PG_Reset              ((uint32_t)0x00001FFE) #define CR_PER_Set               ((uint32_t)0x00000002)#define CR_PER_Reset             ((uint32_t)0x00001FFD)#define CR_MER_Set               ((uint32_t)0x00000004)#define CR_MER_Reset             ((uint32_t)0x00001FFB)#define CR_OPTPG_Set             ((uint32_t)0x00000010)#define CR_OPTPG_Reset           ((uint32_t)0x00001FEF)#define CR_OPTER_Set             ((uint32_t)0x00000020)#define CR_OPTER_Reset           ((uint32_t)0x00001FDF)#define CR_STRT_Set              ((uint32_t)0x00000040)#define CR_LOCK_Set              ((uint32_t)0x00000080)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码定义了一些与Flash控制寄存器（Control Register）相关的位掩码（bits）。以下是这些位掩码的解释：</p><blockquote><ul><li>CR_PG_Set和CR_PG_Reset：<br>用于编程Flash的位掩码。CR_PG_Set将FLASH-&gt;CR寄存器的PG位设置为1，表示启用Flash编程访问。CR_PG_Reset将FLASH-&gt;CR寄存器的PG位复位为0，表示禁用Flash编程访问。</li><li>CR_PER_Set和CR_PER_Reset：<br>用于擦除Flash扇区的位掩码。CR_PER_Set将FLASH-&gt;CR寄存器的PER位设置为1，表示启用Flash扇区擦除。CR_PER_Reset将FLASH-&gt;CR寄存器的PER位复位为0，表示禁用Flash扇区擦除。</li><li>CR_MER_Set和CR_MER_Reset：<br>用于擦除整个Flash存储器的位掩码。CR_MER_Set将FLASH-&gt;CR寄存器的MER位设置为1，表示启用Flash全片擦除。CR_MER_Reset将FLASH-&gt;CR寄存器的MER位复位为0，表示禁用Flash全片擦除。</li><li>CR_OPTPG_Set和CR_OPTPG_Reset：<br>用于编程Flash选项字节的位掩码。CR_OPTPG_Set将FLASH-&gt;CR寄存器的OPTPG位设置为1，表示启用Flash选项字节编程。CR_OPTPG_Reset将FLASH-&gt;CR寄存器的OPTPG位复位为0，表示禁用Flash选项字节编程。</li><li>CR_OPTER_Set和CR_OPTER_Reset：<br>用于擦除Flash选项字节的位掩码。CR_OPTER_Set将FLASH-&gt;CR寄存器的OPTER位设置为1，表示启用Flash选项字节擦除。CR_OPTER_Reset将FLASH-&gt;CR寄存器的OPTER位复位为0，表示禁用Flash选项字节擦除。</li><li>CR_STRT_Set：<br>用于启动Flash操作的位掩码。CR_STRT_Set将FLASH-&gt;CR寄存器的STRT位设置为1，表示启动Flash编程或擦除操作。</li><li>CR_LOCK_Set：<br>用于锁定Flash的位掩码。CR_LOCK_Set将FLASH-&gt;CR寄存器的LOCK位设置为1，表示锁定Flash的访问权限。</li></ul></blockquote><p>这些位掩码用于在进行Flash编程、擦除和操作期间设置或复位Flash控制寄存器中的特定位。在实际应用中，可以根据需要使用这些位掩码来配置和控制Flash的操作。</p><h1 id="STM32库函数中FLASH擦除操作相关函数解析"><a href="#STM32库函数中FLASH擦除操作相关函数解析" class="headerlink" title="STM32库函数中FLASH擦除操作相关函数解析"></a>STM32库函数中FLASH擦除操作相关函数解析</h1><pre class="line-numbers language-none"><code class="language-none">FLASH_Status FLASH_ErasePage(uint32_t Page_Address);FLASH_Status FLASH_EraseAllPages(void);FLASH_Status FLASH_EraseOptionBytes(void);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是三个函数用于擦除STM32的Flash存储器中的页面和选项字节。以下是这些函数的解释：</p><blockquote><ol><li>FLASH_Status FLASH_ErasePage(uint32_t Page_Address)：<br>该函数用于擦除指定地址的Flash存储器页面。Page_Address参数表示要擦除的页面的起始地址。函数返回一个FLASH_Status类型的值，表示擦除操作的状态。可能的返回值包括：<ul><li>FLASH_COMPLETE：擦除操作成功完成。</li><li>FLASH_BUSY：擦除操作正在进行中。</li><li>FLASH_ERROR_WRP：擦除操作失败，由于写保护设置导致的错误。</li><li>FLASH_ERROR_PG：擦除操作失败，由于编程错误导致的错误。</li></ul></li><li>FLASH_Status FLASH_EraseAllPages(void)：<br>该函数用于擦除Flash存储器中的所有页面。函数返回一个FLASH_Status类型的值，表示擦除操作的状态。</li><li>FLASH_Status FLASH_EraseOptionBytes(void)：<br>该函数用于擦除Flash存储器中的选项字节。选项字节是一些用于配置Flash存储器和设备行为的特殊字节。函数返回一个FLASH_Status类型的值，表示擦除操作的状态。</li></ol></blockquote><p>这些函数用于在运行时对Flash存储器进行擦除操作。在调用这些函数之前，请确保已经解锁Flash的访问权限（通过调用FLASH_Unlock函数）</p><h2 id="STM32库函数中FLASH写操作相关函数解析"><a href="#STM32库函数中FLASH写操作相关函数解析" class="headerlink" title="STM32库函数中FLASH写操作相关函数解析"></a>STM32库函数中FLASH写操作相关函数解析</h2><pre class="line-numbers language-none"><code class="language-none">FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是三个函数用于将数据编程到STM32的Flash存储器中。以下是这些函数的解释：</p><blockquote><ol><li>FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)：<br>该函数用于将一个32位的数据（Data）编程到指定地址（Address）的Flash存储器中。函数返回一个FLASH_Status类型的值，表示编程操作的状态。</li><li>FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)：<br>该函数用于将一个16位的数据（Data）编程到指定地址（Address）的Flash存储器中。函数返回一个FLASH_Status类型的值，表示编程操作的状态。</li><li>FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)：<br>该函数用于将一个8位的数据（Data）编程到指定地址（Address）的Flash存储器的选项字节中。选项字节是一些用于配置Flash存储器和设备行为的特殊字节。函数返回一个FLASH_Status类型的值，表示编程操作的状态。</li></ol></blockquote><p>这些函数可以在运行时使用，将数据编程到Flash存储器中。在调用这些函数之前，请确保已经解锁Flash的访问权限（通过调用FLASH_Unlock函数）。在编程之前，请确保已经擦除了要写入的Flash页面。</p><h2 id="STM32库函数中FLASH写保护、读出保护、配置选项字节操作相关函数解析"><a href="#STM32库函数中FLASH写保护、读出保护、配置选项字节操作相关函数解析" class="headerlink" title="STM32库函数中FLASH写保护、读出保护、配置选项字节操作相关函数解析"></a>STM32库函数中FLASH写保护、读出保护、配置选项字节操作相关函数解析</h2><pre class="line-numbers language-none"><code class="language-none">LASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages);FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState);FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以下是这些函数的解释：</p><blockquote><ol><li>FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)：<br>该函数用于启用Flash存储器中指定页面（FLASH_Pages）的写保护。写保护功能可以防止对特定页面的数据写入操作。函数返回一个FLASH_Status类型的值，表示操作的状态。</li><li>FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)：<br>该函数用于配置Flash存储器的读出保护功能。NewState参数用于启用或禁用读出保护功能。函数返回一个FLASH_Status类型的值，表示操作的状态。</li><li>FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)：<br>该函数用于配置用户选项字节（User Option Bytes），用于设置设备的特定选项。OB_IWDG、OB_STOP和OB_STDBY参数用于配置选项字节的不同选项。函数返回一个FLASH_Status类型的值，表示操作的状态。</li></ol></blockquote><p>这些函数用于在运行时对Flash存储器进行写保护、读出保护和配置选项字节的操作。在调用这些函数之前，请确保已经解锁Flash的访问权限（通过调用FLASH_Unlock函数）。</p><h2 id="STM32库函数中FLASH获取相关设置结果的函数解析"><a href="#STM32库函数中FLASH获取相关设置结果的函数解析" class="headerlink" title="STM32库函数中FLASH获取相关设置结果的函数解析"></a>STM32库函数中FLASH获取相关设置结果的函数解析</h2><pre class="line-numbers language-none"><code class="language-none">uint32_t FLASH_GetUserOptionByte(void);uint32_t FLASH_GetWriteProtectionOptionByte(void);FlagStatus FLASH_GetReadOutProtectionStatus(void);FlagStatus FLASH_GetPrefetchBufferStatus(void);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下是这些函数的解释：</p><blockquote><ol><li>uint32_t FLASH_GetUserOptionByte(void)：<br>该函数用于获取用户选项字节（User Option Bytes）的值。用户选项字节是用于设置设备的特定选项的字节。</li><li>uint32_t FLASH_GetWriteProtectionOptionByte(void)：<br>该函数用于获取写保护选项字节的值。写保护选项字节用于配置Flash存储器中的写保护功能。</li><li>FlagStatus FLASH_GetReadOutProtectionStatus(void)：<br>该函数用于获取Flash存储器的读出保护状态。返回的FlagStatus类型值表示读出保护是否已启用。</li><li>FlagStatus FLASH_GetPrefetchBufferStatus(void)：<br>该函数用于获取预取缓存器（Prefetch Buffer）的状态。返回的FlagStatus类型值表示预取缓存器是否已启用。</li></ol></blockquote><p>这些函数用于获取Flash存储器的信息,跟上面的函数作用相反</p><h2 id="STM32库函数中FLASH有关中断配置以及执行状态获取的函数解析"><a href="#STM32库函数中FLASH有关中断配置以及执行状态获取的函数解析" class="headerlink" title="STM32库函数中FLASH有关中断配置以及执行状态获取的函数解析"></a>STM32库函数中FLASH有关中断配置以及执行状态获取的函数解析</h2><pre class="line-numbers language-none"><code class="language-none">void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG);void FLASH_ClearFlag(uint32_t FLASH_FLAG);FLASH_Status FLASH_GetStatus(void);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下是这些函数的解释：</p><blockquote><ol><li>void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)：<br>该函数用于配置Flash存储器的中断功能。FLASH_IT参数用于指定要配置的中断类型，NewState参数用于启用或禁用中断功能。</li><li>FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)：<br>该函数用于获取指定Flash标志位的状态。FLASH_FLAG参数用于指定要查询的标志位，返回的FlagStatus类型值表示标志位的状态。</li><li>void FLASH_ClearFlag(uint32_t FLASH_FLAG)：<br>该函数用于清除指定的Flash标志位。FLASH_FLAG参数用于指定要清除的标志位。</li><li>FLASH_Status FLASH_GetStatus(void)：<br>该函数用于获取Flash存储器的状态。<br>这些函数用于操作Flash存储器的中断和标志位。使用FLASH_ITConfig函数可以配置Flash存储器的中断功能，通过指定FLASH_IT参数来选择要配置的中断类型，通过NewState参数来启用或禁用中断。使用FLASH_GetFlagStatus函数可以获取指定标志位的状态，通过指定FLASH_FLAG参数来选择要查询的标志位，返回的FlagStatus类型值表示标志位的状态。使用FLASH_ClearFlag函数可以清除指定的标志位，通过指定FLASH_FLAG参数来选择要清除的标志位。</li></ol></blockquote><p>一般在进行FLASH之前会认为的清除对应标准确保FLASH处于未被操作的状态。也可以通过FLASH_GetStatus函数来获取Flash存储器的状态。<br>以便根据需要采取相应的处理措施。<br>返回值类型为 <code>FLASH_Status</code>，表示Flash存储器的操作状态。可能的返回值包括：</p><ul><li>FLASH_COMPLETE：上一次的Flash操作已完成。</li><li>FLASH_TIMEOUT：Flash操作超时。</li><li>FLASH_BUSY：Flash存储器正忙，无法执行新的操作。</li><li>FLASH_ERROR_PG：Flash编程错误，写入数据失败。</li><li>FLASH_ERROR_WRP：Flash写保护错误，无法写入数据。</li></ul><p>函数 <code>FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)</code> 用于等待Flash存储器上一次操作的完成。<br>该函数的参数 Timeout是等待超时的时间，单位为毫秒。如果上一次的Flash操作在指定的超时时间内完成，函数将返回 FLASH_COMPLETE，表示操作已完成。如果超过了指定的超时时间，函数将返回 FLASH_TIMEOUT，表示操作超时。<br>返回值类型为 <code>FLASH_Status</code>，表示Flash存储器的操作状态。可能的返回值包括：</p><ul><li>FLASH_COMPLETE：上一次的Flash操作已完成。</li><li>FLASH_TIMEOUT：Flash操作超时。</li><li>FLASH_BUSY：Flash存储器正忙，无法执行新的操作。</li><li>FLASH_ERROR_PG：Flash编程错误，写入数据失败。</li><li>FLASH_ERROR_WRP：Flash写保护错误，无法写入数据。</li></ul><p>通过调用该函数，并传入适当的超时时间，可以等待Flash存储器上一次操作的完成，并根据返回值判断操作的状态。这样可以确保在进行下一次Flash操作之前，上一次操作已经完成。确保程序执行的正确性。</p><h1 id="STM32库函数中有关FLASH性能配置的几个函数"><a href="#STM32库函数中有关FLASH性能配置的几个函数" class="headerlink" title="STM32库函数中有关FLASH性能配置的几个函数"></a>STM32库函数中有关FLASH性能配置的几个函数</h1><pre class="line-numbers language-none"><code class="language-none">void FLASH_SetLatency(uint32_t FLASH_Latency);void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess);void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这三个函数用于配置STM32的Flash存储器访问性能和优化选项。以下是这些函数的解释：</p><blockquote><ol><li>void FLASH_SetLatency(uint32_t FLASH_Latency)：<br>该函数用于设置Flash存储器的访问延迟（Latency）。Flash存储器的访问延迟是指在访问Flash数据时需要的等待周期数。FLASH_Latency参数是一个表示访问延迟的值，具体取决于系统时钟频率和Flash存储器的性能特性。</li><li>void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)：<br>该函数用于配置Flash存储器的半周期访问。FLASH_HalfCycleAccess参数用于启用或禁用Flash存储器的半周期访问模式。在半周期访问模式下，访问Flash存储器的时钟周期被减半，可以提高Flash存储器的访问速度。参数FLASH_HalfCycleAccess可以是以下值之一：<ul><li>FLASH_HalfCycleAccess_Enable：启用半周期访问模式。</li><li>FLASH_HalfCycleAccess_Disable：禁用半周期访问模式。</li></ul></li><li>void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)：<br>该函数用于配置Flash存储器的预取缓冲区。预取缓冲区是用于提前读取Flash数据的缓冲区，可以加速Flash数据的访问。FLASH_PrefetchBuffer参数用于启用或禁用Flash存储器的预取缓冲区。参数FLASH_PrefetchBuffer可以是以下值之一：<ul><li>FLASH_PrefetchBuffer_Enable：启用预取缓冲区。</li><li>FLASH_PrefetchBuffer_Disable：禁用预取缓冲区。</li></ul></li></ol></blockquote><p>这些函数可以根据需要在初始化阶段或运行时阶段调用，以配置Flash存储器的访问性能和优化选项。具体使用哪些函数以及参数取决于系统要求和性能需求。</p><h1 id="STM32的FLASH如何进行编程（库函数样例）"><a href="#STM32的FLASH如何进行编程（库函数样例）" class="headerlink" title="STM32的FLASH如何进行编程（库函数样例）"></a>STM32的FLASH如何进行编程（库函数样例）</h1><pre class="line-numbers language-none"><code class="language-none">int main(void)&#123;  &#x2F;*!&lt; At this stage the microcontroller clock setting is already configured,        this is done through SystemInit() function which is called from startup       file (startup_stm32f10x_xx.s) before to branch to application main.       To reconfigure the default setting of SystemInit() function, refer to       system_stm32f10x.c file     *&#x2F;&#x2F;* Porgram FLASH Bank1 ********************************************************&#x2F;  &#x2F;* Unlock the Flash Bank1 Program Erase controller *&#x2F;  FLASH_UnlockBank1();  &#x2F;* Define the number of page to be erased *&#x2F;  NbrOfPage &#x3D; (BANK1_WRITE_END_ADDR - BANK1_WRITE_START_ADDR) &#x2F; FLASH_PAGE_SIZE;  &#x2F;* Clear All pending flags *&#x2F;  FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);  &#x2F;* Erase the FLASH pages *&#x2F;  for(EraseCounter &#x3D; 0; (EraseCounter &lt; NbrOfPage) &amp;&amp; (FLASHStatus &#x3D;&#x3D; FLASH_COMPLETE); EraseCounter++)  &#123;    FLASHStatus &#x3D; FLASH_ErasePage(BANK1_WRITE_START_ADDR + (FLASH_PAGE_SIZE * EraseCounter));  &#125;    &#x2F;* Program Flash Bank1 *&#x2F;  Address &#x3D; BANK1_WRITE_START_ADDR;  while((Address &lt; BANK1_WRITE_END_ADDR) &amp;&amp; (FLASHStatus &#x3D;&#x3D; FLASH_COMPLETE))  &#123;    FLASHStatus &#x3D; FLASH_ProgramWord(Address, Data);    Address &#x3D; Address + 4;  &#125;  FLASH_LockBank1();    &#x2F;* Check the correctness of written data *&#x2F;  Address &#x3D; BANK1_WRITE_START_ADDR;  while((Address &lt; BANK1_WRITE_END_ADDR) &amp;&amp; (MemoryProgramStatus !&#x3D; FAILED))  &#123;    if((*(__IO uint32_t*) Address) !&#x3D; Data)    &#123;      MemoryProgramStatus &#x3D; FAILED;    &#125;    Address +&#x3D; 4;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码展示了一个主函数的示例，其中包含了对Flash的擦除、编程和数据验证操作。以下是对每个步骤的解释：</p><blockquote><ol><li>对系统进行初始化：在main函数之前，通过调用SystemInit()函数来配置微控制器的时钟设置和其他系统初始化。可以在system_stm32f10x.c文件中重新配置SystemInit()函数的默认设置。</li><li>解锁Flash Bank1：调用FLASH_UnlockBank1()函数来解锁Flash Bank1的编程和擦除控制器，允许对其进行操作。</li><li>计算需要擦除的页数：通过计算Flash可编程区域的起始地址和结束地址之间的页数，得到需要擦除的页数。每页的大小由FLASH_PAGE_SIZE定义。</li><li>清除标志位：调用FLASH_ClearFlag()函数来清除Flash的待处理标志位，包括操作结束标志位(EOP)、编程错误标志位(PGERR)和写保护错误标志位(WRPRTERR)。</li><li>擦除Flash页：使用循环结构，调用FLASH_ErasePage()函数来逐页擦除Flash。循环会检查擦除操作的状态，并在满足条件时继续进行下一页的擦除。</li><li>编程Flash：使用循环结构，调用FLASH_ProgramWord()函数来逐字编程Flash。循环会检查编程操作的状态，并在满足条件时继续进行下一个地址的编程。</li><li>加锁Flash Bank1：调用FLASH_LockBank1()函数来锁定Flash Bank1，防止进一步的编程和擦除操作。</li><li>验证数据的正确性：使用循环结构，通过读取Flash中的数据与预期的数据进行比较，来验证数据的正确性。如果发现不一致的数据，则将MemoryProgramStatus标记为FAILED。</li></ol></blockquote><p>这段代码展示了如何在主函数中执行Flash的擦除、编程和数据验证操作。在实际应用中，需要根据具体的需求和硬件配置进行相应的调整和错误处理。</p><h1 id="在STM32F103C8T6上进行验证"><a href="#在STM32F103C8T6上进行验证" class="headerlink" title="在STM32F103C8T6上进行验证"></a>在STM32F103C8T6上进行验证</h1><pre class="line-numbers language-none"><code class="language-none">#define STM32PAGESIZE 1024  &#x2F;&#x2F;一个页的字节数是1K&#x2F;&#x2F;写数据到FLASH中并加上校验uint8_t STM32Flash_SaveParm(uint32_t Addr,uint8_t *pdata,uint16_t len)&#123;uint16_t i&#x3D;0,Page;uint32_t tmpAddr,tmplen,Sum&#x3D;0;if(Addr%4)return0;FLASH_Unlock();FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);tmpAddr &#x3D; Addr-Addr%STM32PAGESIZE;if(Addr%STM32PAGESIZE)&#123;tmplen &#x3D; len+Addr%STM32PAGESIZE-STM32PAGESIZE;Page   &#x3D; 1;&#125;else&#123;tmplen &#x3D; len;Page   &#x3D; 0;&#125;Page +&#x3D; tmplen&#x2F;STM32PAGESIZE;if(tmplen%STM32PAGESIZE)Page++;for(i&#x3D;0;i&lt;Page;i++)FLASH_ErasePage(tmpAddr+i*STM32PAGESIZE);for(i&#x3D;0;i&lt;len;i++)Sum+&#x3D;pdata[i];for(i&#x3D;0;i&lt;len&#x2F;4;i++)&#123;FLASH_ProgramWord(Addr, *(uint32_t*)pdata);pdata +&#x3D;4;Addr  +&#x3D;4;&#125;if(len%4)&#123;uint8_t buf[4]&#x3D;&#123;0&#125;,j;for(j&#x3D;0;j&lt;len%4;j++)         buf[j]&#x3D;*pdata++;FLASH_ProgramWord(Addr, *(uint32_t*)buf);Addr+&#x3D;4;&#125;FLASH_ProgramWord(Addr, Sum);FLASH_Lock();return0;&#125;&#x2F;&#x2F;读数据从FLASH中并计算校验uint8_t STM32Flash_ReadParm(uint32_t Addr,uint8_t *pdata,uint16_t len)&#123;uint16_t i;uint32_t Sum&#x3D;0;uint8_t *qdata&#x3D;pdata;if(Addr%4)return0;for(i&#x3D;0;i&lt;len&#x2F;4;i++)&#123;*(uint32_t*)pdata&#x3D;*(uint32_t*)Addr;Addr+&#x3D;4;pdata+&#x3D;4;&#125;if(len%4)&#123;uint8_t buf[4]&#x3D;&#123;0&#125;;*(uint32_t*)buf&#x3D;*(uint32_t*)Addr;Addr+&#x3D;4;for(i&#x3D;0;i&lt;len%4;i++)*pdata++&#x3D;buf[i];&#125;for(i&#x3D;0;i&lt;len;i++)Sum+&#x3D;(*qdata++);if(Sum!&#x3D;*(uint32_t*)Addr)&#123;return1;&#125;return0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>FLASH的读写在IAP或者OTA以及fatfs上有很重要的应用，这篇文章就先记录这么多，后面会考虑实现一个单片机给（F407）给另外一个单片机（F103）进行程序升级。对这一块儿感兴趣的朋友可以关注，最近关注我的朋友越来越多，我定期更新的动力也越来越足，争取尽快更新~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> STM32 </tag>
            
            <tag> FLM </tag>
            
            <tag> CMSIS-DAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FOC控制算法详解</title>
      <link href="/20230602/learn_algorithm/FOC%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
      <url>/20230602/learn_algorithm/FOC%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h1><blockquote><p>FOC（field-oriented control）为磁场导向控制，又称为矢量控制（vector control），是一种利用变频器（VFD）控制三相电机的技术，利用调整变频器的输出频率、输出电压的大小及角度，来控制电机的输出。由于处理时会将三相输出电流及电压以矢量来表示，因此称为矢量控制。</p></blockquote><h1 id="控制原理："><a href="#控制原理：" class="headerlink" title="控制原理："></a>控制原理：</h1><p>FOC控制的其实是电机的电磁场方向。转子的转子力矩正比于定子的磁场向量与转子磁场矢量的矢量积。由矢量的关系可知，若使电机的转矩时刻保持最大，则定子磁场向量应与转子磁场向量相互垂直。又因为磁场的大小与方向与电流的大小与方向有着直接的关系，所以在用FOC控制算法控制BLDC时的关键就是控制三相输入的电流大小与方向。而控制电流产生定子磁场与转子磁场垂直的关键在：控制稳定的三相输入电压及其电流向量，并且我们得知道转子的实时位置。<br>输入电流的方向控制，FOC给出了空间电流矢量的概念。其实质是将三相的电流矢量结合，再分解为垂直和平行于转子磁体轴方向的两个分量即d-q结构。垂直方向的电流分量所产生磁场正交于转子的磁场，这就产生了旋转力矩。而平行于转子磁轴方向的电流分量，所产生的磁场与转子磁场一致，就不会产生任何的力矩。另外，一个好的控制算法就需要使这个平行于转子磁轴方向的电流分量尽量最小化，因为，这个电流分量只会使电机产生多余的热量，并加剧轴承的磨损。我们需要控制线圈的电流，以使垂直于转子磁轴方向的电流分量达到最大。由此而得到的电机力矩和这个电流分量的大小成比例。<br>为了使与转子磁场同向的定子电流矢量最小化（为零）且垂直的磁场最大化，定子线圈内的弦波电流需要随着转子的转动角度实时地进行相位调整。控制稳定的三相电流输入可以建立P-I控制器，P-I控制是在不停的调制输入，一旦电机电流被转化成d-q结构，控制将变得非常简单。我们需要两路P-I控制器；一个控制平行与转子磁场的电流，一个控制垂直向电流。因为平行向电流的控制信号为零，所以这就使电机平行向的电流分量也变成零，这也就驱使电机的电流矢量全部转化为垂直向的电流。由于只有垂直向电流才能产生有效的力矩，这样电机的效率被最大化。另一路P-I控制器主要用来控制垂直向的电流，以获得与输入信号相符的需求力矩。这也就使垂直向电流按照要求被控制以获得所需的力矩。<br>转子的实时位置的确定有两种情况：有位置传感器、无位置传感器。对于有传感器，由于电机的传感器（一般为编码器）能反馈电机转子的位置信息，因此在控制中可以不使用位置估算算法，控制起来相对无传感器简单，但是对带传感器的电机应用来说，往往对控制性能要求较高。对于无传感器，由于电机不带任何传感器，因此不能通过简单读取传感器的测量值来得到电机转子的位置信息，所以在控制中需要通过采集电机相电流，使用位置估算算法来计算转子位置。</p><p>具体的FOC控制原理图：<br><img src="/images/learn/foc/20201118222302612.png" alt="图片"></p><ol><li>采集到两相电流</li><li>经过clarke变换后得到两轴正交电流量,</li><li>经过旋转变换后得到正交的电流量 Id、Iq，其中Iq与转矩有关，Id与磁通有关。在实际控制中，常将Id置为０。得到的这两个量不是时变的，因此可以单独的对这两个量进行控制，类似直流量控制一样。而不需要知道具体要给电机三相具体的电压为多少。</li><li>将第３步中得到的Iq与Id量分别送进PI调节器，得到对应的输出Vq和Ｖd;</li><li>通过传感器得到电机转过的角度。</li><li>进行逆park变换，得到二轴电流量。</li><li>对第６步中的Va,Vb进行逆clarke变换，得到实际需要的三相电压输入给逆变电桥，驱动电机转动。</li></ol><h1 id="坐标变换理论："><a href="#坐标变换理论：" class="headerlink" title="坐标变换理论："></a>坐标变换理论：</h1><p>坐标变换理论可以降低马达方程的复杂性，利用坐标变换把定子及转子变量变换到一个旋转坐标系中，该坐标系的转速为角速度ω。<br>假设fax, fbx, fcx 为三相瞬时变量，位于相移120度的a,b,c坐标上，fqx, fdx, f0x 为其变换变量，位于正交坐标d,q上：<br><img src="/images/learn/foc/20201118222302501.png" alt="图片"></p><p>变换方程为：<br><img src="/images/learn/foc/20201118222302611.png" alt="图片"></p><p>3个变换方程用于矢量控制：<br>Clarke:     <code>ω=0, θ(0)=0 -&gt; θ=0</code><br>Park:       <code>ω=ωr, θ(0)=θr(0) -&gt; θ=θr</code><br>反Park:     <code>ω=-ωr , θ(0)= θr(0) -&gt;θ=-θr</code></p><p>所以有：Clarke将定子电流转变为静止直角参考坐标（称αβ坐标）；然后，Park将电流转变为按随机的速度旋转的坐标为（磁场定向控制，与转子同步）；反向Park变换使反电动势从旋转坐标（q, d）到静止坐标。变换过程如下图：<br><img src="/images/learn/foc/20201118222616259.png" alt="图片"></p><p>Clark变换应用于定子电流：<br><img src="/images/learn/foc/20201118222302505.png" alt="图片"></p><p>Park变换应用于定子电流：<br><img src="/images/learn/foc/20201118222302533.png" alt="图片"></p><p>Park逆运算变换应用于定子电压：<br><img src="/images/learn/foc/20201118222302534.png" alt="图片"></p><p>程序的运行过程：<br>1、程序先通过 ADC 采样，对 BLDC 电机的 a、b 两相进行电流采样；<br>2、通过 Clarke() 函数将 a、b 两相电流转换为静止坐标系上的电流  Iα、Iβ ；<br>3、由 Park() 函数将电流  Iα、Iβ 和经 DAC 转换的旋转角度θ转化为电流 Iq、Id；<br>4、将电流 Iq、Id 的电流差输入到建立的 PI 控制器里，通过调节适当的 PI 控制系数输出最佳的旋转电压Vd、Vq；<br>5、用 Circle Limitation 来限制 Vd、Vq 的值以选择恰当的值；<br>6、用 Rev_Park()函数将旋转电压 Vd、Vq 转换为静止坐标系上的电压Vα、Vβ；<br>7、通过三电阻式相电流重构法将电压 Vα、Vβ ，重新建立为 BLDC 电机的三相电压 Ux、Uy、Uw 的大小；<br>8、用 SV_PWM 算法计算矢量及其分分扇区的扇区信息，通过控制 TIM 控制6个 MOSFET 管来控制各相电压方向以达到最后的控制目的。</p><h1 id="扇区的计算："><a href="#扇区的计算：" class="headerlink" title="扇区的计算："></a>扇区的计算：</h1><p>扇区六种状态的计算方式，令 N=4<em>C+2</em>B+A；  N值与扇区的对应关系：<br><img src="/images/learn/foc/20201118222302537.png" alt="图片"></p><p>基本矢量作用时间计算与三相 PWM 波形的合成：<br>PWM 周期计数器的值——为NTpwm=fdsp/fs/2。</p><p>发波系数：<br><img src="/images/learn/foc/20201118222302538.png" alt="图片"></p><p>Unom 为系统额定电压（线电压），开关频率为 fs ，系统时钟为 fc，输入额定电压 Udc，则PWM周期计数器的值：NTpwm=fc/fs/2。</p><p>又有电压基值<img src="/images/learn/foc/20201118222302490.png" alt="图片">，实际电压 U=U’Ubase，U’为标幺值，可以计算得到各扇区基本矢量的作用时间：<br><img src="/images/learn/foc/20201118222302635.png" alt="图片"></p><h1 id="AD采样："><a href="#AD采样：" class="headerlink" title="AD采样："></a>AD采样：</h1><p>STM32 的12位ADC是一种逐次逼近型模拟数字转换器。它有多达18个通道，可测量16个外部和2个内部信号源。各通道的A/D转换可以单次、连续、扫描或间断模式执行。ADC的结果可以左对齐或右对齐方式存储在16位数据寄存器中。</p><p>ADC采样程序流程：<br>1、采样前需要读取三个采样通道的零电流值，以进行传感器校准；<br>2、ADC经TIM1的N通道进行上升沿实践触发后进入中断，进入起动模式，通过FOC驱动算法获得采样值，用计算出的值Vα、Vβ来判断其所在扇区位置和三相PWM输出的占空比；<br><strong>ADC采样注意事项</strong>：只有在下桥臂打开时由SVPWM的当前扇区决定该读哪两相电流，程序中只采样A、B相电流，C相的电流通过 Ia+Ib+Ic=0 的电机电流关系得出。</p><p>每次桥臂开关状态有变化时，会在shunt电阻上的电压产生一个电子干扰，时间长度为TNoise，且当下桥臂打开后，需要等待一段时间来使shunt电阻上的电压达到稳定值，时间长度为TRise，所以在TNoise 及TRise期间不能读相电流；</p><p><em>单电阻采样的时刻与三电阻不一样，且对于变负载或者位置环的应用，单电阻采样不准，因此不建议采用。</em></p><h1 id="磁链输出限制"><a href="#磁链输出限制" class="headerlink" title="磁链输出限制"></a>磁链输出限制</h1><p>对于FOC算法，Vqs与Vds是由2个PID调节器单独计算的，因此需要正确计算电压矢量V，使之输入到SVPWM模块最大的电压幅值为：S16_MAX (即：32767)。<br><img src="/images/learn/foc/20201118222302584.png" alt="图片"></p><h1 id="单电阻采样的原理："><a href="#单电阻采样的原理：" class="headerlink" title="单电阻采样的原理："></a>单电阻采样的原理：</h1><p>对于一个电机驱动硬件系统，硬件的简化框图如下：<br>![图片](/images/learn/foc/20201118222302501 (1).png)</p><p>对于下桥臂的每一个开关状态，其对应的流过采样电阻的电流如表1。T4, T5 及T6 的开关状态与T1, T2 及T3互补。在表1中， 值“0” 表示开关管关闭，而“1”表示开关管打开。<br><img src="/images/learn/foc/20201118222302532.png" alt="图片"><br><img src="/images/learn/foc/20201118222302535.png" alt="图片"></p><p>其最终生成的输出PWM如下图所示：<br><img src="/images/learn/foc/20201118222302524.png" alt="图片"></p><p>使用中心对称模式, 每个PWM 周期被分成7个时间段；</p><ul><li>在其中的三个时间段(I,IV,VII)，电阻中的电流为0；</li><li>在其余的时间段，由于PWM为中心对称模式，电阻中的电流是对称的；</li><li>如图所示，存在两种情况：</li><li>时间段II 及VI， iShunt = –iC；</li><li>时间段III 及V， iShunt = iA；</li><li>因此，此时有可能从采样值重建马达的三相电流：</li><li>时间段III 及V , iA = iShunt</li><li>时间段II 及VI, iC = -iShunt</li><li>iB = -iA - iC</li></ul><p>由于电流会有一定的稳定时间，我们需要避开这个时间。<br>定义<code>TRise</code>： 任一管子开关后，ADC通道上的输入信号的稳定时间；<br>定义<code>Tmin</code>： 执行电流采样所需要的最小时间：等于TRise + ADC 采样时间 + 死区时间；<br>定义<code>DMIN</code>：TMIN的占空比的表达形式<br><img src="/images/learn/foc/20201118222302540.png" alt="图片"></p><p>则由图可以看出，AD采样是需要避开电流稳定的时间段，通常是通过延时一段时间后采样来实现的。但是，存在以下两种情况，就会衍生出电流采样不准的问题：</p><p>1、相邻空间矢量扇区的边界区域</p><blockquote><p><img src="/images/learn/foc/20201118222302538.png" alt="图片"><br>在相邻的两个空间矢量扇区的边界区域, 有两个桥臂的占空比几乎相同；<br>在这种情况下，七个子时间段变成了五个，这样的后果为：只可能采样到两个相电流中的一个；<br>因此，如果电压矢量进入到下图的灰色区域，就不能在同一个PWM周期中同时采样到两个相电流。</p></blockquote><p>2、低调制比</p><blockquote><p>在低调制比的情况下，三个桥臂的占空比几乎相同；</p><ul><li>在这种情况下，七个子时间段变成了三个；</li><li>在所有的三个时间段，流过采样电阻的电流为0；</li><li>这就意味着当电压矢量进入下列灰色区域时，无法采样到相电流。</li></ul></blockquote><p>备注: 三电阻可以在任何时刻采样,不存在此类问题。<br><img src="/images/learn/foc/20201118222302531.png" alt="图片"></p><p>对于FOC库里面的电流采样的函数，主要是以下几个：</p><table><thead><tr><th align="left">函数名</th><th align="left">描述</th><th align="left">调用时刻</th></tr></thead><tbody><tr><td align="left">SVPWM_1ShuntInit</td><td align="left">初始化PWM 及 ADC 外设</td><td align="left">MCU复位后</td></tr><tr><td align="left">SVPWM_1ShuntCurrent<br>ReadingCalibration</td><td align="left">存储零电流时采样电路的ADC值</td><td align="left">马达启动命令后</td></tr><tr><td align="left">SVPWM_1Shunt<br>GetPhaseCurrentValues</td><td align="left">计算相A 及 相B的电流值</td><td align="left">在ADC转换完成后及FOC 子程序之前</td></tr><tr><td align="left">SVPWM_1Shunt<br>CalcDutyCycles</td><td align="left">计算占空比值，配置下一次电流 <br>采样时的ADC及定时器模式.</td><td align="left">FOC 子程序之后</td></tr><tr><td align="left">SVPWMUpdateEvent</td><td align="left">在Update 事件的 ISR 中执行的子程序</td><td align="left">在 Update 事件的 ISR 中</td></tr><tr><td align="left">SVPWMEOCEvent</td><td align="left">在ADC转换结束事件的 ISR 中执行的子程序</td><td align="left">在ADC转换结束事件的 ISR 中</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 机电控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PID到底是个啥？来给你讲个故事</title>
      <link href="/20230602/learn_algorithm/PID%E6%98%AF%E5%95%A5.html"/>
      <url>/20230602/learn_algorithm/PID%E6%98%AF%E5%95%A5.html</url>
      
        <content type="html"><![CDATA[<h1 id="啥是PID？"><a href="#啥是PID？" class="headerlink" title="啥是PID？"></a>啥是PID？</h1><p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）”，是一种很常见的控制算法。<br>PID已经有107年的历史了。<br>它并不是什么很神圣的东西，大家一定都见过PID的实际应用。<br>比如四轴飞行器，再比如平衡小车……还有汽车的定速巡航、3D打印机上的温度控制器….<br>就是类似于这种：需要将某一个物理量“保持稳定”的场合（比如维持平衡，稳定温度、转速等），PID都会派上大用场。<br><img src="/images/learn/pid/DnyD2qNnN8cTMOhMEHU9Ng_001.jpg" alt="图片"></p><p>那么问题来了：<br>比如，我想控制一个“热得快”，让一锅水的温度保持在50℃，这么简单的任务，为啥要用到微积分的理论呢!</p><p>你一定在想：<br>这不是so easy嘛~ 小于50度就让它加热，大于50度就断电，不就行了？几行代码用Arduino分分钟写出来。<br>没错~在要求不高的情况下，确实可以这么干~ But！如果换一种说法，你就知道问题出在哪里了：</p><p>如果我的控制对象是一辆汽车呢？<br>要是希望汽车的车速保持在50km/h不动，你还敢这样干么。<br>设想一下，假如汽车的定速巡航电脑在某一时间测到车速是45km/h。它立刻命令发动机：加速！<br>结果，发动机那边突然来了个100%全油门，嗡的一下，汽车急加速到了60km/h。<br>这时电脑又发出命令：刹车！<br>结果，吱……………哇…………(乘客吐)</p><p>所以，在大多数场合中，用“开关量”来控制一个物理量，就显得比较简单粗暴了。有时候，是无法保持稳定的。因为单片机、传感器不是无限快的，采集、控制需要时间。<br>而且，控制对象具有惯性。比如你将一个加热器拔掉，它的“余热”（即热惯性）可能还会使水温继续升高一小会。<br>这时，就需要一种『算法』：</p><ul><li>它可以将需要控制的物理量带到目标附近</li><li>它可以“预见”这个量的变化趋势</li><li>它也可以消除因为散热、阻力等因素造成的静态误差</li><li>….</li></ul><h1 id="PID算法"><a href="#PID算法" class="headerlink" title="PID算法"></a>PID算法</h1><p>于是，当时的数学家们发明了这一历久不衰的算法——这就是PID。<br>你应该已经知道了，P，I，D是三种不同的调节作用，既可以单独使用（P，I，D），也可以两个两个用（PI，PD），也可以三个一起用（PID）。<br>这三种作用有什么区别呢？客官别急，听我慢慢道来<br><img src="/images/learn/pid/DnyD2qNnN8cTMOhMEHU9Ng_002.gif" alt="图片"><br>我们先只说PID控制器的三个最基本的参数：kP,kI,kD。</p><h2 id="kP"><a href="#kP" class="headerlink" title="kP"></a>kP</h2><blockquote><p>P就是比例的意思。它的作用最明显，原理也最简单。我们先说这个：<br>需要控制的量，比如水温，有它现在的『当前值』，也有我们期望的『目标值』。<br>当两者差距不大时，就让加热器“轻轻地”加热一下。<br>要是因为某些原因，温度降低了很多，就让加热器“稍稍用力”加热一下。<br>要是当前温度比目标温度低得多，就让加热器“开足马力”加热，尽快让水温到达目标附近。<br>这就是P的作用，跟开关控制方法相比，是不是“温文尔雅”了很多!<br>实际写程序时，就让偏差（目标减去当前）与调节装置的“调节力度”，建立一个一次函数的关系，就可以实现最基本的“比例”控制了~<br>kP越大，调节作用越激进，kP调小会让调节作用更保守。<br>要是你正在制作一个平衡车，有了P的作用，你会发现，平衡车在平衡角度附近来回“狂抖”，比较难稳住。<br>如果已经到了这一步——恭喜你！离成功只差一小步了~</p></blockquote><h2 id="kD"><a href="#kD" class="headerlink" title="kD"></a>kD</h2><blockquote><p>D的作用更好理解一些，所以先说说D，最后说I。<br>刚才我们有了P的作用。你不难发现，只有P好像不能让平衡车站起来，水温也控制得晃晃悠悠，好像整个系统不是特别稳定，总是在“抖动”。<br><img src="/images/learn/pid/DnyD2qNnN8cTMOhMEHU9Ng_003.gif" alt="图片"><br>你心里设想一个弹簧：现在在平衡位置上。拉它一下，然后松手。这时它会震荡起来。因为阻力很小，它可能会震荡很长时间，才会重新停在平衡位置。<br>请想象一下：要是把上图所示的系统浸没在水里，同样拉它一下 ：这种情况下，重新停在平衡位置的时间就短得多。<br>我们需要一个控制作用，让被控制的物理量的“变化速度”趋于0，即类似于“阻尼”的作用。<br>因为，当比较接近目标时，P的控制作用就比较小了。越接近目标，P的作用越温柔。有很多内在的或者外部的因素，使控制量发生小范围的摆动。<br>D的作用就是让物理量的速度趋于0，只要什么时候，这个量具有了速度，D就向相反的方向用力，尽力刹住这个变化。<br>kD参数越大，向速度相反方向刹车的力道就越强。<br>如果是平衡小车，加上P和D两种控制作用，如果参数调节合适，它应该可以站起来了~欢呼吧!<br>等等，PID三兄弟好像还有一位。看起来PD就可以让物理量保持稳定，那还要I干嘛？<br>因为我们忽视了一种重要的情况：</p></blockquote><h2 id="kI"><a href="#kI" class="headerlink" title="kI"></a>kI</h2><blockquote><p>还是以热水为例。假如有个人把我们的加热装置带到了非常冷的地方，开始烧水了。需要烧到50℃。<br>在P的作用下，水温慢慢升高。直到升高到45℃时，他发现了一个不好的事情：天气太冷，水散热的速度，和P控制的加热的速度相等了。</p><p>这可怎么办？<br>P兄这样想：我和目标已经很近了，只需要轻轻加热就可以了。<br>D兄这样想：加热和散热相等，温度没有波动，我好像不用调整什么。<br>于是，水温永远地停留在45℃，永远到不了50℃。<br>作为一个人，根据常识，我们知道，应该进一步增加加热的功率。可是增加多少该如何计算呢？<br>前辈科学家们想到的方法是真的巧妙。<br>设置一个积分量。只要偏差存在，就不断地对偏差进行积分（累加），并反应在调节力度上。<br>这样一来，即使45℃和50℃相差不太大，但是随着时间的推移，只要没达到目标温度，这个积分量就不断增加。系统就会慢慢意识到：还没有到达目标温度，该增加功率啦！<br>到了目标温度后，假设温度没有波动，积分值就不会再变动。这时，加热功率仍然等于散热功率。但是，温度是稳稳的50℃。<br>kI的值越大，积分时乘的系数就越大，积分效果越明显。<br>所以，I的作用就是，减小静态情况下的误差，让受控物理量尽可能接近目标值。<br>I在使用时还有个问题：需要设定积分限制。防止在刚开始加热时，就把积分量积得太大，难以控制。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> PID </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必看深度：震惊世间的惊人“神码”！（附完整代码）</title>
      <link href="/20230602/learn_skill/%E9%9C%87%E6%83%8A%E4%B8%96%E9%97%B4%E7%9A%84%E6%83%8A%E4%BA%BA%E7%A5%9E%E7%A0%81.html"/>
      <url>/20230602/learn_skill/%E9%9C%87%E6%83%8A%E4%B8%96%E9%97%B4%E7%9A%84%E6%83%8A%E4%BA%BA%E7%A5%9E%E7%A0%81.html</url>
      
        <content type="html"><![CDATA[<h1 id="一战封神的-0x5f375a86"><a href="#一战封神的-0x5f375a86" class="headerlink" title="一战封神的 0x5f375a86"></a>一战封神的 0x5f375a86</h1><p>雷神之锤3是一款九十年代非常经典的游戏，内容画面都相当不错，作者是大名鼎鼎的约翰卡马克。由于当时游戏背景原因，如果想要高效运行游戏优化必须做的非常好，否则普通人的配置性能根本不够用，在这个背景下就诞生了“快速开平方取倒数的算法”。<br>在早前自雷神之锤3的源码公开后，卡马克大神的代码“一战封神”，令人“匪夷所思”的<code>0x5f375a86</code> ，引领了一代传奇。<br>相比<code>sqrt()</code>函数，这套算法要快将近4倍，要知道，编译器自带的函数，可是经过严格仔细的汇编优化的啊！<br>牛顿迭代法的原理是先猜测一个值，然后从这个值开始进行叠代。因此，猜测的值越准，叠代的次数越少。卡马克选了<code>0x5f3759df</code>这个值作为猜测的结果，再加上后面的移位算法，得到的y非常接近<code>1/sqrt(n)</code>。这样，我们只需要2次牛顿迭代法就可以达到我们所需要的精度。<br>函数返回1/sqrt(x),这个函数在图像处理中比sqrt(x)更有用。</p><p>注意到这个正数只用了一次叠代!(其实就是根本没用叠代，直接运算)。编译、实验，这个团数不仅工作的很好，而且比标准的<code>sqrt()</code>函数快4倍！<br>这个简洁的定数，最核心，也是最让人费解的，就是标注了whatthefuck的一句<code>i=0x5f3759df-(i&gt;&gt;1)；</code>再加上<code>y=y*(threehalfs-(x2*y*y))</code>。<br>两句话就完成了开方运算！而且注意到，核心那句是移位运算，速度极快！特别在很多没有乘法指令的RISC结构CPU上，这样做是极其高效的。<br>算法的原理就是使用牛顿迭代法,用 <code>x-f(x)/f&#39;(x)</code> 来不断的逼近 <code>f(x)=a</code> 的根。<br>求平方根：<code>f(x)=x^2=a ,f&#39;(x)= 2*x, f(x)/f&#39;(x)=x/2</code>,把 <code>f(x)</code> 代入 <code>x-f(x)/f&#39;(x)</code>后有<code>(x+a/x)/2</code>，<br>现在我们选 <code>a=5</code>,选一个猜测值比如 2，  那么我们可以这么算  <code>5/2 = 2.5; (2.5+2)/2 = 2.25; 5/2.25 = ……</code>  这样反复迭代下去，结果必定收敛于 <code>sqrt(5)</code>。<br>但是卡马克作者真正厉害的地方是他选择了一个神秘的常数 0x5f375a86来计算那个梦“值，<br>就是我们加注释的那一行那行算出的值非常接近1/sqrt(n)这样我们只需要2次牛顿迭代就可以达到我们所需要的精度。<br>当然目前也已有翻译过C++语言的版本： </p><pre class="line-numbers language-none"><code class="language-none">float Q_rsqrt(float number) &#123;  long i;  float x2, y;  const float threehalfs &#x3D; 1.5F;    x2 &#x3D; number * 0.5F;  y &#x3D; number;  i &#x3D; * (long *) &amp;y;         &#x2F;&#x2F; evil floating point bit level hacking  i &#x3D; 0x5f3759df - (i &gt;&gt; 1); &#x2F;&#x2F; what the fuck?  y &#x3D; *(float*) &amp;i;  y &#x3D; y * (threehalfs - (x2*y * y));      &#x2F;&#x2F; 1st iteration  &#x2F;&#x2F; y &#x3D; y * (threehalfs - (x2 * y * y)); &#x2F;&#x2F; 2nd iteration, this can be removed  #ifndef Q3_VM    #ifdef __linux__      assert(!isnan(y)); &#x2F;&#x2F; bk010122 - FPE?    #endif  #endif  return y; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，更加魔幻的是，普渡大学的数学家Chris Lomont看了以后觉得有趣，但也不服气，决定要研究一下卡马克弄出来的这个猜测值有什么奥秘。<br>在精心研究之后，Lomont从理论上也推导出一个最佳猜测值，和卡马克的数字非常接近, 0x5f37642f。Lomont计算出结果以后非常满意，于是拿自己计算出的起始值和卡马克的神秘数字做比赛，看看谁的数字能够更快更精确的求得平方根。结果是卡马克赢了…<br>Lomont怒了，采用暴力方法一个数字一个数字试过来，终于找到一个比卡马克数字要好上那么一丁点的数字，虽然实际上这两个数字所产生的结果非常近似，这个暴力得出的数字是0x5f375a86。</p><hr><h1 id="囊括世界万物的一段代码"><a href="#囊括世界万物的一段代码" class="headerlink" title="囊括世界万物的一段代码"></a>囊括世界万物的一段代码</h1><p>这是一段使用Processing语言的代码，这短短的几行代码永无休止的就在做一件事——“穷举”。那么它又有什么特殊之处吗？<br>忽略机器本身的性能限制，假设 frameCount 可以无限大（frameCount代表当前帧数）。只需安安静静地盯着屏幕，就可以看到所有像素的所有组合可能。<br>这意味着你可以在上面看到所有艺术大师的作品，蒙娜丽莎、向日葵甚至是初音……人类历史上所有光辉的瞬间都将闪现在眼前。<br>但是这又需要多久时间呢？计算机里的每个像素都是由 256 级的 RGB 组成的。因此可以表示 256 ³ （1600万）种颜色。假如图形的分辨率为 1000 × 1000，所有的像素可能的色值相互组合，将会产生 256 的 3000000 次方张不同图片。<br>如果将图片排在一个长廊上，人以一秒一张的速度去浏览。由于一年有 31536000 秒，因此要走完这条长廊，就需要 10⁷²²⁴⁷¹² 年。<br>这个数字已经大得很难用人类的常用单位去表示了。硬是要用，那就是 10亿亿亿亿亿亿……年（90万个亿）。要清楚，宇宙的年龄也仅仅是 140 亿年（1.4 × 10¹⁰年）。。<br>这也意味着，即使你从宇宙大爆炸看到现在，也无法将这个程序看完。但如果把图片像素的精度降低呢？用 100 × 100 的分辨率并且只用黑白二值去表示图形？此时总数就会缩减到 2⁷⁰⁰⁰⁰ ，也就约等于 10³⁰¹⁰。<br>看似缩小很多了。如果同时动用全人类的力量，将这个任务分配给70亿人。每人还是要不眠不休地看上 3.17 × 10³⁰⁰² 年，才能看完。<br>即使化到最简，结果仍是大得恐怖。但如果能看完，我手上说不准会有一张 100 × 100 的HelloKitty头像，他手上或许能有一张爱因斯坦吐舌头的照片。<br>可以用这么简洁的形式去展现万物，用近乎无限的时间去换取无限的可能，我觉得这就是这段代码的魅力所在。</p><pre class="line-numbers language-none"><code class="language-none">void setup()&#123;  size(500, 500);&#125;void draw()&#123;  for (int i &#x3D; 0; i &lt; width; i++)  &#123;    for (int j &#x3D; 0; j &lt; height; j++)    &#123;      stroke(frameCount&#x2F;pow(255,i+j*width)%255, frameCount&#x2F;pow(255,i+j*width+1)%255, frameCount&#x2F;pow(255,i+j*width+2)%255);      point(i, j);    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码也有5x5的精简加速版本，当然其中的参数也是可以任意修改的，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">int num, w, frame, level;void setup()&#123;  size(400, 400);  num &#x3D; 5;  w &#x3D; width &#x2F; num;  level &#x3D; 2; &#x2F;&#x2F; 色值精度&#125;void draw()&#123;  for (int i &#x3D; 0; i &lt; num; i++)  &#123;    for (int j &#x3D; 0; j &lt; num; j++)    &#123;      fill((int(frame &#x2F; pow(level, i + j * num)) % level) * (255 &#x2F; (level - 1)));      rect(w * i, w * j, w, w);    &#125;  &#125;  &#x2F;&#x2F; frame++;  &#x2F;&#x2F; 匀速播放  frame &#x3D; int(pow(frameCount, 2)); &#x2F;&#x2F; 加速播放&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="只有13个字符的Linux-Fork炸弹"><a href="#只有13个字符的Linux-Fork炸弹" class="headerlink" title="只有13个字符的Linux Fork炸弹"></a>只有13个字符的Linux Fork炸弹</h1><p>早在2002年，Jaromil设计了最为精简的一个Linux Fork炸弹，整个代码只有13个字符，在 shell 中运行后几秒后系统就会宕机：</p><pre class="line-numbers language-none"><code class="language-none">:()&#123;:|:&amp;&#125;;:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样看起来不是很好理解，我们可以更改下格式：</p><pre class="line-numbers language-none"><code class="language-none">:()&#123;:|:&amp;&#125;;:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更好理解一点的话就是这样:</p><pre class="line-numbers language-none"><code class="language-none">bomb()&#123;bomb|bomb&amp;&#125;;bomb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为shell中函数可以省略<code>function</code>关键字，所以上面的十三个字符是功能是定义一个函数与调用这个函数，函数的名称为<code>:</code>，主要的核心代码是<code>:|:&amp;</code>，可以看出这是一个函数本身的递归调用，通过&amp;实现在后台开启新进程运行，通过管道实现进程呈几何形式增长，最后再通过:来调用函数引爆炸弹。因此，几秒钟系统就会因为处理不过来太多的进程而死机，解决的唯一办法就是重启。<br>当然有“不怕死”的小伙伴用了云主机试了一试：<br>结果，运行一段时间后直接报出了<code>-bash: fork: Cannot allocate memory</code>，说明内存不足了。<br>并且在二号终端上尝试连接也没有任何反应。因为是虚拟的云主机，所以我只能通过主机服务商的后台来给主机断电重启。然后才能重新登录：</p><p>当然，<code>Fork</code>炸弹用其它语言也可以分分钟写出来一个，例如，<code>python</code>版：</p><pre class="line-numbers language-none"><code class="language-none">import oswhile True:   os.fork()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Fork炸弹的本质无非就是靠创建进程来抢占系统资源，在Linux中，我们可以通过ulimit命令来限制用户的某些行为，运行ulimit -a可以查看我们能做哪些限制：</p><pre class="line-numbers language-none"><code class="language-none">ubuntu@10-10-57-151:~$ ulimit -a    core file size      (blocks, -c) 0 data seg size     (kbytes, -d) unlimited scheduling priority     (-e) 0file size      (blocks, -f) unlimited pending signals     (-i) 7782 max locked memory     (kbytes, -l) 64 max memory size      (kbytes, -m) unlimited open files       (-n) 1024 pipe size     (512 bytes, -p) 8 POSIX message queues      (bytes, -q) 819200 real-time priority      (-r) 0 stack size      (kbytes, -s) 8192 cpu time    (seconds, -t) unlimited max user processes      (-u) 7782 virtual memory     (kbytes, -v) unlimited file locks       (-x) unlimited<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>-u</code>参数可以限制用户创建进程数，因此，我们可以使用<code>ulimit -u 20</code>来允许用户最多创建20个进程。这样就可以预防bomb炸弹。但这样是不彻底的，关闭终端后这个命令就失效了。我们可以通过修改<code>/etc/security/limits.conf</code>文件来进行更深层次的预防，在文件里添加如下一行（ubuntu需更换为你的用户名）：<br><code>ubuntu - nproc 20</code></p><p>这样，退出后重新登录，就会发现最大进程数已经更改为<code>20</code>了，这个时候我们再次运行炸弹就不会报内存不足了，而是提示<code>-bash: fork: retry: No child processes</code>，说明<code>Linux</code>限制了炸弹创建进程。</p><hr><h1 id="东尼•霍尔的快速排序算法"><a href="#东尼•霍尔的快速排序算法" class="headerlink" title="东尼•霍尔的快速排序算法"></a>东尼•霍尔的快速排序算法</h1><p>这个算法是由图灵奖得主东尼•霍尔<code>(C. A. R. Hoare)</code>在1960年提出的，从名字中就可以看出，快速就是他的特点。<br>快速排序采用了“分治法”策略，把一个序列划分为两个子序列。在待排序列中，选择一个元素作为“基准”（Pivot）。<br>所有小于“基准”的元素，都移动到“基准”前面，所有大于“基准”的元素，都移动到“基准”后面（相同的数可以到任一边）。此为“分区”（partition）操作。<br>分别对“基准”两边的序列，不断重复一、二步，直至所有子集只剩下一个元素。</p><p>假设现有一数列：</p><blockquote><p>对此数列进行快速排序。选择第一个元素 45 作为第一趟排序的“基准”（基准值可以任意选择）。<br>第一趟：将元素 45 拿出来，分别从数列的两端开始探测<br>首先从右向左开始，找到第一个小于 45 的元素为 25，然后将 25 放置到第一个元素 45 的位置上。此时数列变为：<br>然后从左向右开始，找到第一个大于 45 的元素为 66 ，然后将 66 放置到原先元素 25的位置上。此时数列变为：<br>继续从右向左开始，找到第二个小于 45 的元素为 10 ，然后将 10 放置到原先元素 66的位置上，此时数列变为：<br>继续从左向右开始，找到第二个大于 45 的元素为 90 ，然后将 90 放置到原先元素 10的位置上，此时数列变为：<br>继续从右向左开始，此时发现左右碰面，因此将“基准”45 放置到原先元素 90 的位置上，此时数列变为：<br>至此，第一轮结束，“基准”45 左侧为小数区，右侧为大数区。同样的分别对小数区和大数区应用此方法直至完成排序。</p></blockquote><p>分析完成后通过C++的源代码如下：</p><hr><h1 id="快速排序核心算法："><a href="#快速排序核心算法：" class="headerlink" title="快速排序核心算法："></a>快速排序核心算法：</h1><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 每一轮的快速排序int QuickPartition(int a[], int low, int high)&#123;  int temp &#x3D; a[low]; &#x2F;&#x2F; 选择数组a的第一个元素作为“基准”  while (low &lt; high) &#123;    while (low &lt; high &amp;&amp; a[high] &gt;&#x3D; temp) &#123; &#x2F;&#x2F; 从右向左查找第一个小于“基准”的数      high--;    &#125;    if (low &lt; high) &#123;      a[low] &#x3D; a[high]; &#x2F;&#x2F; 将第一个找到的大于“基准”的数移动到low处      low++;    &#125;    while (low &lt; high &amp;&amp; a[low] &lt;&#x3D; temp) &#123; &#x2F;&#x2F; 从左向右查找第一个大于“基准”的数      low++;    &#125;    if (low &lt; high) &#123;      a[high] &#x3D; a[low]; &#x2F;&#x2F; 将第一个找到的小于“基准”的数移动到high处      high--;    &#125;    a[low] &#x3D; temp; &#x2F;&#x2F; 将“基准”填到最终位置  &#125;  return low; &#x2F;&#x2F; 返回“基准”的位置，用于下一轮排序。&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="递归调用QuickSort（分治法）："><a href="#递归调用QuickSort（分治法）：" class="headerlink" title="递归调用QuickSort（分治法）："></a>递归调用QuickSort（分治法）：</h1><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 快速排序-递归算法void QuickSort(int a[], int low, int high)&#123;  if (low &lt; high) &#123;    int temp &#x3D; QuickPartition(a, low, high); &#x2F;&#x2F; 找出每一趟排序选择的“基准”位置    QuickSort(a, low, temp - 1);       &#x2F;&#x2F; 递归调用QuickSort，对“基准”左侧数列排序    QuickSort(a, temp + 1, high);      &#x2F;&#x2F; 对“基准”右侧数列排序  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数调用：</p><pre class="line-numbers language-none"><code class="language-none">void main()&#123;  int a[8] &#x3D; &#123;45, 38, 66, 90, 88, 10, 25, 45&#125;; &#x2F;&#x2F; 初始化数组a  QuickSort(a, 0, 7);  cout &lt;&lt; endl &lt;&lt; &quot;排序后：&quot;;  for (int i &#x3D; 0; i &lt;&#x3D; 7; i++) &#123;    cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;  &#125;  getchar();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排序后结果：</p><hr><h1 id="毫无炫技又惊为天人的二分图的最大匹配、完美匹配和匈牙利算法"><a href="#毫无炫技又惊为天人的二分图的最大匹配、完美匹配和匈牙利算法" class="headerlink" title="毫无炫技又惊为天人的二分图的最大匹配、完美匹配和匈牙利算法"></a>毫无炫技又惊为天人的二分图的最大匹配、完美匹配和匈牙利算法</h1><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><blockquote><p>简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集U和V，使得每一条边都分别连接U、V中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。</p></blockquote><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><blockquote><p>在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。</p></blockquote><p>我们定义匹配点、匹配边、未匹配点、非匹配边，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。</p><h2 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h2><blockquote><p>一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p></blockquote><h2 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h2><blockquote><p>如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p></blockquote><p>举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是完美匹配问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是最大匹配问题。<br>基本概念讲完了。求解最大匹配问题的一个算法是匈牙利算法，下面讲的概念都为这个算法服务。</p><p><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。<br><strong>增广路</strong>：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：<br>增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。<br>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。<br>匈牙利树一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树：</p><p>这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。<br>下面给出匈牙利算法的 DFS 和 BFS 版本的代码：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 顶点、边的编号均从 0 开始&#x2F;&#x2F; 邻接表储存struct Edge&#123;    int from;    int to;    int weight;    Edge(int f, int t, int w) : from(f), to(t), weight(w) &#123;&#125;&#125;;vector&lt;int&gt; G[__maxNodes]; &#x2F;* G[i] 存储顶点 i 出发的边的编号 *&#x2F;vector&lt;Edge&gt; edges;typedef vector&lt;int&gt;::iterator iterator_t;int num_nodes;int num_left;int num_right;int num_edges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">int matching[__maxNodes]; &#x2F;* 存储求解结果 *&#x2F;int check[__maxNodes];bool dfs(int u)&#123;  for (iterator_t i &#x3D; G[u].begin(); i !&#x3D; G[u].end(); ++i) &#123; &#x2F;&#x2F; 对 u 的每个邻接点    int v &#x3D; edges[*i].to;    if (!check[v]) &#123;   &#x2F;&#x2F; 要求不在交替路中      check[v] &#x3D; true; &#x2F;&#x2F; 放入交替路      if (matching[v] &#x3D;&#x3D; -1 || dfs(matching[v])) &#123; &#x2F;&#x2F; 如果是未盖点，说明交替路为增广路，则交换路径，并返回成功        matching[v] &#x3D; u;        matching[u] &#x3D; v;        return true;      &#125;    &#125;  &#125;  return false; &#x2F;&#x2F; 不存在增广路，返回失败&#125;int hungarian()&#123;  int ans &#x3D; 0;  memset(matching, -1, sizeof(matching));  for (int u &#x3D; 0; u &lt; num_left; ++u) &#123;    if (matching[u] &#x3D;&#x3D; -1) &#123;      memset(check, 0, sizeof(check));      if (dfs(u))        ++ans;    &#125;  &#125;  return ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">queue&lt;int&gt; Q;int prev[__maxNodes];int Hungarian()&#123;  int ans &#x3D; 0;  memset(matching, -1, sizeof(matching));  memset(check, -1, sizeof(check));  for (int i &#x3D; 0; i &lt; num_left; ++i) &#123;    if (matching[i] &#x3D;&#x3D; -1) &#123;      while (!Q.empty()) Q.pop();      Q.push(i);      prev[i] &#x3D; -1;      &#x2F;&#x2F; 设 i 为路径起点      bool flag &#x3D; false; &#x2F;&#x2F; 尚未找到增广路      while (!Q.empty() &amp;&amp; !flag) &#123;        int u &#x3D; Q.front();        for (iterator_t ix &#x3D; G[u].begin(); ix !&#x3D; G[u].end() &amp;&amp; !flag; ++ix) &#123;          int v &#x3D; edges[*ix].to;          if (check[v] !&#x3D; i) &#123;            check[v] &#x3D; i;            Q.push(matching[v]);            if (matching[v] &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 此点为匹配点              prev[matching[v]] &#x3D; u;            &#125; else &#123;                &#x2F;&#x2F; 找到未匹配点，交替路变为增广路              flag &#x3D; true;              int d &#x3D; u, e &#x3D; v;              while (d !&#x3D; -1) &#123;                int t &#x3D; matching[d];                matching[d] &#x3D; e;                matching[e] &#x3D; d;                d &#x3D; prev[d];                e &#x3D; t;              &#125;            &#125;          &#125;        &#125;        Q.pop();      &#125;      if (matching[i] !&#x3D; -1) ++ans;    &#125;  &#125;  return ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><blockquote><ul><li><p>从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。</p><ul><li>如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。</li><li>如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li></ul></li><li><p>由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 prev 数组。</p></li></ul></blockquote><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><blockquote><p>两个版本的时间复杂度均为O（V•E）。<br>DFS 的优点是思路清晰、代码量少，但是性能不如 BFS。我测试了两种算法的性能。对于稀疏图，BFS 版本明显快于 DFS 版本；而对于稠密图两者则不相上下。<br>在完全随机数据 9000 个顶点 4,0000 条边时前者领先后者大约 97.6%，9000 个顶点 100,0000 条边时前者领先后者 8.6%, 而达到 500,0000 条边时 BFS 仅领先 0.85%。</p></blockquote><h3 id="补充定义和定理："><a href="#补充定义和定理：" class="headerlink" title="补充定义和定理："></a>补充定义和定理：</h3><blockquote><p>最大匹配数：最大匹配的匹配边的数目<br>最小点覆盖数：选取最少的点，使任意一条边至少有一个端点被选择<br>最大独立数：选取最多的点，使任意所选两点均不相连<br>最小路径覆盖数：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。<br><strong>定理1</strong>：最大匹配数 = 最小点覆盖数（这是 Konig 定理）<br><strong>定理2</strong>：最大匹配数 = 最大独立数定理3：最小路径覆盖数 = 顶点数 - 最大匹配数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 奇淫巧技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows BAT脚本（批处理）——for循环，if判断，goto跳转，遍历文件名，start打开网页</title>
      <link href="/20230601/learn_base/Windows%20BAT%E8%84%9A%E6%9C%AC.html"/>
      <url>/20230601/learn_base/Windows%20BAT%E8%84%9A%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[<h1 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h1><blockquote><p>在cmd窗口中：<code>for %I in (command1) do command2</code><br>在批处理文件中：<code>for %%I in (command1) do command2</code><br>for语句的基本要素：</p><ol><li>for、in和do是for语句的关键字；</li><li>%%I是for语句中对形式变量的引用；</li><li>in之后，do之前的括号不能省略；</li><li>command1表示字符串或变量，command2表示字符串、变量或命令语句；<pre class="line-numbers language-none"><code class="language-none">@echo offfor %%i in(1, B, 3) do ehco %%ipause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/images/learn/cmd/1568466-20200317101344774-120755532.png"></li></ol></blockquote><h1 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h1><p>计算机只在乎0和1是吧？所以我们需要一种方法，来处理当条件是0的时候干什么，条件为1的时候又干什么。<br>好消息是 DOS 对条件语句支持的非常好。</p><h2 id="检查文件或文件夹是否存在"><a href="#检查文件或文件夹是否存在" class="headerlink" title="检查文件或文件夹是否存在"></a>检查文件或文件夹是否存在</h2><blockquote><pre class="line-numbers language-auto" data-language="auto"><code class="language-auto">IF EXIST &quot;temp.txt&quot; ECHO found<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>取反:</p><pre class="line-numbers language-auto" data-language="auto"><code class="language-auto">IF NOT EXIST &quot;temp.txt&quot; ECHO not found<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>If 和 Else 语句：</p><pre class="line-numbers language-auto" data-language="auto"><code class="language-auto">IF EXIST &quot;temp.txt&quot; (    ECHO found) ELSE (    ECHO not found)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NOTE: 在判断的表达式两边加上双引号，这样可以避免一些bug，比如变量不存在，导致语法错误。</p></blockquote><h2 id="检查变量是否初始化"><a href="#检查变量是否初始化" class="headerlink" title="检查变量是否初始化"></a>检查变量是否初始化</h2><blockquote><pre class="line-numbers language-auto" data-language="auto"><code class="language-auto">IF &quot;%var%&quot;&#x3D;&#x3D;&quot;&quot; (SET var&#x3D;default value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-auto" data-language="auto"><code class="language-auto">IF NOT DEFINED var (SET var&#x3D;default value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h2 id="检查变量是否与字符串匹配"><a href="#检查变量是否与字符串匹配" class="headerlink" title="检查变量是否与字符串匹配"></a>检查变量是否与字符串匹配</h2><blockquote><pre class="line-numbers language-auto" data-language="auto"><code class="language-auto">SET var&#x3D;Hello, World!IF &quot;%var%&quot;&#x3D;&#x3D;&quot;Hello, World!&quot; (    ECHO found)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者不区分大小写来比较：</p><pre class="line-numbers language-auto" data-language="auto"><code class="language-auto">SET var&#x3D;Hello, World!IF &#x2F;I &quot;%var%&quot;&#x3D;&#x3D;&quot;hello, world!&quot; (    ECHO found)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="算数运算符比较"><a href="#算数运算符比较" class="headerlink" title="算数运算符比较"></a>算数运算符比较</h2><blockquote><pre class="line-numbers language-auto" data-language="auto"><code class="language-auto">SET &#x2F;A var&#x3D;1IF &#x2F;I &quot;%var%&quot; EQU &quot;1&quot; ECHO equality with 1IF &#x2F;I &quot;%var%&quot; NEQ &quot;0&quot; ECHO inequality with 0IF &#x2F;I &quot;%var%&quot; GEQ &quot;1&quot; ECHO greater than or equal to 1IF &#x2F;I &quot;%var%&quot; LEQ &quot;1&quot; ECHO less than or equal to 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="检查返回值"><a href="#检查返回值" class="headerlink" title="检查返回值"></a>检查返回值</h2><blockquote><pre class="line-numbers language-auto" data-language="auto"><code class="language-auto">IF &#x2F;I &quot;%ERRORLEVEL%&quot; NEQ &quot;0&quot; (    ECHO execution failed)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote><p><code>@echo off</code>是不显示本命令行及后面的所有命令行本身；echo是输出命令；<br><code>set aa=xia3</code>，是给变量aa赋值为xia3，%aa%是使用此变量；</p><pre class="line-numbers language-none"><code class="language-none">@echo offset aa&#x3D;xia3echo %aa%echo bbpause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/cmd/1568466-20200317103906826-1057248177.png"></p></blockquote><blockquote><p>if 语句来判断是否已经赋值；<br><code>if defined str (echo %str%) else  (echo 变量str的值为空)</code>；<br>注意：括号为英文状态下的()，否则执行不成功；</p><pre class="line-numbers language-none"><code class="language-none">@echo offset aa&#x3D;xia3if defined aa (echo %aa%) else (echo NULL)pause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/cmd/1568466-20200317110811212-232387164.png"> </p></blockquote><h1 id="rem语句"><a href="#rem语句" class="headerlink" title="rem语句"></a>rem语句</h1><blockquote><p>REM语句是注释此行，相当于此行不执行；</p><pre class="line-numbers language-none"><code class="language-none">@echo offREM set aa&#x3D;xia3if defined aa (echo %aa%) else (echo NULL)pause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/cmd/1568466-20200317110645684-399108014.png"> </p></blockquote><h1 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h1><blockquote><p>goto label跳转到要执行的标签，标签由冒号与标签名组成；<br>多个标签之间要加上exit终止程序继续向下运行；<br>同名的标签，程序执行最上面的一个；<br>标签名必须是常量，不能是变量；</p><pre class="line-numbers language-none"><code class="language-none">@echo offset &#x2F;p input&#x3D;请输入字母A或Bif &quot;%input%&quot;&#x3D;&#x3D;&quot;A&quot; goto Arem 如果input值是A，会跳转到A的标签去运行，运行时将跳过gotoA与:A间的内容if &quot;%input%&quot;&#x3D;&#x3D;B”goto Bif not “%input%&quot;&#x3D;&#x3D;&quot;A”(if not %input%&#x3D;&#x3D;&quot;B&quot; goto C)rem 如果输入的值不是A就进行下个判断，下一个判断，如果输入不是B就跳转到C语句;:Aecho您输入的是Apauseexit:Becho 是Bpauseexit:Cecho不是A或者Bpauseexit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/cmd/1568466-20200317114905972-352348399.png"> </p></blockquote><h1 id="脚本应用"><a href="#脚本应用" class="headerlink" title="脚本应用"></a>脚本应用</h1><h2 id="文件遍历，输出文件名；"><a href="#文件遍历，输出文件名；" class="headerlink" title="文件遍历，输出文件名；"></a>文件遍历，输出文件名；</h2><blockquote><p>用for循环遍历文件，用echo打印出文件名；<br>for /R %%s in (.,*) do (echo %%s)</p><pre class="line-numbers language-none"><code class="language-none">@echo offset path&#x3D;D:\screm set给path赋值D:rem 进入D盘目录，否则在当前test.bat目录下执行遍历;cd %path%rem 切换到相应路径下;for &#x2F;R %%i in(.,*) do(echo %%i)rem 用for循环遍历文件pause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/cmd/1568466-20200317144420398-1413548109.png"><br>dos中 【dir /?】，查看dir命令下的参数；dir /s显示指定目录和所有子目录的文件；【D:】切换目录到D盘下；<br><img src="/images/learn/cmd/1568466-20200317144209413-749959907.png"> </p></blockquote><h2 id="start用法；"><a href="#start用法；" class="headerlink" title="start用法；"></a>start用法；</h2><blockquote><p>start命令可以用来启动电脑上的软件；</p><pre class="line-numbers language-none"><code class="language-none">@echo offREM 就是启动IE浏览器，跳转到百度页面，并自动搜索‘苹果’；start http:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;苹果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/cmd/1568466-20200317150619842-260631561.png"></p></blockquote><h2 id="自己设定搜索内容；"><a href="#自己设定搜索内容；" class="headerlink" title="自己设定搜索内容；"></a>自己设定搜索内容；</h2><blockquote> <pre class="line-numbers language-none"><code class="language-none"> @echo offset &#x2F;p key&#x3D;你写啥就搜啥start http:&#x2F;wwwbaiducom&#x2F;s?wd&#x3D;%key%pause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/cmd/1568466-20200317151055119-572686174.png"> </p></blockquote><h2 id="bat脚本搜索后，延迟10s，使用taskkill关掉我们打开的网站；"><a href="#bat脚本搜索后，延迟10s，使用taskkill关掉我们打开的网站；" class="headerlink" title="bat脚本搜索后，延迟10s，使用taskkill关掉我们打开的网站；"></a>bat脚本搜索后，延迟10s，使用taskkill关掉我们打开的网站；</h2><blockquote> <pre class="line-numbers language-none"><code class="language-none"> @echo offset &#x2F;p key&#x3D;你写啥就搜啥start http:&#x2F;wwwbaiducom&#x2F;s?wd&#x3D;%key%ping -n 10 127.0.0.1 &gt; nulrem 让脚本延迟10秒，不然后面的关掉任务可能会执行失败taskkill &#x2F;fi &quot;windowTitle eq %key%*”&#x2F;frem 只要标题前面是&quot;key&quot;的窗口都关闭pause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/cmd/1568466-20200317152329930-1357066038.png"> </p></blockquote><h1 id="启动指定应用"><a href="#启动指定应用" class="headerlink" title="启动指定应用"></a>启动指定应用</h1><pre class="line-numbers language-none"><code class="language-none">@echo offif %1&#x3D;&#x3D;&quot;hexo&quot; goto HEXO:HEXOREM 启动HEXO博客系统 cd E:\WorkBloge:hexo server -p 80exit <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 脚本 </tag>
            
            <tag> SHELL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex 布局教程：语法篇</title>
      <link href="/20230601/learn_bs/CSS%E5%AD%A6%E4%B9%A0-Flex%20%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(%E8%AF%AD%E6%B3%95%E7%AF%87).html"/>
      <url>/20230601/learn_bs/CSS%E5%AD%A6%E4%B9%A0-Flex%20%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(%E8%AF%AD%E6%B3%95%E7%AF%87).html</url>
      
        <content type="html"><![CDATA[<p>网页布局（layout）是 CSS 的一个重点应用。<br><img src="/images/learn/flex/flex_image_item_001.png"></p><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。<br><img src="/images/learn/flex/flex_image_item_003.gif"></p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。<br><img src="/images/learn/flex/flex_image_item_004.jpg"></p><p>Flex 布局将成为未来布局的首选方案。本文介绍它的语法，下一篇文章给出常见布局的 Flex 写法。网友 JailBreak 为本文的所有示例制作了 Demo，也可以参考。<br>以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。</p><h1 id="Flex-布局是什么？"><a href="#Flex-布局是什么？" class="headerlink" title="Flex 布局是什么？"></a>Flex 布局是什么？</h1><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。</p><pre class="line-numbers language-none"><code class="language-none">.box&#123;  display: flex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>行内元素也可以使用 Flex 布局。</p><pre class="line-numbers language-none"><code class="language-none">.box&#123;  display: inline-flex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Webkit 内核的浏览器，必须加上-webkit前缀。</p><pre class="line-numbers language-none"><code class="language-none">.box&#123;  display: -webkit-flex; &#x2F;* Safari *&#x2F;  display: flex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src="/images/learn/flex/flex_image_item_006.gif"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p>以下6个属性设置在容器上。</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h2 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h2><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p><pre class="line-numbers language-none"><code class="language-none">.box &#123;  flex-direction: row | row-reverse | column | column-reverse;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/flex/flex_image_item_007.png"><br><img src="/images/learn/flex/flex_image_item_008.gif"></p><p>它可能有4个值。</p><ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><h2 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h2><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><pre class="line-numbers language-none"><code class="language-none">.box&#123;  flex-wrap: nowrap | wrap | wrap-reverse;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/flex/flex_image_item_009.png"></p><p>它可能取三个值。</p><blockquote><ul><li>nowrap（默认）：不换行。<br><img src="/images/learn/flex/flex_image_item_011.gif"></li><li>wrap：换行，第一行在上方。<br><img src="/images/learn/flex/flex_image_item_012.jpg"></li><li>wrap-reverse：换行，第一行在下方。<br><img src="/images/learn/flex/flex_image_item_013.jpg"></li></ul></blockquote><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><pre class="line-numbers language-none"><code class="language-none">.box &#123;  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h2><p>justify-content属性定义了项目在主轴上的对齐方式。</p><pre class="line-numbers language-none"><code class="language-none">.box &#123;  justify-content: flex-start | flex-end | center | space-between | space-around;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/flex/flex_image_item_014.png"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h2 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h2><p>align-items属性定义项目在交叉轴上如何对齐。</p><pre class="line-numbers language-none"><code class="language-none">.box &#123;  align-items: flex-start | flex-end | center | baseline | stretch;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/flex/flex_image_item_016.png"></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h2 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h2><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><pre class="line-numbers language-none"><code class="language-none">.box &#123;  align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/flex/flex_image_item_018.png"></p><p>该属性可能取6个值。</p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><p>以下6个属性设置在项目上。</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h2 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h2><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><pre class="line-numbers language-none"><code class="language-none">.item &#123;  order: &lt;integer&gt;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/flex/flex_image_item_020.png"></p><h2 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h2><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><pre class="line-numbers language-none"><code class="language-none">.item &#123;  flex-grow: &lt;number&gt;; &#x2F;* default 0 *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/flex/flex_image_item_022.png"></p><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h2 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h2><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><pre class="line-numbers language-none"><code class="language-none">.item &#123;  flex-shrink: &lt;number&gt;; &#x2F;* default 1 *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/flex/flex_image_item_024.jpg"></p><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p><h2 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h2><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><pre class="line-numbers language-none"><code class="language-none">.item &#123;  flex-basis: &lt;length&gt; | auto; &#x2F;* default auto *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h2 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h2><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><pre class="line-numbers language-none"><code class="language-none">.item &#123;  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h2 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h2><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre class="line-numbers language-none"><code class="language-none">.item &#123;  align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/flex/flex_image_item_025.png"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。<br>（完）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式表</title>
      <link href="/20230601/learn_bs/CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8.html"/>
      <url>/20230601/learn_bs/CSS%E6%A0%B7%E5%BC%8F%E8%A1%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-font-family-好看常用的中文字体"><a href="#CSS-font-family-好看常用的中文字体" class="headerlink" title="CSS,font-family,好看常用的中文字体"></a>CSS,font-family,好看常用的中文字体</h1><blockquote><p>例1（小米米官网）：</p><pre class="line-numbers language-none"><code class="language-none">font-family: &quot;Arial&quot;,&quot;Microsoft YaHei&quot;,&quot;黑体&quot;,&quot;宋体&quot;,sans-serif;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例2（淘宝技术研发中心）：</p><pre class="line-numbers language-none"><code class="language-none">font: 12px&#x2F;1.5 Tahoma,Helvetica,Arial,&#39;宋体&#39;,sans-serif;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例3（加网 ）：</p><pre class="line-numbers language-none"><code class="language-none">font: 14px&#x2F;1.5 &#39;Microsoft YaHei&#39;,arial,tahoma,\5b8b\4f53,sans-serif;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例4（淘宝UED）：</p><pre class="line-numbers language-none"><code class="language-none">font: 12px&#x2F;1 Tahoma,Helvetica,Arial,&quot;\5b8b\4f53&quot;,sans-serif;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例5（一淘UX）:</p><pre class="line-numbers language-none"><code class="language-none">font-family: Helvetica, &#39;Hiragino Sans GB&#39;, &#39;Microsoft Yahei&#39;, &#39;微软雅黑&#39;, Arial, sans-serif;font: 12px&#x2F;1 Tahoma,Helvetica,Arial,&quot;\5b8b\4f53&quot;,sans-serif;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h1 id="CSS设置字体种类"><a href="#CSS设置字体种类" class="headerlink" title="CSS设置字体种类"></a>CSS设置字体种类</h1><blockquote><p>转载自：<a href="https://blog.csdn.net/Kellogg_and_Nina/article/details/78349654">CSS设置字体种类，如宋体，楷体，黑体，仿宋等等</a><br>如：宋体,div里面设置字体样式</p><div style="font-family:Simsun"></blockquote><h2 id="全局设置字体样式"><a href="#全局设置字体样式" class="headerlink" title="全局设置字体样式"></a>全局设置字体样式</h2><blockquote><body style="font-family:Simsun"></blockquote><h2 id="字体样式的CSS表示大全"><a href="#字体样式的CSS表示大全" class="headerlink" title="字体样式的CSS表示大全"></a>字体样式的CSS表示大全</h2>  <pre class="line-numbers language-none"><code class="language-none">华文细黑：STHeiti Light [STXihei] 华文黑体：STHeiti 华文楷体：STKaiti 华文宋体：STSong 华文仿宋：STFangsong 儷黑 Pro：LiHei Pro Medium 儷宋 Pro：LiSong Pro Light 標楷體：BiauKai 蘋果儷中黑：Apple LiGothic Medium 蘋果儷細宋：Apple LiSung Light <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  宋体：SimSuncss中中文字体（font-family）的英文名称</p><h2 id="Mac-OS的一些："><a href="#Mac-OS的一些：" class="headerlink" title="Mac OS的一些："></a>Mac OS的一些：</h2>  <pre class="line-numbers language-none"><code class="language-none">华文细黑：STHeiti Light [STXihei]华文黑体：STHeiti华文楷体：STKaiti华文宋体：STSong华文仿宋：STFangsong儷黑 Pro：LiHei Pro Medium儷宋 Pro：LiSong Pro Light標楷體：BiauKai蘋果儷中黑：Apple LiGothic Medium蘋果儷細宋：Apple LiSung Light<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Windows的一些："><a href="#Windows的一些：" class="headerlink" title="Windows的一些："></a>Windows的一些：</h2>  <pre class="line-numbers language-none"><code class="language-none">新細明體：PMingLiU細明體：MingLiU標楷體：DFKai-SB黑体：SimHei新宋体：NSimSun仿宋：FangSong楷体：KaiTi仿宋_GB2312：FangSong_GB2312楷体_GB2312：KaiTi_GB2312微軟正黑體：Microsoft JhengHei微软雅黑体：Microsoft YaHei<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="装Office会生出来的一些："><a href="#装Office会生出来的一些：" class="headerlink" title="装Office会生出来的一些："></a>装Office会生出来的一些：</h2>  <pre class="line-numbers language-none"><code class="language-none">隶书：LiSu 幼圆：YouYuan 华文细黑：STXihei 华文楷体：STKaiti 华文宋体：STSong 华文中宋：STZhongsong 华文仿宋：STFangsong 方正舒体：FZShuTi 方正姚体：FZYaoti 华文彩云：STCaiyun 华文琥珀：STHupo 华文隶书：STLiti 华文行楷：STXingkai 华文新魏：STXinwei<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Windows-中的中文字体。"><a href="#Windows-中的中文字体。" class="headerlink" title="Windows 中的中文字体。"></a>Windows 中的中文字体。</h1><blockquote><p>在默认情况下，也就是未自行安装新字体或者 Office 等文字处理软件的情况下，Windows 默认提供下列字体：<br>Windows 95/98/98SE 宋体、黑体、楷体_GB2312、仿宋_GB2312<br>Windows XP/2000/2003/ME/NT 宋体/新宋体、黑体、楷体_GB2312、仿宋_GB2312 (Windows XP SP3 宋体-PUA)<br>Windows Vista/7/2008 宋体/新宋体、黑体、楷体、仿宋、微软雅黑、SimSun-ExtB</p></blockquote><h1 id="那么每种字体能显示那些汉字呢？"><a href="#那么每种字体能显示那些汉字呢？" class="headerlink" title="那么每种字体能显示那些汉字呢？"></a>那么每种字体能显示那些汉字呢？</h1><blockquote><p>Vista 之前的 Windows 中宋体/新宋体、黑体支持 GBK 1.0 字符集，<br>楷体_GB2312、仿宋_GB2312 支持 GB2312-80 字符集。<br>（注：Windows 3.X 只能支持 GB2312-80 字符集）<br>Vista 及之后的 Windows 中宋体/新宋体、黑体、楷体、仿宋、微软雅黑支持 GB18030-2000 字符集，<br>SimSun-ExtB 只支持 GB18030-2005 字符集扩展 B 部分。</p></blockquote><h1 id="下面对字符集进行简单的介绍："><a href="#下面对字符集进行简单的介绍：" class="headerlink" title="下面对字符集进行简单的介绍："></a>下面对字符集进行简单的介绍：</h1><blockquote><p>GB2312-80 &lt; GBK 1.0 &lt; GB18030-2000 &lt; GB18030-2005<br>GB2312-80 中的字符数量最少，GB18030-2005 字符数量最多。<br>GB2312-80 是最早的版本，字符数比较少；<br>GBK 1.0 中的汉字大致与 Unicode 1.1 中的汉字数量相同；<br>GB18030-2000 中的汉字大致与 Unicode 3.0 中的汉字数量相同，主要增加了扩展 A 部分；<br>GB18030-2005 中的汉字大致与 Unicode 4.1 中的汉字数量相同，主要增加了扩展 B 部分；<br>由于 Unicode 5.2 的发布，估计 GB18030 会在近期发布新版本，增加扩展 C 部分。<br>需要说明的是在 GB18030 中扩展 B 部分并不是强制标准。<br>如果想查看 GB18030 的标准文本，请访问 <a href="http://www.gb168.cn/">http://www.gb168.cn</a> 中的强标阅读。<br>如果想了解 Unicode 的内容，请访问 <a href="http://www.unicode.org./">http://www.unicode.org。</a></p></blockquote><h1 id="现在纠正网上普遍的一个错误："><a href="#现在纠正网上普遍的一个错误：" class="headerlink" title="现在纠正网上普遍的一个错误："></a>现在纠正网上普遍的一个错误：</h1><blockquote><p>GB18030-2000 和 GB18030-2005 都不支持单字节的欧元符号</p></blockquote><h1 id="与简体中文有关的代吗页如下："><a href="#与简体中文有关的代吗页如下：" class="headerlink" title="与简体中文有关的代吗页如下："></a>与简体中文有关的代吗页如下：</h1><blockquote><p>936 gb2312 简体中文(GB2312)————其实是GBK<br>10008 x-mac-chinesesimp 简体中文(Mac)<br>20936 x-cp20936 简体中文(GB2312-80)<br>50227 x-cp50227 简体中文(ISO-2022)<br>51936 EUC-CN 简体中文(EUC)<br>52936 hz-gb-2312 简体中文(HZ)<br>54936 GB18030 简体中文(GB18030)</p></blockquote><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><blockquote><p>使用楷体_GB2312、仿宋_GB2312后，在 Windows 7/Vista/2008 中可能不再显示为对应的字体。<br>这是因为 Windows 7/Vista/2008 中有楷体、仿宋，默认情况下没有楷体_GB2312、仿宋_GB2312，字体名称相差“_GB2312”。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM语法 Part 7[栈和函数]</title>
      <link href="/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(7)-%E6%A0%88%E5%92%8C%E5%87%BD%E6%95%B0.html"/>
      <url>/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(7)-%E6%A0%88%E5%92%8C%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Part-7：栈和函数"><a href="#Part-7：栈和函数" class="headerlink" title="Part 7：栈和函数"></a><strong>Part 7：栈和函数</strong></h2><p>在这一部分我们来看一下进程中叫做<strong>栈</strong>的内存区域。本章涵盖了栈的用途和相关操作。此外我们将介绍 ARM 中函数的实现、类型和差异。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h3><p>一般而言，栈就是进程中的一段内存。这段内存是在进程创建时分配的。我们使用栈来保存一些临时数据，如函数中的局部变量，函数之间转换的环境变量等。使用PUSH和POP指令与栈进行交互。在Part 4：内存指令：<strong>加载与存储</strong>中我们讲到PUSH和POP是一些其他内存操作指令的别名，这里为简单起见我们使用PUSH和POP指令。</p><p>在看实例之前，我们先要明白栈有多种实现方式。首先，当我们说栈增长了，意思是一个数据（32位）被放入了栈中。栈可以向上增长（当栈是按照降序方式实现）或者向下增长（当栈是按照升序方式实现）。下一条信息将被放置的实际位置是由栈指针定义的。准确的说是保存在寄存器SP中的地址指定的。地址可以是栈中的当前（最后入栈）项或者下一个可用的内存位置。如果SP指向的是栈中的最后一个项（完整栈实现方式），那么是先增加（向上增加栈）或减小（向下增长栈）SP再放入数据；如果SP指向的是栈内下一个有效的空位置，那么是数据先入栈后再增加SP（向上增加栈）或减少SP（向下增长栈）。</p><p><img src="/images/learn/arm-asm/v2-b4558526a7f719a2d3e48520d5f52d96_b.gif"></p><p>总结了栈的不同实现，我们可以用以下表格列出了不同情况下使用不同的多数据存储或多数据加载指令。</p><p><img src="/images/learn/arm-asm/v2-a0bb45eea8a7de0040fe896d4b9c583c_b.jpg"></p><p>我们的例子中使用了完整降序栈（Full descending）。下面是一个简单例子，看一下这种栈是如何处理栈指针的。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">/* azeria@labs:~$ as stack.s -o stack.o &amp;&amp; gcc stack.o -o stack &amp;&amp; gdb stack */.global main​main:     mov   r0, #2  /* 设置R0的初始值*/     push  &#123;r0&#125;    /* 将R0的值保存到栈*/     mov   r0, #3  /* 覆盖R0的值 */     pop   &#123;r0&#125;    /* 恢复R0的初始值 */     bx    lr      /* 结束程序 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在一开始，栈指针指向地址0xbefff6f8 （你的环境中可能不同）代表栈中的最后一项值。这时我们看一下这个地址处的值（同样，你的环境中可能不同）：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> x/1x $sp0xbefff6f8: 0xb6fc7000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当执行完第一条MOV指令后，栈内数据没有变化。当执行PUSH指令时，将发生以下事情：首先SP的值减4（4 bytes = 32 bits）；然后R0中的值保存到SP指定的地址处。现在再看一下SP中指定的地址处的值：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> x/x $sp0xbefff6f4: 0x00000002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例子中的指令mov r0, #3用来模拟R0中的数据被覆盖的情形。然后使用POP再将之前的数据恢复。所以，当执行POP指令时，实际发生了以下事情：首先从当前SP指向的内存地址（0xbefff6f4）处读取一个32位的数据（前面PUSH时保存的2），然后SP寄存器的值减4（变成0xbefff6f8 ），最后将从栈中读取的数值2保存到R0。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> info registers r0r0       0x2          2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（注意，下面的gif展示的栈的低地址在上面，高地址在下面。不是前面展示不同堆栈实现时的图片的那种方式，这样是为了让栈看起来跟GDB中展示一样）：</p><p><img src="/images/learn/arm-asm/v2-ea8de3e39d28da5aca3fa1379be5a9fe_b.gif"></p><p>我们看一下函数如何利用Stack来保存本地变量、保留寄存器状态。为了让一切变得井然有序，函数使用<strong>栈帧</strong>（专门用于函数中使用的局部内存区域）。栈帧是在函数开始调用时创建的（下一节将详细介绍）。<strong>栈帧指针</strong>（FP）被置为栈帧的底部，然后分配栈帧的缓冲区。栈帧中通常（从底部）保存了返回地址（前面的LR寄存器值）、栈帧指针、其他一些需要保存的寄存器、函数参数（如果超过4个参数）、局部变量等等。虽然栈帧的实际内容可能有所不同，但基本就这些。最后栈帧在函数结束时被销毁。</p><p>下面是栈中栈帧的示意图：</p><p><img src="/images/learn/arm-asm/v2-f14834f4dae535548b5b5d247ff53cb6_b.jpg"></p><p>为了直观点，再看一段代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* azeria@labs:~$ gcc func.c -o func &amp;&amp; gdb func */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>​<span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">do_nothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span>b<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> b<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>​<span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">do_nothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面的GDB截图中我们可以看一下栈帧的样子：</p><p><img src="/images/learn/arm-asm/v2-d47421051795c4834c0a5b9423758749_b.jpg"></p><p>从上图中我们可以看到，当前我们即将离开函数max（反汇编代码底部的箭头）时，这时，<code>FP</code>（<code>R11</code>寄存器）指向栈帧最底部的<code>0xbefff254</code>。看栈中的绿色地址保存了返回地址<code>0x00010418</code>（前面的LR寄存器）。再往上4字节的地址处（<code>0xbefff250</code>）保存值<code>0xbefff26c</code>，这是前一个栈帧指针（<code>FP</code>）。地址<code>0xbefff24c</code>和<code>0xbefff248</code>处的<code>0x1</code>和<code>0x2</code>是函数max运行时的局部变量。所以刚才分析的这个栈帧只包含了<code>LR</code>，<code>FP</code>和两个局部变量。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h3><p>要理解ARM中的函数，首先要熟悉函数体的结构：开始、执行体和收尾。</p><p>开始时需要保存程序前面的状态（LR和R11分别入栈）然后为函数的局部变量设置堆栈。虽然开始部分的实现可能因编译器而异，但通常是用PUSH/ADD/SUB指令来完成的。大体看起来是下面这样：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">push   &#123;r11, lr&#125;    /* 将lr和r11入栈 */add    r11, sp, #0  /* 设置栈帧的底部位置 */sub    sp, sp, #16  /* 栈指针减去16为局部变量分配缓存区 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数体部分就是你程序的实际逻辑区，包含了你代码逻辑的各种指令：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">mov    r0<span class="token punctuation">,</span> #<span class="token number">1</span>       <span class="token comment">/* 设置局部变量(a=1). 同时也为函数max的第一个参数 */</span>mov    r1<span class="token punctuation">,</span> #<span class="token number">2</span>       <span class="token comment">/* 设置局部变量(b=2). 同时也为函数max的第二个参数 */</span>bl     max          <span class="token comment">/* 调用函数max */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的代码展示了为函数设置局部变量并跳转到另一个函数的过程。同时还展示了通过寄存器为另一个函数（max）传递参数的过程。在某些情况下，当要传递的参数超过4个时，我们需要另外使用栈来存储剩余的参数。还要说明一下，函数通过寄存器R0返回结果。所以不论max函数结果是什么，最后都要在函数结束返回后从R0中取返回值。在某些情况下，结果可能是 64 位的长度（超过 32 位寄存器的大小），这时候就需要结合R0和R1来存储返回值。</p><p>函数的最后部分用于将程序的状态还原到它初始的状态（函数调用前），这样就可以从函数被调用的地方继续执行。所以我们需要重新调整栈指针（SP）。这是通过加减帧指针寄存器（R11）来实现的。重新调整栈指针后，将之前（函数开始处）保存的寄存器值从堆栈弹出到相应的寄存器来还原这些寄存器值。根据函数类型，一般POP指令是函数最后结束的指令。但是，在还原寄存器值后，我们需要使用 BX 指令来离开函数。示例如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">sub    sp, r11, #0  /* 重新调整栈指针 */pop    &#123;r11, pc&#125;    /* 恢复栈帧指针, 通过加载之前保存的LR到PC，程序跳转到之前LR保存位置。函数的栈帧被销毁 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所以我们现在知道：</p><ol><li> 函数在开始时设置相应的环境。</li><li> 函数体中执行相关逻辑，然后通过R0保存返回值。</li><li> 函数收尾时恢复所有的状态，以便程序可以在函数调用前的位置继续执行。</li></ol><p>另一个重要的知识点时函数类型：叶子函数和非叶子函数。叶子函数在函数内不会调用/跳转到另一个函数。非叶子函数则会在自己的函数逻辑中调用另一个函数。这两种函数的实现方式类似。不过，也有一些不同。我们用下面的代码分析一下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">/* azeria@labs:~$ as func.s -o func.o &amp;&amp; gcc func.o -o func &amp;&amp; gdb func */.global main​main:    push   &#123;r11, lr&#125;    /* 开始，栈帧指针和LR分别入栈 */    add    r11, sp, #0  /* 设置栈帧的底部（译注：其实是将sp的值给R11，栈指针指向初始的栈帧指针位置（栈帧底部）） */    sub    sp, sp, #16  /* 在栈上分配一些内存作为接下来局部变量要用的缓存区（译注：栈指针减16，相当于将栈帧指针往下移动了16字节）） */    mov    r0, #1       /* 设置局部变量 (a=1). 同时也为函数max准备参数a */    mov    r1, #2       /* 设置局部变量 (b=2). 同时也为函数max准备参数b */    bl     max          /* 跳转到函数max */    sub    sp, r11, #0  /* 重新调整栈指针 */    pop    &#123;r11, pc&#125;    /* 恢复栈帧指针, 通过加载之前保存的LR到PC，程序跳转到之前LR保存位置 */​max:    push   &#123;r11&#125;        /* 开始，栈帧指针入栈 */    add    r11, sp, #0  /* 设置栈帧底部 */    sub    sp, sp, #12  /* 栈指针减12，分配栈内存 */    cmp    r0, r1       /* 比较R0和R1(a和b) */    movlt  r0, r1       /* 如果R0&lt;R1, 将R1存储到R0 */    add    sp, r11, #0  /* 收尾，调整栈指针 */    pop    &#123;r11&#125;        /* 恢复栈帧指针 */    bx     lr           /* 通过寄存器LR跳转到main函数 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的例子包含两个函数：main函数是一个非叶子函数，max函数是叶子函数。之前说了非叶子函数有跳转到其他函数的逻辑（bl , max），而max中没有（最后一条是跳转到LR指定的地址，不是函数分支）这类代码，所以是叶子函数。</p><p>另一个不同点是函数的开始与收尾的实现有差异。来看一段代码，这是叶子函数与非叶子函数在开始部分的差异：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">/* 非叶子函数 */push   &#123;r11, lr&#125;    /* 分别保存栈帧指针和LR */add    r11, sp, #0  /* 设置栈帧底部 */sub    sp, sp, #16  /* 在栈上分配缓存区*/​/* 叶子函数 */push   &#123;r11&#125;        /* 保存栈帧指针 */add    r11, sp, #0  /* 设置栈帧底部 */sub    sp, sp, #12  /* 在栈上分配缓存区 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同之处是非叶子函数保存了更多的寄存器。原因也很自然，因为非叶子函数中执行时LR会被修改，因此要先保存LR以便最后恢复。当然如果有必要也可以在函数开始时保存更多的寄存器。</p><p>下面这段代码可以看到，叶函数与非叶函数在收尾时的差异主要是在于，叶子函数在结尾直接通过LR中的值跳转回去，而非叶子函数需要先通过POP恢复LR寄存器，再进行分支跳转。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">/* A prologue of a non-leaf function */push   &#123;r11, lr&#125;    /* Start of the prologue. Saving Frame Pointer and LR onto the stack */add    r11, sp, #0  /* Setting up the bottom of the stack frame */sub    sp, sp, #16  /* End of the prologue. Allocating some buffer on the stack */​/* A prologue of a leaf function */push   &#123;r11&#125;        /* Start of the prologue. Saving Frame Pointer onto the stack */add    r11, sp, #0  /* Setting up the bottom of the stack frame */sub    sp, sp, #12  /* End of the prologue. Allocating some buffer on the stack */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，我们要再次强调一下在函数中BL和BX指令的使用。在我们的示例中，通过使用BL指令跳转到叶子函数中。在汇编代码中我们使用了标签，在编译过程中，标签被转换为相对应的内存地址。在跳转到对应位置之前，BL会将下一条指令的地址存储到LR寄存器中这样我们就能在函数max结束的时候返回了。</p><p>BX指令在被用在我们离开一个叶函数时，使用LR作为寄存器参数。刚刚说了LR存放着函数调用返回后下一条指令的地址。由于叶函数不会在执行时修改LR寄存器，所以就可以通过LR寄存器跳转返回到main函数了。同样可以使用BX指令帮助我们切换ARM模式和Thumb模式。可以通过LR寄存器的最低比特位来完成，0代表ARM模式，1代表Thumb模式。</p><p>换一种方式看一下函数及其内部，下面的动画说明了非叶子函数和叶子函数的内部工作过程。</p><p><img src="/images/learn/arm-asm/v2-2366dbff72919f11bd14649817c8931a_b.gif"></p><END>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM语法 Part 6[条件状态和分支]</title>
      <link href="/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(6)-%E6%9D%A1%E4%BB%B6%E7%8A%B6%E6%80%81%E5%92%8C%E5%88%86%E6%94%AF.html"/>
      <url>/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(6)-%E6%9D%A1%E4%BB%B6%E7%8A%B6%E6%80%81%E5%92%8C%E5%88%86%E6%94%AF.html</url>
      
        <content type="html"><![CDATA[<p>在探讨CPSR时我们已经接触了条件状态。我们通过跳转（分支）或者一些只有满足特定条件才执行的指令来控制程序在运行时的执行流。通过CPSR寄存器中的特定bit位来表示条件状态。这些位根据指令每次执行的结果而不断变化。例如，比较运算时如果两个数相等，那么就置CPSR中的Zero位（Z=1），实际上是因为：a - b = 0，这种情况下就是<strong>相等</strong>状态。如果第一个数大，那么就是<strong>大于</strong>状态。如果第二个数大，就是<strong>小于</strong>状态。除此之外，还有<strong>小于等于</strong>、<strong>大于等于</strong>等等。</p><p>下面的表格列出了可用的条件状态码，描述和标志位：</p><p><img src="/images/learn/arm-asm/arm-condition.png"></p><p>在下面代码片段中看一下执行条件加法时的实际用法L：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.global main​main:        mov     r0, #2     /* 初始化变量 */        cmp     r0, #3     /* 将R0中的值与3比较，负数位置1 */        addlt   r0, r0, #1 /* 如果上一条比较结果是小于（查看CPSR），则将R0加1 */        cmp     r0, #3     /* 将R0中的值再与3比较， 零位置1，同时负数位重置为0 */        addlt   r0, r0, #1 /* 如果上一条比较结果是小于（查看CPSR），则将R0加1 */        bx      lr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一条<code>cmp</code>指令结果导致<code>CPSR</code>中的负数位置1（<code>2- 3 = -1</code>）意思是<code>R0</code>小于<code>R3</code>。因为满足小于条件（<code>CPSR</code>中的溢出位不等于负数位<code>V != N</code>）所以接下来的<code>ADDLT</code>指令执行。在执行下一条<code>cmp</code>指令时，<code>R0 = 3</code>。所以清除负数位（<code>3 - 3 = 0</code>，负数位清零），零位置位（<code>Z = 1</code>）。现在溢出位是0，负数位是0，不满足小于条件。所以最后一条<code>ADDLT</code>指令不执行，<code>R0</code>值保持3不变。</p><h2 id="Thumb模式下的条件执行"><a href="#Thumb模式下的条件执行" class="headerlink" title="Thumb模式下的条件执行"></a><strong>Thumb模式下的条件执行</strong></h2><p>我们在介绍指令集的章节讨论了Thumb状态下的不同。具体而言是Thumb-2版本支持条件执行。某些 ARM 处理器版本支持”IT”指令，允许在 Thumb 状态下支持多达4个条件执行指令。参考：<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABIJDIC.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABIJDIC.html</a>。</p><p>语法：IT{x{y{z}}} cond</p><ul><li>  cond 指定 IT 块的第一个指令的条件。</li><li>  x 指定 IT 块中第二个指令的条件开关。</li><li>  y 指定 IT 块中第三个指令的条件开关。</li><li>  z 指定 IT 块中第四个指令的条件开关。</li></ul><p>其实IT指令的结构就是“IF-Then-(Else)”，语法都是由字母“T”和“E”构成：</p><ul><li>  IT：If-Then（下一条指令是条件的）；</li><li>  ITT：If-Then-Then（后两条指令是条件的）；</li><li>  ITE：If-Then-Else（后两条指令是条件的）；</li><li>  ITTE：If-Then-Then-Else（后三条指令是条件的）；</li><li>  ITTEE：If-Then-Then-Else-Else（后四条指令是条件的）；</li></ul><p>IT块中的每条指令必须指定相同或逻辑相反的条件后缀。意思是，如果使用ITE，那么前两个指令必须有相同的后缀，而第三个必须是逻辑相反的后缀。下面是 ARM 参考手册中的一些示例，说明了这些逻辑：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ITTE   NE           ; 接下来的3条指令都是有条件的。ANDNE  R0, R0, R1   ; ANDNE不更新条件标志。ADDSNE R2, R2, #1   ; ADDSNE更新条件标志。MOVEQ  R2, R3       ; 有条件的移动​ITE    GT           ; 接下来的2条指令都是有条件的。ADDGT  R1, R0, #55  ; 条件满足大于时进行相加。ADDLE  R1, R0, #48  ; 条件不满足大于时进行相加。​ITTEE  EQ           ; 接下来的4条指令都是有条件的。MOVEQ  R0, R1       ; 有条件的MOVADDEQ  R2, R2, #10  ; 有条件的ADDANDNE  R3, R3, #1   ; 有条件的ANDBNE.W  dloop        ; 分支指令只能在IT块的最后一个指令中使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>错误示例：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">IT     NE           ; 下一条指令是条件的。     ADD    R0, R0, R1   ; 语法错误，不是有条件的指令。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面是条件代码和相反代码：</p><p><img src="https://pic4.zhimg.com/v2-957871637f82f58e8859fec715adc6bb_b.jpg"></p><p>现在使用以下代码来测试：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.syntax unified    @ 非常重要!.text.global _start​_start:    .code 32    add r3, pc, #1   @ PC的值加1并存储到R3。    bx r3            @ 跳转到R3中的地址处，并切换运行模式 ->切换到Thumb模式，因为R3最低有效位（LSB） = 1。​    .code 16         @ Thumb模式    cmp r0, #10          ite eq           @ 如果R0等于10...    addeq r1, #2     @ ... 那么 R1 = R1 + 2    addne r1, #3     @ ... 否则 R1 = R1 + 3    bkpt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>.code 32</code></p><p>示例中的代码开始在ARM模式下，第一条指令将PC中的地址值加1并存储到<code>R3</code>，然后bx指令跳转到<code>R3</code>中的地址位置，并且模式切换成<code>Thumb</code>模式，因为<code>R3</code>中的值最低有效位为1（0不切换）。为此使用<code>bx</code>（分支+交换）非常重要。</p><p><code>.code 16</code></p><p>在<code>Thumb</code>模式下，首先比较<code>R0</code>和<code>10</code>，结果将负数位N置位（<code>0 - 10 = -10</code>）。之后使用<code>If-Then-Else</code>块，因为零位Z（Zero）没有被置位所以<code>ADDEQ</code>指令被跳过，然后因为结果不相等所以执行<code>ADDNE</code>指令。</p><p>在 <code>GDB</code> 中单步执行此代码会干扰结果，因为你要在 <code>ITE</code> 块中执行这两个指令。 但是，在 <code>GDB</code> 中运行代码而不设置断点并单步执行每个指令将生成正确的结果设置 <code>R1</code> = 3。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h2><p>分支（跳转）允许我们跳转到另一个代码段。当你需要跳过（或者重复）某块代码或者跳转到指定的函数的时候，分支很有用。此类情形中最佳的示例是IF和循环。先来看看IF案例。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.global main​main:        mov     r1, #2     /* 设置初始变量a */        mov     r2, #3     /* 设置初始变量b */        cmp     r1, r2     /* 比较两个变量值看哪个更大 */        blt     r1_lower   /* 因为R2更大(N==1)，跳转到r1_lower */        mov     r0, r1     /* 如果没有跳转, 例如R1的值更大(或者相等)，则将R1的值存储到R0 */        b       end        /* 结束 */r1_lower:        mov r0, r2         /* R1小于R2时跳转到此处, 将R2的值存储到R0 */        b end              /* 结束 */end:        bx lr              /* THE END */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码是比较两个初始值并返回最大值，C语言伪代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    max <span class="token operator">=</span> b<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    max <span class="token operator">=</span> a<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在再看一下怎么使用条件分支实现循环：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.global main​main:        mov     r0, #0     /* 设置初始变量a */loop:        cmp     r0, #4     /* 比较a==4 */        beq     end        /* 如果a==4，结束 */        add     r0, r0, #1 /* 否则将R0中的值递增1 */        b loop             /* 跳转到loop开始位置 */end:        bx lr              /* THE END */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C语言伪代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   a<span class="token operator">=</span> a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B、BX、BLX指令"><a href="#B、BX、BLX指令" class="headerlink" title="B、BX、BLX指令"></a><strong>B、BX、BLX指令</strong></h2><p>有三种类型的分支指令：</p><ul><li><p>普通分支（B）  </p></li><li><p>  简单的跳转到一个函数。</p></li><li><p>带链接的跳转（BL）  </p></li><li><p>  将PC+4的值保存到LR寄存器，然后跳转。</p></li><li><p>带状态切换的跳转（BX）和带状态切换及链接的跳转（BLX）  </p></li><li><p>  与B和BL一致，只是添加了工作状态的切换（ARM模式-Thumb模式）。</p></li><li><p>  需要寄存器作为第一个操作数。</p></li></ul><p>BX、BLX用来切换ARM模式到Thumb模式。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.text.global _start​_start:     .code 32         @ ARM mode     add r2, pc, #1   @ put PC+1 into R2     bx r2            @ branch + exchange to R2​    .code 16          @ Thumb mode     mov r0, #1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的技巧是获得当前PC的值，加1然后保存到一个寄存器，然后跳转（并且切换状态模式）到这个寄存器内的地址。可以看到加指令（<code>add r2, pc, #1</code>）获取到有效的PC地址值（<code>当前PC内的值+8=0x805C</code>）然后加1（<code>0x805C + 1 = 0x805D</code>）。接下来，我们跳转的地址（ <code>0x805D = 10000000 01011101</code>）最低有效位为1，那么意味着地址不是4字节（<code>32bit</code>）对齐的。跳转到这样的地址不会导致非对齐问题。在<code>GDB</code>中运行的样子（含<code>GEF</code>）：</p><p><img src="https://pic2.zhimg.com/v2-0101a32310271ca0e5684c7675929c7d_r.jpg"></p><p>注意上面的<code>gif</code>图片是在低版本的<code>GEF</code>下创建的，所以你的显示界面可能不一样，但是逻辑是一样的。</p><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a><strong>条件分支</strong></h2><p>分支也可以有条件地执行，用于在满足特定条件时跳转到函数。我们看一个使用<code>BEQ</code>应用条件分支的例子，这是一段没太有用的汇编代码，只不过是在寄存器等于特定值时将一个值移动到寄存器并跳转到另一个函数的过程。</p><p><img src="https://pic1.zhimg.com/v2-141270f7256618589fad37f2becbf420_b.jpg"></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.text.global _start​_start:   mov r0, #2   mov r1, #2   add r0, r0, r1   cmp r0, #4   beq func1   add r1, #5   b func2func1:   mov r1, r0   bx  lrfunc2:   mov r0, r1   bx  lr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><end>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM语法 Part 5[加载和存储多个值]</title>
      <link href="/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(5)-%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%98%E5%82%A8%E5%A4%9A%E4%B8%AA%E5%80%BC.html"/>
      <url>/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(5)-%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%98%E5%82%A8%E5%A4%9A%E4%B8%AA%E5%80%BC.html</url>
      
        <content type="html"><![CDATA[<p>有时你想要更有效率，一次加载（或存储）多个值。为此我们可以使用LDM（load multiple）和STM（stroe multiple）指令。这些指令有各种变体，基本上只因访问初始地址的方式而异。这是我们本节将要使用的代码，将一步步地认识这些指令。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.data​array_buff: .word 0x00000000             /* array_buff[0] */ .word 0x00000000             /* array_buff[1] */ .word 0x00000000             /* array_buff[2]. 此处是一个相对地址，等于array_buff+8 */ .word 0x00000000             /* array_buff[3] */ .word 0x00000000             /* array_buff[4] */​.text.global _start​_start: adr r0, words+12             /* address of words[3] -> r0 */ ldr r1, array_buff_bridge    /* address of array_buff[0] -> r1 */ ldr r2, array_buff_bridge+4  /* address of array_buff[2] -> r2 */ ldm r0, &#123;r4,r5&#125;              /* words[3] -> r4 = 0x03; words[4] -> r5 = 0x04 */ stm r1, &#123;r4,r5&#125;              /* r4 -> array_buff[0] = 0x03; r5 -> array_buff[1] = 0x04 */ ldmia r0, &#123;r4-r6&#125;            /* words[3] -> r4 = 0x03, words[4] -> r5 = 0x04; words[5] -> r6 = 0x05; */ stmia r1, &#123;r4-r6&#125;            /* r4 -> array_buff[0] = 0x03; r5 -> array_buff[1] = 0x04; r6 -> array_buff[2] = 0x05 */ ldmib r0, &#123;r4-r6&#125;            /* words[4] -> r4 = 0x04; words[5] -> r5 = 0x05; words[6] -> r6 = 0x06 */ stmib r1, &#123;r4-r6&#125;            /* r4 -> array_buff[1] = 0x04; r5 -> array_buff[2] = 0x05; r6 -> array_buff[3] = 0x06 */ ldmda r0, &#123;r4-r6&#125;            /* words[3] -> r6 = 0x03; words[2] -> r5 = 0x02; words[1] -> r4 = 0x01 */ ldmdb r0, &#123;r4-r6&#125;            /* words[2] -> r6 = 0x02; words[1] -> r5 = 0x01; words[0] -> r4 = 0x00 */ stmda r2, &#123;r4-r6&#125;            /* r6 -> array_buff[2] = 0x02; r5 -> array_buff[1] = 0x01; r4 -> array_buff[0] = 0x00 */ stmdb r2, &#123;r4-r5&#125;            /* r5 -> array_buff[1] = 0x01; r4 -> array_buff[0] = 0x00; */ bx lr​words: .word 0x00000000             /* words[0] */ .word 0x00000001             /* words[1] */ .word 0x00000002             /* words[2] */ .word 0x00000003             /* words[3] */ .word 0x00000004             /* words[4] */ .word 0x00000005             /* words[5] */ .word 0x00000006             /* words[6] */​array_buff_bridge: .word array_buff             /* array_buff的地址, 或者说是array_buff[0]的地址 */ .word array_buff+8           /* array_buff[2]的地址 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开始之前，你一定要记住.word是指内存中的数据是32位，也就是4字节。这对理解地址偏移量很重要。程序中的.data段分配了一个空白的数组，有5个元素。我们将它作为可写内存来进行数据存储。.text段包含我们的代码，以及包含两个标签的只读数据段。一个标签是包含7个元素的数组，第二个标签用来桥接.text段和.date段，以便我们可以访问保存在.data中的array_buff。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">adr r0, words+12             /* address of words[3] -> r0 */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>ADR</code>指令（惰性方法）获取<code>words</code>的第四个元素（<code>words[3]</code>）的地址，存储到<code>R0</code>。定位到<code>words</code>数组的中间，以便接下来向前和向后操作。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> break _start gef> rungef> nexti<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在<code>R0</code>存有wards[3]的地址<code>0x80B8</code>，算一下words[0]地址，也就是数组words开始的地址：<code>0x80AC ( 0x80B8 – 0xC)</code>。看一下内存值。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> x/7w 0x00080AC0x80ac &lt;words>: 0x00000000 0x00000001 0x00000002 0x000000030x80bc &lt;words+16>: 0x00000004 0x00000005 0x00000006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在<code>R1</code>和<code>R2</code>中分别保存array_buff数组的第一（array_buff[0]）和第三（array_buff[2]）个元素的地址。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ldr r1, array_buff_bridge    /* address of array_buff[0] -> r1 */ldr r2, array_buff_bridge+4  /* address of array_buff[2] -> r2 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行完上面两条指令，看一下<code>R1</code>和<code>R2</code>中的值，分别是<code>array_buff[0]</code>和<code>array_buff[2]</code>的地址。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> info register r1 r2r1      0x100d0     65744r2      0x100d8     65752<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下一条指令<code>LDM</code>从<code>R0</code>指向的<code>words[3]</code>位置加载两个值到<code>R4</code>和<code>R5</code>，其中<code>words[3]</code>给<code>R4</code>，<code>words[4]</code>给<code>R5</code>。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ldm r0, &#123;r4,r5&#125;              /* words[3]() -> r4 = 0x03; words[4] -> r5 = 0x04 */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们一条指令就加载了两个数据，让<code>R4=0x00000003</code>，<code>R5 = 0x00000004</code>。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> info registers r4 r5r4      0x3      3r5      0x4      4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很好，现在再用<code>STM</code>指令一次存储多条数据值。代码中<code>STM</code>从<code>R4</code>和<code>R5</code>分别获取值<code>0x03</code>和<code>0x04</code>，然后依次存储到<code>R1</code>指定的地址处。前面的指令让<code>R1</code>通过<code>array_buff_bridge</code>指向了数组<code>array_buff</code>的开始位置，最终运行结果：<code>array_buff[0] = 0x00000003 and array_buff[1] = 0x00000004</code>。如果没有特殊说明，<code>LDM</code>和<code>STM</code>操作的数据都是32位。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">stm r1, &#123;r4,r5&#125;              /* r4 -> array_buff[0] = 0x03; r5 -> array_buff[1] = 0x04 */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在<code>0x03</code>和<code>0x04</code>应该分别被保存到了<code>0x100D0</code> and <code>0x100D4</code>。下面的指令是产看地址<code>0x000100D0</code>处的两个字长度的值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> x/2w 0x000100D00x100d0 <span class="token operator">&lt;</span>array_buff<span class="token operator">></span>:  0x3   0x4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>前面提到，<code>LDM</code>和<code>STM</code>有很多变种。其中一种指令后缀。如-<code>IA（increase after）</code>、<code>-IB（increase before）</code>、<code>-DA（decrease after）</code>、<code>-DB（decrease before）</code>。这些变种依据第一个操作数（保存源地址或目标地址的寄存器）指定的不同的内存访问方式而不同。在实践中，<code>LDM</code>与<code>LDMIA</code>相同，意思是第一个操作数（寄存器）内的地址随着元素的加载而不断增加。通过这种方式我们根据第一个操作数（保存了源地址的寄存器）获取一连串（正向）的数据。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ldmia r0, &#123;r4-r6&#125; /* words[3] -> r4 = 0x03, words[4] -> r5 = 0x04; words[5] -> r6 = 0x05; */ stmia r1, &#123;r4-r6&#125; /* r4 -> array_buff[0] = 0x03; r5 -> array_buff[1] = 0x04; r6 -> array_buff[2] = 0x05 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行完上面的指令后，寄存器<code>R4-R6</code>以及地址<code>0x000100D0</code>， <code>0x000100D4</code>和<code>0x000100D8</code>的值应该是<code>0x3</code>， <code>0x4</code>和<code>0x5</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> info registers r4 r5 r6r4     0x3     <span class="token number">3</span>r5     0x4     <span class="token number">4</span>r6     0x5     <span class="token number">5</span>gef<span class="token operator">></span> x/3w 0x000100D00x100d0 <span class="token operator">&lt;</span>array_buff<span class="token operator">></span>: 0x00000003  0x00000004  0x00000005<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LDMIB</code>指令先将源地址加4个字节（一个字）然后再执行加载。这种方式下我们仍然会得到一串加载的数据，但是第一个元素是从源地址偏移4个字节开始的。这就是为什么例子中<code>LDMIB</code>指令操作后<code>R4</code>中的值是<code>0x00000004</code> （<code>words[4]</code>）而不是<code>R0</code>所指的<code>0x00000003</code>（<code>words[3]</code>）的原因。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ldmib r0, &#123;r4-r6&#125;            /* words[4] -> r4 = 0x04; words[5] -> r5 = 0x05; words[6] -> r6 = 0x06 */stmib r1, &#123;r4-r6&#125;            /* r4 -> array_buff[1] = 0x04; r5 -> array_buff[2] = 0x05; r6 -> array_buff[3] = 0x06 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面两条指令执行后，寄存器<code>R4-R6</code>以及地址<code>0x100D4</code>， <code>0x100D8</code>和<code>0x100DC</code>的值应该是<code>0x4</code>， <code>0x5</code>和<code>0x6</code>。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> x/3w 0x100D40x100d4 &lt;array_buff+4>: 0x00000004  0x00000005  0x00000006gef> info register r4 r5 r6r4     0x4    4r5     0x5    5r6     0x6    6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当使用<code>LDMDA</code>指令所有的操作都是反向的。<code>R0</code>当前指向words[3]，当执行指令时反方向加载<code>words[3]</code>，<code>words[2]</code>，<code>words[1]</code>到寄存器<code>R6</code>，<code>R5</code>，<code>R4</code>。是的，寄存器也是按照反向顺序。执行完指令后<code>R6 = 0x00000003，R5 = 0x00000002，R4 = 0x00000001</code>。这里的逻辑是，每次加载后都将源地址递减一次。加载时寄存器按照反方向是因为：每次加载时地址在减小，寄存器也跟着反方向，逻辑上保证了高地址上对应的是高寄存器中的值。再看一下<code>LDMIA</code>（或<code>LDM</code>）的例子，我们首先加载低寄存器是因为源地也是低地址，然后加载高寄存器是因为源地址也增加了。</p><p>加载多条值，后递减：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ldmda r0, &#123;r4-r6&#125; /* words[3] -> r6 = 0x03; words[2] -> r5 = 0x02; words[1] -> r4 = 0x01 */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行后R4、R5和R6的值：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> info register r4 r5 r6r4     0x1    1r5     0x2    2r6     0x3    3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>加载多条值，前递减：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ldmdb r0, &#123;r4-r6&#125; /* words[2] -> r6 = 0x02; words[1] -> r5 = 0x01; words[0] -> r4 = 0x00 */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行后R4、R5和R6的值：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> info register r4 r5 r6r4 0x0 0r5 0x1 1r6 0x2 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>存储多条值，后递减：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">stmda r2, &#123;r4-r6&#125; /* r6 -> array_buff[2] = 0x02; r5 -> array_buff[1] = 0x01; r4 -> array_buff[0] = 0x00 */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行后array_buff[2]，array_buff[1]和array_buff[0]地址处的值：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> x/3w 0x100D00x100d0 &lt;array_buff>: 0x00000000 0x00000001 0x00000002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>存储多条值，前递减：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">stmda r2, &#123;r4-r6&#125; /* r6 -> array_buff[2] = 0x02; r5 -> array_buff[1] = 0x01; r4 -> array_buff[0] = 0x00 */<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行后array_buff[2]，array_buff[1]和array_buff[0]地址处的值：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> x/2w 0x100D00x100d0 &lt;array_buff>: 0x00000000 0x00000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="入栈和出栈"><a href="#入栈和出栈" class="headerlink" title="入栈和出栈"></a><strong>入栈和出栈</strong></h2><p>进程中有一个叫做<strong>栈</strong>的内存位置。栈指针（SP）寄存器总是指向栈内存中的地址。程序应用中通常使用栈来存储临时数据。前面讲的ARM中只能使用加载和存储来访问内存，就是只能使用<code>LDR</code>/<code>STR</code>指令或者他们的衍生指令（<code>LDM</code>、<code>STM</code>、<code>LDMIA</code>、<code>LDMDA</code>、<code>STMDA</code>等等）进行内存操作。在<code>x86</code>中使用PUSH和POP从栈内取或存，ARM中我们也可以使用这条指令。</p><p>当我们将数据<strong>PUSH</strong>入向下生长的栈（详见Part 7：堆栈与函数）时，会发生以下事情：</p><ol><li> 首先，SP中的地址减少4（译注：4字节=32位）。</li><li> 然后，数据存储到SP的新地址值处。</li></ol><p>当数据从栈中<strong>POP</strong>出时，发生以下事情：</p><ol><li> 当前SP中地址处的数据加载到指定寄存器中。</li><li> SP中的地址值加4。</li></ol><p>下面的例子中使用<code>PUSH/POP</code>以及<code>LDMIA/STMDB</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.text.global _start​_start:   mov r0, #3   mov r1, #4   push &#123;r0, r1&#125;   pop &#123;r2, r3&#125;   stmdb sp!, &#123;r0, r1&#125;   ldmia sp!, &#123;r4, r5&#125;   bkpt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反编译一下代码：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">azeria@labs:~$ as pushpop.s -o pushpop.oazeria@labs:~$ ld pushpop.o -o pushpopazeria@labs:~$ objdump -D pushpoppushpop: file format elf32-littlearm​Disassembly of section .text:​00008054 &lt;_start>: 8054: e3a00003 mov r0, #3 8058: e3a01004 mov r1, #4 805c: e92d0003 push &#123;r0, r1&#125; 8060: e8bd000c pop &#123;r2, r3&#125; 8064: e92d0003 push &#123;r0, r1&#125; 8068: e8bd0030 pop &#123;r4, r5&#125; 806c: e1200070 bkpt 0x0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到LDMIA和STMDB被替换成了PUSH和POP。那是因为PUSH是STMDB的同语义指令，POP是LDMIA的同语义指令。</p><p>再GDB中调试运行一下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> break _startgef> rungef> nexti 2[...]gef> x/w $sp0xbefff7e0: 0x00000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行完头两条指令后先查看一下SP指向的地址以及地址处的数值。下一条PUSH指令会将SP减去8，并且将<code>R1</code>和<code>R0</code>中的值按顺序压入栈中。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> nexti[...] ----- Stack -----0xbefff7d8|+0x00: 0x3 &lt;- $sp0xbefff7dc|+0x04: 0x40xbefff7e0|+0x08: 0x1[...] gef> x/w $sp0xbefff7d8: 0x00000003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来栈中的值0x03和0x04弹出到寄存器中。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> nextigef> info register r2 r3r2     0x3    3r3     0x4    4gef> x/w $sp0xbefff7e0: 0x00000001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM语法 Part 4[内存指令：加载和存储]</title>
      <link href="/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(4)-%20%E5%86%85%E5%AD%98%E6%8C%87%E4%BB%A4.html"/>
      <url>/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(4)-%20%E5%86%85%E5%AD%98%E6%8C%87%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<p>ARM使用加载（Load）/存储（Stroe）指令来读写内存，这意味着你只能使用LDR和STR指令访问内存。在ARM上数据必须从内存中加载到寄存器之后才能进行其他操作，而在x86上大部分指令都可以直接访问内存中的数据。如前所述，在ARM上增加内存里的一个32-bit数据值，需要三个指令（load，increment，store）。为了解释 ARM 上的 Load 和 Store 操作的基本原理，我们从一个基本示例开始，然后再使用三个基本偏移形式，每个偏移形式具有三种不同的寻址模式。为了简单化，每个示例，我们将在同一段汇编代码中使用不同 LDR/STR 偏移形式的。遵循这本段教程的最佳方法是在你的测试环境中用调试器（GDB）运行代码示例。</p><ol><li> 偏移形式：立即数作为偏移量</li></ol><ul><li>  寻址模式：立即寻址</li><li>  寻址模式：前变址寻址</li><li>  寻址模式：后变址寻址</li></ul><ol><li> 偏移形式：寄存器作为偏移量</li></ol><ul><li>  寻址模式：立即寻址</li><li>  寻址模式：前变址寻址</li><li>  寻址模式：后变址寻址</li></ul><ol><li> 偏移形式：缩放寄存器作为偏移量</li></ol><ul><li>  寻址模式：立即寻址</li><li>  寻址模式：前变址寻址</li><li>  寻址模式：后变址寻址</li></ul><p>第一个例子：</p><p>LDR 将内存中的值加载到寄存器中，STR 将寄存器内的值存储到内存地址。</p><p><img src="/images/learn/arm-asm/v2-7e659a5fa5dd68149eed99e9f703e749_b.jpg"></p><pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">LDR <span class="token register variable">R2</span>, <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">]</span>   @ <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">]</span> <span class="token operator">-</span> <span class="token register variable">R0</span>中保存的值是源地址。STR <span class="token register variable">R2</span>, <span class="token operator">[</span><span class="token register variable">R1</span><span class="token operator">]</span>   @ <span class="token operator">[</span><span class="token register variable">R1</span><span class="token operator">]</span> <span class="token operator">-</span> <span class="token register variable">R1</span>中保存的值是目标地址。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>LDR : 把R0内保存的值作为地址值，将该地址处的值加载到寄存器R2中。</p><p>STR : 把R1内保存的值作为地址值，将寄存器R2中的值存储到该地址处。</p><p>汇编程序是这样：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.data          /*.data段是动态创建的，无法预测 */var1: .word 3  /* 内存中的变量var1=3*/var2: .word 4  /* 内存中的变量var2=4*/​.text          /* 代码段开始位置 */ .global _start​_start:    ldr r0, adr_var1  @ 通过标签adr_var1获得变量var1的地址，并加载到R0。    ldr r1, adr_var2  @ 通过标签adr_var2获得变量var2的地址，并加载到R1。    ldr r2, [r0]      @ 通过R0内的地址获取到该地址处的值（0x03)，加载到R2。    str r2, [r1]      @ 将R2内的值（0x03）存储到R1中的地址处。     bkpt             ​adr_var1: .word var1  /* 变量var1的地址位置 */adr_var2: .word var2  /* 变量var2的地址位置 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在程序底部有我们的<strong>文本池</strong>（在代码段用来存储常量、字符串或其他可以引用的位置无关的偏移量），使用<code>adr_var1</code>和<code>adr_va2</code>两个标签来存储<code>var1</code>和<code>var2</code>的内存地址。第一个<code>LDR</code>将<code>var1</code>的地址加载到<code>R0</code>，然后第二个<code>LDR</code>将<code>var2</code>的地址加载到·。之后将<code>R0</code>中的地址指向的值（<code>0x03</code>）加载到<code>R2</code>，最后将<code>R2</code>中的值（<code>0x03</code>）存储到<code>R1</code>中的地址处。</p><p>当加载数据到寄存器中时，使用<code>[]</code>符号意思时：取寄存器中的值作为地址值，然后再从该地址处加载数据到目标寄存器中，如果不加<code>[]</code>那就是将寄存器中保存的值直接加载到目标寄存器。</p><p>同样STR命令中也是一个意思。</p><p>这听起来比实际要复杂的多，没关系，下面是一个更直观的演示图：</p><p><img src="/images/learn/arm-asm/v2-78d69cde5c24061ce9305c206406cde6_b.gif"></p><p>下面我们看一下调试器中的这段代码：</p><pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">gef<span class="token operator">></span> disassemble _startDump of assembler code for function _start: <span class="token number">0x00008074</span> <span class="token operator">&lt;</span><span class="token operator">+</span><span class="token number">0</span><span class="token operator">></span>:      ldr  <span class="token register variable">r0</span>, <span class="token operator">[</span>pc, #<span class="token number">12</span><span class="token operator">]</span>   <span class="token comment">; 0x8088 &lt;adr_var1></span> <span class="token number">0x00008078</span> <span class="token operator">&lt;</span><span class="token operator">+</span><span class="token number">4</span><span class="token operator">></span>:      ldr  <span class="token register variable">r1</span>, <span class="token operator">[</span>pc, #<span class="token number">12</span><span class="token operator">]</span>   <span class="token comment">; 0x808c &lt;adr_var2></span> <span class="token number">0x0000807c</span> <span class="token operator">&lt;</span><span class="token operator">+</span><span class="token number">8</span><span class="token operator">></span>:      ldr  <span class="token register variable">r2</span>, <span class="token operator">[</span><span class="token register variable">r0</span><span class="token operator">]</span> <span class="token number">0x00008080</span> <span class="token operator">&lt;</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">></span>:     str  <span class="token register variable">r2</span>, <span class="token operator">[</span><span class="token register variable">r1</span><span class="token operator">]</span> <span class="token number">0x00008084</span> <span class="token operator">&lt;</span><span class="token operator">+</span><span class="token number">16</span><span class="token operator">></span>:     <span class="token register variable">bx</span>   lrEnd of assembler dump.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开头的两个<code>LDR</code>操作中的第二操作数被替换成了<code>[pc, #12</code>]。这被叫做PC相对寻址。因为我们使用了标签，所以编译器可以计算出文本池中标签的地址相对位置（<code>pc+12</code>）。您可以使用这种精确的方法自行计算位置，也可以像前面一样使用标签。唯一的区别是，相较于使用标签，你需要计算值在文本池中的确切位置。在这种情况下，它距离有效的PC位置有3个跳转（4+4+4=12）。本章稍后将介绍有关PC相对寻址的介绍。</p><p>如果你忘了为什么有效PC指向当前指位置后两个指令，在第二部介绍了[…在执行过程中，在ARM模式下，PC将当前指令的地址加上8（两个ARM指令）作为最终值存储起来，在Thumb模式下，将当前指令加上 4（两个Thumb指令）作为最终值存储起来。而x86中PC始终指向要执行的下一个指令…]</p><p><img src="/images/learn/arm-asm/v2-e13403cda1903a6d3268c5cc8665025c_b.png"></p><h1 id="1-偏移模式：立即数作为偏移量"><a href="#1-偏移模式：立即数作为偏移量" class="headerlink" title="1.偏移模式：立即数作为偏移量"></a>1.偏移模式：立即数作为偏移量</h1><pre class="line-numbers language-text" data-language="text"><code class="language-text">STR    Ra, [Rb, imm]LDR    Ra, [Rc, imm]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里，我们使用立即（整数）作为偏移量。从基寄存器（以下示例中的 R1）中增加或减去此值，在编译时可以用已知的偏移量访问数据。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.datavar1: .word 3var2: .word 4​.text.global _start​_start:    ldr r0, adr_var1  @ 通过标签adr_var1获得变量var1的地址，并加载到R0。    ldr r1, adr_var2  @ 通过标签adr_var2获得变量var2的地址，并加载到R1。    ldr r2, [r0]      @ 通过R0内的地址获取到该地址处的值（0x03)，加载到R2。     str r2, [r1, #2]  @ 以R1中的值为基准加上立即数2作为最终地址，将R2中的值（0x03）存储到该地址处，其中R1中的值不会被修改。     str r2, [r1, #4]! @ 前变址寻址：以R1中的值为基准加上立即数4作为最终地址，将R2中的值（0x03）存储到该地址处，其中R1中的值被修改为：R1+4。     ldr r3, [r1], #4  @ 后变址寻址：将R1中的值作为最终地址，获取该地址处的数据加载到R3，其中R1中的值被修改为：R1+4。    bkpt​adr_var1: .word var1adr_var2: .word var2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设以上程序文件为<code>ldr.s</code>，编译并用GDB允许，看看会发生什么。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ as ldr.s <span class="token parameter variable">-o</span> ldr.o$ ld ldr.o <span class="token parameter variable">-o</span> ldr$ gdb ldr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>GDB</code>（包含<code>gef</code>）中，在<code>_start</code>处设置断点，运行程序。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> <span class="token builtin class-name">break</span> _startgef<span class="token operator">></span> run<span class="token punctuation">..</span>.gef<span class="token operator">></span> nexti <span class="token number">3</span>     /* 运行后3条指令 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>系统上的寄存器现在填充了以下值（注意，这些地址在你的系统上可能有所不同）：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">$r0 : 0x00010098 -> 0x00000003$r1 : 0x0001x009c -> 0x00000004$r2 : 0x00000003$r3 : 0x00000000$r4 : 0x00000000$r5 : 0x00000000$r6 : 0x00000000$r7 : 0x00000000$r8 : 0x00000000$r9 : 0x00000000$r10 : 0x00000000$r11 : 0x00000000$r12 : 0x00000000$sp : 0xbefff7e0 -> 0x00000001$lr : 0x00000000$pc : 0x00010080 -> &lt;_start+12> str r2, [r1]$cpsr : 0x00000010<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一条指令将在偏移地址模式下执行<code>STR</code>指令。它将把<code>R2</code>中的值（<code>0x00000003</code>）存储在：<code>R1</code>（<code>0x0001x009c</code>）+偏移（<code>#2</code>）= <code>0x1009e</code>地址处，运行完该条指令后用x/w命令查看<code>0x0001x009c</code>处的值为<code>0x3</code>，完全正确。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> nextigef<span class="token operator">></span> x/w 0x1009e 0x1009e <span class="token operator">&lt;</span>var2+<span class="token operator"><span class="token file-descriptor important">2</span>></span>: 0x3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>再下一条~指令是前变址寻址。可以根据“<code>!</code>”来识别该模式。唯一区别是，基准寄存器会被更新为最终访问地址。这意味着，我们将<code>R2</code> （<code>0x3</code>） 中的值存储到 地址：<code>R1</code> （<code>0x1009c</code>）+ 偏移量（<code>#4</code>） = <code>0x100A0</code>，并使用此地址更新 <code>R1</code>。运行完命令查看<code>0x100A0</code>地址处的值，然后使用命令<code>info register r1</code>查看<code>R1</code>的值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> nextigef<span class="token operator">></span> x/w 0x100A00x100a0: 0x3gef<span class="token operator">></span> info register r1r1     0x100a0     <span class="token number">65696</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一条<code>LDR</code>指令是后变址寻址。意思是<code>R1</code>中的值作为最终访问地址，获取最终访问地址处的值加载到<code>R3</code>。然后将<code>R1</code>（<code>0x100A0</code>）更新为<code>R1（0x100A0）+ 偏移（#4）= 0x100a4</code>。运行完该命令看看寄存器<code>R1</code>和<code>R3</code>的值。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> info register r1r1      0x100a4   <span class="token number">65700</span>gef<span class="token operator">></span> info register r3r3      0x3       <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下图是实际发生的事情：</p><p><img src="/images/learn/arm-asm/v2-5e0c077175fddac4295e69d8e0ac9745_b.gif"></p><h1 id="2-偏移模式：寄存器作为偏移量（寄存器基址变址寻址）"><a href="#2-偏移模式：寄存器作为偏移量（寄存器基址变址寻址）" class="headerlink" title="2.偏移模式：寄存器作为偏移量（寄存器基址变址寻址）"></a>2.偏移模式：寄存器作为偏移量（<strong>寄存器基址变址寻址</strong>）</h1><pre class="line-numbers language-text" data-language="text"><code class="language-text">STR    Ra, [Rb, Rc]LDR    Ra, [Rb, Rc]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种偏移是使用寄存器作为偏移量。下面的示例是，代码在运行时计算要访问的数组索引。</p><pre class="line-numbers language-nasm" data-language="nasm"><code class="language-nasm">.data<span class="token label function">var1:</span> .word <span class="token number">3</span><span class="token label function">var2:</span> .word <span class="token number">4</span>​.text.<span class="token keyword">global _start</span>​<span class="token label function">_start:</span>    ldr <span class="token register variable">r0</span>, adr_var1  @ 通过标签adr_var1获得变量var1的地址，并加载到<span class="token register variable">R0</span>。    ldr <span class="token register variable">r1</span>, adr_var2  @ 通过标签adr_var2获得变量var2的地址，并加载到<span class="token register variable">R1</span>。    ldr <span class="token register variable">r2</span>, <span class="token operator">[</span><span class="token register variable">r0</span><span class="token operator">]</span>      @ 通过<span class="token register variable">R0</span>内的地址获取到该地址处的值（<span class="token number">0x03</span>)，加载到<span class="token register variable">R2</span>。     str <span class="token register variable">r2</span>, <span class="token operator">[</span><span class="token register variable">r1</span>, <span class="token register variable">r2</span><span class="token operator">]</span>  @ 以<span class="token register variable">R1</span>中的值为基准地址，<span class="token register variable">R2</span>中的值（<span class="token number">0x03</span>）为偏移量，获得最终访问地址，将<span class="token register variable">R2</span>中的值（<span class="token number">0x03</span>）存储到该地址处，基准寄存器<span class="token register variable">R1</span>中的值保存不变。    str <span class="token register variable">r2</span>, <span class="token operator">[</span><span class="token register variable">r1</span>, <span class="token register variable">r2</span><span class="token operator">]</span><span class="token operator">!</span> @ 前变址寻址：以<span class="token register variable">R1</span>中的值为基准地址，<span class="token register variable">R2</span>中的值（<span class="token number">0x03</span>）为偏移量，获得最终访问地址，将<span class="token register variable">R2</span>中的值（<span class="token number">0x03</span>）存储到该地址处，基准寄存器<span class="token register variable">R1</span>中的值更新为<span class="token register variable">R1</span><span class="token operator">+</span><span class="token register variable">R2</span>。     ldr <span class="token register variable">r3</span>, <span class="token operator">[</span><span class="token register variable">r1</span><span class="token operator">]</span>, <span class="token register variable">r2</span>  @ 后变址寻址：以<span class="token register variable">R1</span>中的值为最终访问地址，获取该地址处的数据并加载到<span class="token register variable">R3</span>，基准寄存器<span class="token register variable">R1</span>中的值更新为<span class="token register variable">R1</span><span class="token operator">+</span><span class="token register variable">R2</span>。    <span class="token register variable">bx</span> lr​<span class="token label function">adr_var1:</span> .word var1<span class="token label function">adr_var2:</span> .word var2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当执行第一条<code>STR</code>指令时，<code>R2</code>中的值（<code>0x00000003</code>）被存储到地址：<code>0x0001009c + 0x00000003 = 0x0001009F</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> x/w 0x0001009F 0x1009f <span class="token operator">&lt;</span>var2+<span class="token operator"><span class="token file-descriptor important">3</span>></span>: 0x00000003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第二条<code>STR</code>指令操作是前变址寻址，做了同样的操作，不同的一点是<code>R1</code>的值会被更新：<code>R1=R1+R2</code>。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> info register r1 r1     0x1009f      65695<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后一条<code>LDR</code>指令操作是后变址寻址。以<code>R1</code>中的值为访问地址，获取该地址处的数据并加载到<code>R3</code>，然后更新<code>R1</code>的值：<code>R1 = R1 + R2 = 0x1009f + 0x3 = 0x100a2</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> info register r1 r1      0x100a2     <span class="token number">65698</span>gef<span class="token operator">></span> info register r3 r3      0x3       <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/learn/arm-asm/v2-76803a6678cb05ff60302dfd9a41e771_b.jpg"></p><h1 id="3-偏移模式：缩放寄存器作为偏移量（寄存器基址变址寻址）"><a href="#3-偏移模式：缩放寄存器作为偏移量（寄存器基址变址寻址）" class="headerlink" title="3.偏移模式：缩放寄存器作为偏移量（寄存器基址变址寻址）"></a>3.偏移模式：缩放寄存器作为偏移量（寄存器基址变址寻址）</h1><pre class="line-numbers language-text" data-language="text"><code class="language-text">LDR    Ra, [Rb, Rc, &lt;shifter>]STR    Ra, [Rb, Rc, &lt;shifter>]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第三中偏移形式是缩放寄存器作为偏移量。这种情况下，Rb是基地址寄存器，<code>Rc</code>是一个被左移或右移（<code>&lt;shifter&gt;</code>位移操作）缩放过的立即数（<code>Rc</code>中保存的值）。意思是桶型位移操作用来缩放偏移量。下面是一个在数组上循环遍历的例子，可以在<code>GDB</code>中运行看一下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.datavar1: .word 3var2: .word 4​.text.global _start​_start:    ldr r0, adr_var1  @ 通过标签adr_var1获得变量var1的地址，并加载到R0。    ldr r1, adr_var2  @ 通过标签adr_var2获得变量var2的地址，并加载到R1。    ldr r2, [r0]      @ 通过R0内的地址获取到该地址处的值（0x03)，加载到R2。     str r2, [r1, r2, LSL#2]  @ 以R2中的值左移2位（相当于乘以4）为偏移量，加上R1中的基准地址获得最终访问地址，将R2中的值（0x03)存储到该地址，基准寄存器R1中的值不变。    str r2, [r1, r2, LSL#2]! @ 以R2中的值左移2位（相当于乘以4）为偏移量，加上R1中的基准地址获得最终结果地址，将R2中的值（0x03)存储到该地址，基准寄存器R1中的值被修改: R1 = R1 + R2&lt;&lt;2    ldr r3, [r1], r2, LSL#2  @ 以R1中的值为访问地址，加载该地址处的数据到R3，基准寄存器R1中的值被修改: R1 = R1 + R2&lt;&lt;2    bkpt​adr_var1: .word var1adr_var2: .word var2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是程序运行时的样子：</p><p><img src="/images/learn/arm-asm/v2-449b52f8c8f8c628d6f1db0dc4cfa8e4_b.jpg"></p><p>第一条不多赘述，第二条<code>STR</code>指令操作使用了前变址寻址，也就是：<code>R1</code>的值<code>0x1009c+R2</code>中的值左移<code>2</code>位（<code>0x03&lt;&lt;2=0xc</code>）= <code>0x100a8</code>，并更新<code>R1</code>的值为<code>0x100a8</code>：<code>R1 = R1 + 0x03&lt;&lt;2 = 0x100a8 + 0xc = 0x100b4</code>。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> info register r1r1      0x100a8      <span class="token number">65704</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后一条<code>LDR</code>指令操作使用了后变址寻址。意思是，加载<code>R1</code>中的值<code>0x100a8</code>地址处的数据到寄存器<code>R3</code>，然后将<code>R2</code>中的值左移两位（<code>0x03&lt;&lt;2=0xc</code>）得到值<code>0xC</code>，再加上<code>R1</code>中的值<code>0x100a8</code>得到<code>0x100b4</code>，最后<code>R1</code>的值更新为<code>0x100a8</code>：<code>R1 = R1 + 0x03&lt;&lt;2 = 0x100a8 + 0xc = 0x100b4</code>。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gef> info register r1r1      0x100b4      65716<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>记住<code>LDR</code>和<code>STR</code>中有三种偏移形式：</p><ol><li> 立即数作为偏移量</li></ol><ul><li>  <code>ldr r3, [r1, #4]</code></li></ul><ol><li> 寄存器作为偏移量</li></ol><ul><li>  <code>ldr r3, [r1, r2]</code></li></ul><ol><li> 带有位移操作的寄存器作为偏移量</li></ol><ul><li>  <code>ldr r3, [r1, r2, LSL#2]</code></li></ul><p>如何记住<code>LDR</code>和<code>STR</code>这些寻址模式：</p><ul><li><p>  如果带有<code>!</code>，就是前变址寻址</p></li><li><p>  <code>ldr r3, [r1, #4]!</code></p></li><li><p>  <code>ldr r3, [r1, r2]!</code></p></li><li><p>  <code>ldr r3, [r1, r2, LSL#2]!</code></p></li><li><p>  如果基地值寄存器（<code>R1</code>）带中括号，就是后变址寻址</p></li><li><p>  <code>ldr r3, [r1], #4</code></p></li><li><p>  <code>ldr r3, [r1], r2</code></p></li><li><p>  <code>ldr r3, [r1], r2, LSL#2</code></p></li><li><p>  其他的都是带偏移量的寄存器间接寻址</p></li><li><p>  <code>ldr r3, [r1, #4]</code></p></li><li><p>  <code>ldr r3, [r1, r2]</code></p></li><li><p>  <code>ldr r3, [r1, r2, LSL#2]</code></p></li></ul><h1 id="LDR中的PC相对寻址"><a href="#LDR中的PC相对寻址" class="headerlink" title="LDR中的PC相对寻址"></a>LDR中的PC相对寻址</h1><p><code>LDR</code>是唯一用来加载数据到寄存器中的指令。语法如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.section .text.global _start​_start:   ldr r0, =jump        /* 加载函数标签jump的地址到R0 */   ldr r1, =0x68DB00AD  /* 加载值0x68DB00AD到R1 */jump:   ldr r2, =511         /* 加载值511到R2 */    bkpt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些指令被称为伪指令，我们可以使用此语法来引用文本池中的数据。在上面的示例中，我们使用这些伪指令引用一个函数的偏移量，在指令中将一个32位常量加载到寄存器中。我需要使用此语法在一个指令中将 32 位常量移动到寄存器中的原因是，ARM 只能一次加载 8 位值。什么？要了解原因，您需要了解 ARM 上如何处理立即数的。</p><h1 id="ARM中的立即数"><a href="#ARM中的立即数" class="headerlink" title="ARM中的立即数"></a>ARM中的立即数</h1><p>在ARM上加载一个立即数到寄存器中并不像x86上那么简单，ARM对于立即数有很多限制。这些限制是什么以及如何处理它们并不是ARM汇编所关心的，这只是为了有助于你理解，其实有一些技巧可以绕过这些限制（提示：<code>LDR</code>）。</p><p>我们知道ARM指令长度是32位，并且所有指令都是可条件执行指令。其中有16种条件码，就要占用4位（2^4=16)，然后还要2位代指目标寄存器，2位代指操作寄存器，1位作为状态标志，加起其他一些操作码占用的位。到这里分配完指令类型，寄存器以及其他位段，最后只剩下12位用来操作立即数，最多只能表示4096个数。</p><p>这意味着ARM中<code>MOV</code>指令只能操作一定范围内的立即数，如果不能直接被调用，就必须被分割成多个部分，用众多小数字拼起来。</p><p>还没完，这12位还不全是用来表示一个整数，其中8位用来表示0-255范围的数<code>n</code>，4位表示旋转循环右移（其实ARM中只有一种位移，就是旋转循环右移，左移也是通过旋转循环右移得到）的次数<code>r</code>（范围0-30）。所以一个立即数的表示形式是：<code>v = n ror 2*r</code>。也就是说，只能以偶数进行旋转循环右移，一次移动两位，n组成的有效位图必须能放到一个字节（8位）中。</p><p>下面是一些有效和无效的立即数：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Valid values:#256        // 1 ror 24 --> 256  循环右移12次，每次两位(注意数据是32位长度)。#384        // 6 ror 26 --> 384  循环右移13次，每次两位。#484        // 121 ror 30 --> 484#16384      // 1 ror 18 --> 16384#2030043136 // 121 ror 8 --> 2030043136#0x06000000 // 6 ror 8 --> 100663296 (0x06000000 in hex)​Invalid values:#370        // 185 ror 31 --> 循环右移31位，但超出了(0 – 30)范围，因此不是有效立即数。#511        // 1 1111 1111 --> 有效位图无法放到一个字节（8位）中。#0x06010000 // 110 0000 0001.. --> 有效位图无法放到一个字节（8位）中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>译注：1.以上立即数都是32位长度。2.旋转循环右移：每位都向右移动，末位不断放到最前位，类似首尾相连。3.有效位图要能放到一个字节中：例子中</em><code>*#511*</code><em>的二进制为</em><code>*0000 0000 0000 0000 0000 0001 1111 1111*</code><em>，有效位图为</em><code>*1 1111 1111*</code><em>，超过一个字节。</em><code>*#0x06010000*</code><em>的二进制位‭</em><code>*0110 0000 0001 0000 0000 0000 0000*</code><em>‬，有效位图</em><code>*110 0000 0001*</code><em>超过一个字节。</em></p><p>其结果是无法一次加载完整的 32 位地址。我们可以通过使用以下两个选项之一来绕过此限制：</p><ol><li><p> 用较小的值构造较大的值</p></li><li><p> 不要使用 <code>MOV r0, #511</code></p></li><li><p> 分成两部分： <code>MOV r0, #256</code>和<code>ADD r0, #255</code></p></li><li><p> 使用加载方式“<code>ldr r1, =value</code>”，编译器会很乐意将其转换位<code>MOV</code>指令，或者是<code>PC</code>相对寻址来加载。</p></li><li><p> <code>LDR r1, = 511</code></p></li></ol><p>如果你加载了一个无效的立即数，那么编译器会报错：“<code>Error: invalid constant</code>”。如果遇到这种问题你应该知道怎么做。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.section .text.global _start​_start:    mov     r0, #511    bkpt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果尝试编译，编译器会输出类似以下错误：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">azeria@labs:~$ as test.s -o test.otest.s: Assembler messages:test.s:5: Error: invalid constant (1ff) after fixup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你应该把<code>511</code>拆成几个小数值，或者用前面介绍的<code>LDR</code>方式。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.section .text.global _start​_start: mov r0, #256   /* 1 ror 24 = 256, so it's valid */ add r0, #255   /* 255 ror 0 = 255, valid. r0 = 256 + 255 = 511 */ ldr r1, =511   /* load 511 from the literal pool using LDR */ bkpt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你想判断一个立即数是否是有效的立即数，你可以用我写的python脚本<a href="https://raw.githubusercontent.com/azeria-labs/rotator/master/rotator.py">rotator.py</a> ：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">azeria@labs:~$ python rotator.pyEnter the value you want to check: <span class="token number">511</span>​Sorry, <span class="token number">511</span> cannot be used as an immediate number and has to be split.​azeria@labs:~$ python rotator.pyEnter the value you want to check: <span class="token number">256</span>​The number <span class="token number">256</span> can be used as a valid immediate number.<span class="token number">1</span> ror <span class="token number">24</span> --<span class="token operator">></span> <span class="token number">256</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><end>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM语法 Part 3[ARM指令集]</title>
      <link href="/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(3)-ARM%E6%8C%87%E4%BB%A4%E9%9B%86.html"/>
      <url>/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(3)-ARM%E6%8C%87%E4%BB%A4%E9%9B%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="ARM模式和Thumb模式"><a href="#ARM模式和Thumb模式" class="headerlink" title="ARM模式和Thumb模式"></a><strong>ARM模式和Thumb模式</strong></h1><p>ARM处理器主要有两种工作模式（先不算Jazelle）-ARM状态和Thumb状态。这些状态模式与权限级别无关，它们主要区别是指令集，在ARM模式下指令集始终是32-bit，但是在Thumb模式下可以是16-bit或者32-bit。学会怎么使用Thumb模式对于ARM开发很重要。编写ARM壳代码时，我们需要避免NULL字节，使用16位Thumb指令而不是32位ARM指令可以降低这种风险。ARM各版本的调用规范容易让人混淆，不是所有的ARM版本都支持相同的Thumb指令集。后来，ARM 引入了增强的 Thumb 指令集（伪名称：Thumbv2），它允许 32 位 Thumb 指令甚至允许条件执行，在之前的版本中是不行的。为了在Thumb模式中支持条件执行，引入了“<code>it</code>”指令。但是，该指令随后又在更高版本中删除了，被一种更简单的方式所替换。不同ARM/Thumb指令集的有各种不同变体，一般不同关心这些。只需要知道的是你的目标设备的 ARM 版本及其特定的 Thumb 支持，然后再调整代码。ARM 信息中可以帮助您确定ARM 版本的细节（<a href="http://infocenter.arm.com/help/index.jsp">http://infocenter.arm.com/help/index.jsp</a>）。</p><ul><li>  Thumb-1（16 位指令）：在ARMv6和更早的体系结构中使用。</li><li>  Thumb-2（16 位和 32 位指令）：在Thumb-1基础上添加更多指令并允许它们为 16 位或 32 位宽（ARMv6T2、ARMv7）。</li><li>  ThumbEE：更改和添加了一些支持动态生成代码的功能（在执行之前或执行期间在设备上编译代码）。</li></ul><p>ARM模式和Thumb模式的态区别：</p><ul><li><p>  条件执行：在ARM模式下所有的指令都支持条件执行。一些版本的ARM处理器可以通过<code>it</code>指令在Thumb工作模式下支持条件执行。</p></li><li><p>  ARM和Thumb模式下的32-bit指令：在Thumb模式下的32-bit指令有<code>.w</code>后缀。</p></li><li><p>桶型位移器（barrel shifter）是ARM模式下的另一个特点。它可以将多条指令缩减为一条。例如，你可以通过向左位移1位的指令后缀将乘法运算直接包含在一条<code>MOV</code>指令中（将一个寄存器的值乘以2，再将结果<code>MOV</code>到另一个寄存器）:<br>  <code>MOV R1, R0, LSL#1 ;R1 = R0 * 2</code>，而不需要使用专门的乘法指令来运算。</p><p>  要切换处理器在其中执行的状态，必须满足以下两个条件之一：</p></li><li><p>  我们可以使用分支指令 BX（分支和切换状态）或 BLX（分支、链接和切换状态），并将目标寄存器的最小有效位设置为 1。可以通过偏移量加1来实现，例如0x5530+1。您可能会认为这将导致对齐问题，因为指令是 2 或 4 字节对齐的。这不是问题，因为处理器将忽略最低有效位。详见Part 6：条件执行和分支。</p></li><li><p>  如果当前程序状态寄存器的T位被置位，就说明工作在Thumb模式下。</p></li></ul><h1 id="ARM指令简介"><a href="#ARM指令简介" class="headerlink" title="ARM指令简介"></a><strong>ARM指令简介</strong></h1><p>本节简单介绍ARM指令集以及基本用法。了解汇编语言中的最小部分如何操作，它们之间如何衔接，它们之间能组合成什么样的功能。</p><p>ARM指令后面通常跟着两个操作数，像下面这样的形式：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">MNEMONIC&#123;S&#125;&#123;condition&#125; &#123;Rd&#125;, Operand1, Operand2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于ARM指令集的灵活性，并不是所有的指令都用到这些字段。这些字段的解释如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">MNEMONIC     - 操作指令（机器码对应的助记符）。&#123;S&#125;          - 可选后缀. 如果指定了该后缀，那么条件标志将根据操作结果进行更新。&#123;condition&#125;  - 执行指令所需满足的条件。&#123;Rd&#125;         - 目标寄存器，存储操作结果。Operand1     - 第一操作数（寄存器或者立即数）Operand2     - 第二操作数. 立即数或者带有位移操作后缀（可选）的寄存器。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>MNEMONIC</code>, <code>S,</code> <code>Rd</code>和<code>Operand1</code>字段比较明了，<code>condition</code> 和 <code>Operand2</code>字段需要再解释一下。<code>condition</code>字段与<code>CPSR</code>寄存器的值有关，准确的说是和<code>CPSR</code>某些位有关。<code>Operand2</code>也叫可变操作数，因为它可以有多种形式–立即数、寄存器、带有位移操作的寄存器。例如<code>Operand2</code>可以有以下多种形式：</p><pre class="line-numbers language-ASM" data-language="ASM"><code class="language-ASM">#123                    - 立即数。Rx                      - 寄存器x (如 R1, R2, R3 ...)。Rx, ASR n               - 寄存器x，算术右移n位 (1 &#x3D; n &#x3D; 32)。Rx, LSL n               - 寄存器x，逻辑左移n位 (0 &#x3D; n &#x3D; 31)。Rx, LSR n               - 寄存器x，逻辑右移n位 (1 &#x3D; n &#x3D; 32)。Rx, ROR n               - 寄存器x，循环右移n位 (1 &#x3D; n &#x3D; 31)。Rx, RRX                 - 寄存器x，扩展的循环位移，右移1位。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们以一个简单的例子看一下这些指令的不同：</p><pre class="line-numbers language-ASM" data-language="ASM"><code class="language-ASM">ADD   R0, R1, R2         - 将寄存器R1内的值与寄存器R2内的值相加，结果存储到R0。ADD   R0, R1, #2         - 将寄存器R1内的值加上立即数2，结果存储到R0。MOVLE R0, #5             - 仅当满足条件LE（小于或等于）时，才将立即数5移动到R0（编译器会把它看作MOVLE R0, R0, #5）。MOV   R0, R1, LSL #1     - 将寄存器R1的内容向左移动一位然后移动到R0（Rd）。因此，如果R1值是2，它将向左移动一位，并变为4。然后将4移动到R0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>来快速总结一下，看一下后续示例中将涉及的一些常用指令：</p><p><img src="/images/learn/arm-asm/v2-74d22374f88395c04878b6a4e38d94e2.jpg"></p><end>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM语法 Part 2[数据类型]</title>
      <link href="/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(2)-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
      <url>/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(2)-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<p>与高级编程语言类似，ARM汇编也支持操作不同的数据类型。</p><p><img src="/images/learn/arm-asm/v2-cbde49a069908bc349b9db851c9b95c7.png"></p><p>我们载入（load)或存储（store）的数据类型可以是有符号或无符号的<strong>字</strong>、<strong>半字</strong>或<strong>字节</strong>。这些数据类型的扩展符是：-h或-sh代表<strong>半字</strong>，-b和-sb代表<strong>字节</strong>，其中<strong>字</strong>没有扩展符号。有符号和无符号的区别：</p><ul><li>  有符号数据类型可以存储正数和负数，因此表示的值范围更小。</li><li>  无符号数据类型可以存储大的正数（包含0），不能存储符数因此可以表示更大的数。</li></ul><p>载入和存储指令使用数据类型：</p><pre class="line-numbers language-TEXT" data-language="TEXT"><code class="language-TEXT">ldr &#x3D; Load Wordldrh &#x3D; Load unsigned Half Wordldrsh &#x3D; Load signed Half Wordldrb &#x3D; Load unsigned Byteldrsb &#x3D; Load signed Bytes​str &#x3D; Store Wordstrh &#x3D; Store unsigned Half Wordstrsh &#x3D; Store signed Half Wordstrb &#x3D; Store unsigned Bytestrsb &#x3D; Store signed Byte<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字节序列"><a href="#字节序列" class="headerlink" title="字节序列"></a>字节序列</h1><p>查看内存中的字节有两种基本方式：小端模式（Little-Endian）和大端模式（Big-Endian）。它们的不同之处是对象存储在内存中时每个字节的排列顺序-字节顺序。在x86这种小端模式的机器上低位字节存储在低地址（更靠近零地址），而在大端模式的机器上高位字节存储在低地址。在第三版本之前ARM架构是小端模式，之后是两种模式都允许，可以进行设置来切换字节序列。例如，在 ARMv6 上，指令是固定的小端，数据访问可以是小端或大端，由程序状态寄存器 （CPSR） 的位 9（E 位）控制。</p><p><img src="/images/learn/arm-asm/v2-2598cab062a1f04b3f0be6362530d64e_b.jpg"></p><h1 id="ARM寄存器"><a href="#ARM寄存器" class="headerlink" title="ARM寄存器"></a>ARM寄存器</h1><p>寄存器的数量取决于ARM的版本。根据ARM参考手册，除了基于 ARMv6-M 和 ARMv7-M 的处理器外，共有30个32位通用寄存器。前 16 个寄存器可在用户级模式下访问，其他寄存器在特权软件执行中可用（除了 ARMv6-M 和 ARMv7-M ）。在本教程中，我们将使用非特权模式下可访问的寄存器：r0-15。这 16 个寄存器可以分为两组：通用寄存器和特殊用途寄存器。</p><p><img src="/images/learn/arm-asm/v2-6aac505a399410581ac849576a43d9fb_b.jpg"></p><p>下表只是简要了解 ARM 寄存器与英特尔处理器中的寄存器的关系。</p><p><img src="/images/learn/arm-asm/v2-839c287093fc49f9f059424e03e923c2_b.jpg"></p><p><strong>R0-R12</strong>：可用于常见操作期间存储临时值、指针（内存位置）等等。例如R0，在算术运算期间可以称为累加器，或用于存储调用的函数时返回的结果。R7在进行系统调用时非常有用，因为它存储了系统号，R11可帮助我们跟踪作为帧指针的堆栈上的边界（稍后将介绍）。此外，ARM上的函数调用约定函数的前四个参数存储在寄存器r0-r3中。</p><p>R13：SP（栈指针）。始终指向当前栈顶。</p><p><strong>R14：LR</strong>（链接寄存器）。进行函数调用时，链接寄存器将更新为当前函数调用指令的下一个指令的地址，也就是函数调用返回后需要继续执行的指令。这么做是允许子函数调用完成后，在子函数中利用该寄存器保存的指令地址再返回到父函数中。</p><p><strong>R15：PC</strong>（程序计数器）。程序计数器自动按执行的指令大小递增。此指令大小在ARM模式下始终为4个字节，在THUMB模式下为2个字节。执行分支指令时，PC保存目标地址。在执行过程中，在ARM模式下PC将当前指令的地址加上8（两个ARM指令），在Thumb（v1）状态下则指令加上4（两个Thumb指令）。这与x86 中PC始终指向要执行的下一个指令不同。</p><p>我们看一下在调试状态下PC的值。我们使用以下程序将PC地址存储到 r0 中，并包含两个随机指令。看看会发生什么。</p><pre class="line-numbers language-ASM" data-language="ASM"><code class="language-ASM">.section .text.global _start​_start: mov r0, pc mov r1, #2 add r2, r1, r1 bkpt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用GDB在<code>_start</code>处设置断点并运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gef<span class="token operator">></span> br _startBreakpoint <span class="token number">1</span> at 0x8054gef<span class="token operator">></span> run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$r0</span> 0x00000000   <span class="token variable">$r1</span> 0x00000000   <span class="token variable">$r2</span> 0x00000000   <span class="token variable">$r3</span> 0x00000000 <span class="token variable">$r4</span> 0x00000000   <span class="token variable">$r5</span> 0x00000000   <span class="token variable">$r6</span> 0x00000000   <span class="token variable">$r7</span> 0x00000000 <span class="token variable">$r8</span> 0x00000000   <span class="token variable">$r9</span> 0x00000000   <span class="token variable">$r10</span> 0x00000000  <span class="token variable">$r11</span> 0x00000000 <span class="token variable">$r12</span> 0x00000000  <span class="token variable">$sp</span> 0xbefff7e0   <span class="token variable">$lr</span> 0x00000000   <span class="token variable">$pc</span> 0x00008054 <span class="token variable">$cpsr</span> 0x00000010 ​0x8054 <span class="token operator">&lt;</span>_start<span class="token operator">></span> mov r0, pc     <span class="token operator">&lt;</span>- <span class="token variable">$pc</span>0x8058 <span class="token operator">&lt;</span>_start+<span class="token operator"><span class="token file-descriptor important">4</span>></span> mov r0, <span class="token comment">#2</span>0x805c <span class="token operator">&lt;</span>_start+<span class="token operator"><span class="token file-descriptor important">8</span>></span> <span class="token function">add</span> r1, r0, r00x8060 <span class="token operator">&lt;</span>_start+1<span class="token operator"><span class="token file-descriptor important">2</span>></span> bkpt 0x00000x8064 andeq r1, r0, r1, asr <span class="token comment">#10</span>0x8068 cmnvs r5, r0, lsl <span class="token comment">#2</span>0x806c tsteq r0, r2, ror <span class="token comment">#18</span>0x8070 andeq r0, r0, r110x8074 tsteq r8, r6, lsl <span class="token comment">#6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到PC持有将要执行的下一个指令（<code>mov r0, pc</code>） 的地址（0x8054）。现在，让我们执行这条指令，之后R0应该持有PC（0x8054） 的地址，对吗？</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$r0</span> 0x0000805c   <span class="token variable">$r1</span> 0x00000000   <span class="token variable">$r2</span> 0x00000000   <span class="token variable">$r3</span> 0x00000000 <span class="token variable">$r4</span> 0x00000000   <span class="token variable">$r5</span> 0x00000000   <span class="token variable">$r6</span> 0x00000000   <span class="token variable">$r7</span> 0x00000000 <span class="token variable">$r8</span> 0x00000000   <span class="token variable">$r9</span> 0x00000000   <span class="token variable">$r10</span> 0x00000000  <span class="token variable">$r11</span> 0x00000000 <span class="token variable">$r12</span> 0x00000000  <span class="token variable">$sp</span> 0xbefff7e0   <span class="token variable">$lr</span> 0x00000000   <span class="token variable">$pc</span> 0x00008058 <span class="token variable">$cpsr</span> 0x00000010​0x8058 <span class="token operator">&lt;</span>_start+<span class="token operator"><span class="token file-descriptor important">4</span>></span> mov r0, <span class="token comment">#2       &lt;- $pc</span>0x805c <span class="token operator">&lt;</span>_start+<span class="token operator"><span class="token file-descriptor important">8</span>></span> <span class="token function">add</span> r1, r0, r00x8060 <span class="token operator">&lt;</span>_start+1<span class="token operator"><span class="token file-descriptor important">2</span>></span> bkpt 0x00000x8064 andeq r1, r0, r1, asr <span class="token comment">#10</span>0x8068 cmnvs r5, r0, lsl <span class="token comment">#2</span>0x806c tsteq r0, r2, ror <span class="token comment">#18</span>0x8070 andeq r0, r0, r110x8074 tsteq r8, r6, lsl <span class="token comment">#6</span>0x8078 adfcssp f0, f0, <span class="token comment">#4.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对吗？错！看一下R0中的地址。虽然我们期望R0包含以前读取的PC值（0x8054），但它保留的值比我们之前读取的PC 早两个指令（0x805c）。从这个示例中可以看到，当我们直接读取PC时，它遵循PC指向下一个指令的定义；但在调试时，PC会指向当前PC值之后的两个指令（0x8054 + 8 = 0x805C）。这是因为较旧的ARM处理器始终取当前执行的指令之后的两个指令。ARM保留此定义的原因是为了确保与早期处理器兼容。</p><h1 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h1><p>当你用gdb调试ARM程序时，你会看到一些状态标志：</p><p><img src="/images/learn/arm-asm/v2-f6c3bdae6bc01ea24a2a3ffb54c752b1_b.png"></p><p>寄存器<code>$cpsr</code>显示当前程序状态寄存器的值，在它下面你可以看到工作状态标志，用户模式，中断标志，溢出标志，进位标志，零标志位，符号标志。这些标志代表了CPSR寄存器中特定的位，并根据CPSR的值进行设置，如果标志位有效则会进行加粗。N、Z、C 和 V 位与x86上的EFLAG寄存器中的SF、ZF、CF和OF位相同。这些位用于支持条件分支中的条件执行，并在汇编层面支持循环语句。我们将在第6部分：条件执行和分支中进行介绍。</p><p><img src="/images/learn/arm-asm/v2-d4e4d2af2290ef85ff0e45883546b77c_b.jpg"></p><p>上图显示了32位寄存器（CPSR）的结构，左侧是高字节位，右侧是低字节位。每个单元（GE和M部分以及空白单元除外）的大小均为一个bit位。这些位定义了程序当前状态的各种属性。</p><p><img src="/images/learn/arm-asm/v2-4900e072dbad402f8e51eb531dfb132a_b.jpg"></p><p>假设我们可以使用<code>CMP</code>指令比较1和2，返回结果应该为负数（<code>1 - 2 = -1</code>）。当比较两个相等的数则会设置Z（zero）标志位（例如比较2和2， <code>2 - 2 = 0</code>）。记住，CMP指令中使用的寄存器不会被修改，只有CPSR会根据这些寄存器相互比较的结果进行修改。</p><p>这是GDB（安装了GEF）中的模样：在此示例中，我们比较寄存器r1和r0，其中r1 = 4和r0 = 2。这是执行 cmp r1，r0 操作后标志的外观：</p><p><img src="/images/learn/arm-asm/v2-fedb0cccd25f9ec947388256a8174b4e_b.png"></p><p>之所以设置Carry标志，是因为我们使用 <code>cmp r1, r0</code> 将 4 与 2（4 - 2）进行比较。相反，如果我们使用 cmp r0 r1、r1 将较小的数字（2）与较大的数字（4）进行比较，则设置负标志（N）。</p><p>CPSR 包含以下状态标志：</p><ul><li>  N – 当计算结果为负时被设置.</li><li>  Z – 当计算结果为零时被设置.</li><li>  C – 当计算结果有进位时被设置.</li><li>  V – 当计算结果有溢出时被设置.</li></ul><p>C：其设置分一下几种情况：</p><ul><li>  加法运算(包括比较指令cmn):当运算结果产生了进位时(无符号数溢出),C=1,否则C=0.</li><li>  减法运算(包括比较指令cmp):当运算时发生了借位(无符号数下益出),C=0,否则C=1.</li><li>  对于包含移位操作的非加/减运算指令:C为移位操作中最后移出位的值.</li><li>  对于其他非加减运算指令:C的值通常保持不变.</li></ul><p>V：如果加、减或比较的结果大于或等于2^31 或小于-2^31，则会发生溢出。</p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM语法 Part 1[ARM汇编介绍]</title>
      <link href="/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(1)-ARM%E6%B1%87%E7%BC%96%E4%BB%8B%E7%BB%8D.html"/>
      <url>/20230601/Asm_asm/ARM%E8%AF%AD%E6%B3%95(1)-ARM%E6%B1%87%E7%BC%96%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>看到一个比较好的ARM汇编入门教程。上不了班，闲着没事翻译了一下。</p><p>原址：<a href="https://azeria-labs.com/writing-arm-assembly-part-1/">https://azeria-labs.com/writing-arm-assembly-part-1/</a></p><h1 id="ARM-汇编语言入门（一）"><a href="#ARM-汇编语言入门（一）" class="headerlink" title="ARM 汇编语言入门（一）"></a>ARM 汇编语言入门（一）</h1><h2 id="Part1：ARM汇编介绍"><a href="#Part1：ARM汇编介绍" class="headerlink" title="Part1：ARM汇编介绍"></a><strong>Part1：ARM汇编介绍</strong></h2><h2 id="处理器arm-VS-intel"><a href="#处理器arm-VS-intel" class="headerlink" title="处理器arm VS. intel"></a>处理器arm VS. intel</h2><p>ARM与Intel有诸多不同，最主要的区别是指令集。Intel是<strong>复杂指令集</strong>（CISC：Complex Instruction Set Computing）处理器，拥有功能更多更丰富的指令，允许对内存进行更复杂的操作。因此也拥有更多的指令操作，寻址模式，然而寄存器数量却比ARM少。CISC处理器主要应用在个人电脑，工作站，服务器当中。</p><p>ARM是<strong>精简指令集</strong>（RISC：Reduced Instruction set Computing）处理器，拥有更简单的指令集（少于100个）和更多的通用寄存器。与Intel不同，ARM指令只操作寄存器，且只能使用Load/Stroe(取/存)命令来读取和写入内存。也就是说，如果增加某个地址处的32位数据的值，你起码需要三个指令（取，加，存）：首先将该地址处的数据加载到寄存器（取），然后增加寄存器里的值（加），最后再将寄存器里的值存储到原来的地址处（存）。</p><p>精简指令集有优点也有缺点。优点之一是单条指令执行更快，相应地也获得了更高的处理速度（精简指令集系统通过减少单条指令的时钟周期来减少执行时间）。不利的一面是更少的指令意味着更加要求更加注重软件书写效率。还要注意的是ARM有两种工作状态：ARM模式和Thumb模式。Thumb模式指令可以是2个字节或者4个字节（详见Part 3:ARM指令集）。</p><p>ARM与x86其他区别：</p><ul><li>  ARM中大部分指令都可以用作条件执行。</li><li>  x86和x86-64系列处理器使用<strong>小端</strong>（little-endian）地址格式。</li><li>  ARM架构在第三版以前是小端模式。之后变为<strong>大-小端</strong>（BI-endian)格式，允许大端或小端两种模式进行切换。</li></ul><p>不仅ARM与Intel有不同，而且ARM各版本之间也有不同。本教程尽量保留它们之间最通用的部分以便你能理解ARM是怎么工作的。一旦你理解了最基本的部分，当你选择不同的ARM版本时也可以融会贯通。本教程所有的例子是在32-bit ARMv6平台（Raspberry Pi 1）创建，所有的说明都是基于此版本。</p><p><img src="/images/learn/arm-asm/v2-64d9d1ab1b00428fe3421c4f26d4e72d_b.jpg"></p><p><em>不同ARM版本命名</em></p><h1 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h1><p>在开始ARM开发之前我们需要先了解基本的汇编编程。使用一般的编程语言或者脚本语言来开发不行吗，为什么还需要ARM汇编？确实不行，如果我们要做逆向工程或者想了解ARM二进制程序流，创建自己的ARM壳程序（shellcode：利用程序漏洞而执行的代码），手工制作ROP（Return-Oriented Programming一种利用特殊返回指令不断返回多个前一段指令而最终拼成一段有效逻辑代码，以达到特殊攻击目的的编程技术）工具链以及调试ARM程序就要了解ARM汇编。</p><p>你不需要了解逆向工程或应用开发方面所有的汇编语言细节，你只需要了解一个大概。基础的知识都会在本教程中讲到，如果你想要了解更多可以参考文末的附加链接。</p><p>那么究竟什么是汇编语言？汇编语言你可以看成是包裹在机器码上的的一层薄薄的语法糖指令，这些指令代表着只有机器（计算机）才能读懂的二进制码。那么为什么不直接写机器码呢？好吧，如果那样做的话你绝对会很蛋疼。所以你最好还是写汇编，人能够容易读懂的ARM汇编。计算机不能运行汇编代码，它只能读懂机器码。我们要使用工具来将汇编代码转换为机器码。GNU汇编器<code>as</code>为我们提供了这样的功能，可以识别*.s类型的源代码文件。</p><p>当你编写完扩展名*.s的汇编源文件后，要用<code>as</code>编译然后用<code>ld</code>链接：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ as program.s <span class="token parameter variable">-o</span> program.o$ ld program.o <span class="token parameter variable">-o</span> program<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/learn/arm-asm/v2-f4e7f04b38f34f4d294e48815910b5e2_b.gif"></p><h1 id="探秘汇编语言"><a href="#探秘汇编语言" class="headerlink" title="探秘汇编语言"></a>探秘汇编语言</h1><p>现在我们从最底层的工作做起。在最底层是电路板上的电信号，电信号是切换两个不同的电平产生的，0V(off)或者5V(on)。因为很容易地看到电路的电平变化，所以我们可以通过可视化数字0和1的表示来匹配电压的开关模式，不仅是因为0/1可以代表电信号的缺失和出现，还因为0/1是二进制系统里数字。然后用一系列0/1组成机器码指令在计算机处理器中运行。下面就是一个机器语码指令。</p><p><code>1110 0001 1010 0000 0010 0000 0000 0001</code></p><p>很好，但是我们难以记得这些0/1组合的代表什么意思。因此我们使用叫做助记符的东西来帮助我们记忆这些二进制组合，每个二进制机器码给定一个名字。这些助记符通常包含三段字符，但不全是。这种程序被叫做汇编语言程序，它使用一系列助记符代表计算机机器码。指令中的<strong>操作数</strong>放在助记符之后。例如：</p><p>现在我们知道了汇编程序是由叫做助记符的文本信息组成的，我们需要把它转换为机器码。前面提到的，GNU Binutils项目为我们提供了叫做<code>as</code>的汇编工具。使用<code>as</code>把ARM汇编语言转换为ARM机器码的过程就叫做汇编。</p><p>综上，计算机能够理解（回应）电信号的缺失和出现，并且我们可以将这一系列电信号表示成一组0/1序列（bits)。我们就可以用机器码（一系列电信号）让计算机根据一种定义好的行为做出反应。因为我们难以记忆这一串0/1组成的指令的意义，所以提供了一种助记来代表这些指令。这组助记符是计算机的汇编语言，我们使用名为”汇编器”的程序将代码从助记符表示形式转换为计算机可读的计算机代码，就像编译器对高级语言代码做的一样。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a><strong>扩展阅读</strong></h1><ol><li> Whirlwind Tour of ARM Assembly. <a href="https://www.coranac.com/tonc/text/asm.htm">https://www.coranac.com/tonc/text/asm.htm</a></li><li> ARM assembler in Raspberry Pi. <a href="http://thinkingeek.com/arm-assembler-raspberry-pi/">http://thinkingeek.com/arm-assembler-raspberry-pi/</a></li><li> Practical Reverse Engineering: x86, x64, ARM, Windows Kernel, Reversing Tools, and Obfuscation by Bruce Dang, Alexandre Gazet, Elias Bachaalany and Sebastien Josse.</li><li> ARM Reference Manual. <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0068b/index.html">http://infocenter.arm.com/help/topic/com.arm.doc.dui0068b/index.html</a></li><li> Assembler User Guide. <a href="http://www.keil.com/support/man/docs/armasm/default.htm">http://www.keil.com/support/man/docs/armasm/default.htm</a> </li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编(5)-OC反汇编</title>
      <link href="/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(5)-OC%E5%8F%8D%E6%B1%87%E7%BC%96.html"/>
      <url>/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(5)-OC%E5%8F%8D%E6%B1%87%E7%BC%96.html</url>
      
        <content type="html"><![CDATA[<p>OC代码的精髓其实就是<code>objc_msgSend</code>。而OC的反汇编其实就是查看其中的方法调用。</p><p>objc_msgSend有两个参数，第一个是id类型，第二个是SEL类型。id、SEL其实都是一个结构体，内部有isa指针，所以这两个在内存中占有8个字节。</p><h1 id="1-OC汇编"><a href="#1-OC汇编" class="headerlink" title="1. OC汇编"></a>1. OC汇编</h1><p>声明一个Person类，并添加两个属性，一个类方法。</p><pre class="line-numbers language-none"><code class="language-none">@interface Person : NSObject@property(nonatomic, copy) NSString * name;@property(nonatomic, assign) int age;+(instancetype)person;@end@implementation Person+ (instancetype)person &#123;    return [[self alloc] init];&#125;@endint main(int argc, char * argv[]) &#123;    Person * p &#x3D; [Person person];    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>放在main函数里，直接调用类方法，生成一个临时变量。<br>打上断点，直接在汇编模式下进行debug。</p><pre class="line-numbers language-none"><code class="language-none">Demo&#96;main:    ...    ...    0x10405a16c &lt;+24&gt;:  adrp   x8, 3    0x10405a170 &lt;+28&gt;:  add    x8, x8, #0x648            ; &#x3D;0x648 -&gt;  0x10405a174 &lt;+32&gt;:  ldr    x0, [x8]    0x10405a178 &lt;+36&gt;:  adrp   x8, 3    0x10405a17c &lt;+40&gt;:  add    x8, x8, #0x638            ; &#x3D;0x638     0x10405a180 &lt;+44&gt;:  ldr    x1, [x8]    0x10405a184 &lt;+48&gt;:  bl     0x10405a4d4               ; symbol stub for: objc_msgSend    0x10405a188 &lt;+52&gt;:  mov    x29, x29    0x10405a18c &lt;+56&gt;:  bl     0x10405a4f8               ; symbol stub for: objc_retainAutoreleasedReturnValue    0x10405a190 &lt;+60&gt;:  add    x8, sp, #0x8              ; &#x3D;0x8     0x10405a194 &lt;+64&gt;:  str    x0, [sp, #0x8]    0x10405a198 &lt;+68&gt;:  stur   wzr, [x29, #-0x4]    0x10405a19c &lt;+72&gt;:  mov    x0, x8    0x10405a1a0 &lt;+76&gt;:  mov    x8, #0x0    0x10405a1a4 &lt;+80&gt;:  mov    x1, x8    0x10405a1a8 &lt;+84&gt;:  bl     0x10405a510               ; symbol stub for: objc_storeStrong    ...    ...  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里隐藏了开辟栈空间和回收相关的代码。</p><p><code>objc_msgSend</code>需要两个参数id和SEL，从上面的代码可以初步判断两个参数的值分别在x0、x1寄存器中。</p><p>首先我们看一下x0寄存器中的数据。按照老方法，adrp计算x8的地址是<code>0x010405d648</code>。x0的值存放在<code>0x010405d648</code>所指向的内存中。</p><pre class="line-numbers language-none"><code class="language-none">(lldb) po 0x010405d648&lt;Person: 0x10405d648&gt;(lldb) x 0x010405d6480x10405d648: 30 d7 05 04 01 00 00 00 68 d6 05 04 01 00 00 00  0.......h.......0x10405d658: 08 00 00 00 08 00 00 00 10 00 00 00 08 00 00 00  ................(lldb) po 0x010405d730Person<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们确定了第一个参数是Person类。在看第二个参数：</p><pre class="line-numbers language-none"><code class="language-none">(lldb) x 0x10405d6380x10405d638: 05 3d 42 8f 01 00 00 00 00 00 00 00 00 00 00 00  .&#x3D;B.............0x10405d648: 30 d7 05 04 01 00 00 00 68 d6 05 04 01 00 00 00  0.......h.......(lldb) po (SEL)0x018f423d05&quot;person&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有毛病，就是一个方法<code>person</code>。</p><p>不同的系统版本，实现的汇编是不一样，iOS11下，汇编对objc_alloc进行了优化，但是没有对init处理。</p><p>iOS14 ：没有消息发送，直接objc_alloc_init<br>iOS11 ： 一次消息发送，objc_alloc, objc_msgSend(self, init)<br>iOS9 ： 两次消息发送，objc_msgSend(alloc),objc_msgSend(self, init)</p><h2 id="1-1-objc-storeStrong"><a href="#1-1-objc-storeStrong" class="headerlink" title="1.1 objc_storeStrong"></a>1.1 objc_storeStrong</h2><p>这里还看到一个这个东西，这个设计到oc源码的逻辑，我们稍微看一下。</p><pre class="line-numbers language-none"><code class="language-none">void objc_storeStrong(id *location, id obj)&#123;    id prev &#x3D; *location;    if (obj &#x3D;&#x3D; prev) &#123;        return;    &#125;    objc_retain(obj);    *location &#x3D; obj;    objc_release(prev);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个函数需要两个参数，第一个是id *类型，这就是一个地址，第二个是id类型。我们反过来看汇编代码，看这两个变量，正常来说还是在x0、x1寄存器中。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; x8中存地址0x10405a190 &lt;+60&gt;:  add    x8, sp, #0x8              ; &#x3D;0x8 &#x2F;&#x2F; 把x0寄存器的值放在x8中。0x10405a194 &lt;+64&gt;:  str    x0, [sp, #0x8]&#x2F;&#x2F; 把0存起来0x10405a198 &lt;+68&gt;:  stur   wzr, [x29, #-0x4]&#x2F;&#x2F; x0 &#x3D; x8，是一个地址。0x10405a19c &lt;+72&gt;:  mov    x0, x8&#x2F;&#x2F; x8置空0x10405a1a0 &lt;+76&gt;:  mov    x8, #0x0&#x2F;&#x2F; x1 &#x3D; 00x10405a1a4 &lt;+80&gt;:  mov    x1, x8&#x2F;&#x2F; 这里x0是一个地址， x1是个nil，两个变量0x10405a1a8 &lt;+84&gt;:  bl     0x10405a510  ; symbol stub for: objc_storeStrong<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过分析汇编，objc_storeStrong两个变量分别是一个地址，一个是nil。然后看一些源码。</p><pre class="line-numbers language-none"><code class="language-none">void objc_storeStrong(id *location, id obj)&#123;    &#x2F;&#x2F; location有值， obj &#x3D; nil    id prev &#x3D; *location;    &#x2F;&#x2F; 不相等    if (obj &#x3D;&#x3D; prev) &#123;        return;    &#125;    &#x2F;&#x2F; 对nil进行retain    objc_retain(obj);    &#x2F;&#x2F; 寻址之后置空，也就是把id对象置空    *location &#x3D; obj;    &#x2F;&#x2F; 释放    objc_release(prev);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以这个函数不仅仅只是用来强引用的，还可以进行释放操作，在这里就是一个很明显的例子。</p><h2 id="1-2-属性"><a href="#1-2-属性" class="headerlink" title="1.2 属性"></a>1.2 属性</h2><p>我们在mian函数中，对实例对象p的两个属性进行赋值。</p><pre class="line-numbers language-none"><code class="language-none">int main(int argc, char * argv[]) &#123;    Person * p &#x3D; [Person person];    p.name &#x3D; @&quot;name&quot;;    p.age &#x3D; 18;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在真机上执行一下，然后我们使用之前的Hopper工具进行看一下。</p><p><img src="/images/learn/arm-asm/arm-5-property.jpg"></p><p>这里就很详细的标注了整个内容，看起来比读汇编代码省事很多。</p><h2 id="3-block的汇编"><a href="#3-block的汇编" class="headerlink" title="3. block的汇编"></a>3. block的汇编</h2><p>在main函数中直接声明一个栈区的block，全局区的也是一样的道理。</p><pre class="line-numbers language-none"><code class="language-none">int a &#x3D; 10;void(^block)(void) &#x3D; ^() &#123;    NSLog(@&quot;block--%d&quot;,a);&#125;;    block();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后真机上运行。这里省去了很大一部分的代码，只拿了关键部分的逻辑。</p><pre class="line-numbers language-none"><code class="language-none">Demo&#96;main:    0x10052a0cc &lt;+36&gt;:  adrp   x10, 2    0x10052a0d0 &lt;+40&gt;:  ldr    x10, [x10]-&gt;  0x10052a0d4 &lt;+44&gt;:  str    x10, [sp, #0x8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>先获取x10寄存器的值，也就是<code>0x10052c000</code>,lldb调试一下：</p><pre class="line-numbers language-none"><code class="language-none">(lldb) x 0x10052c0000x10052c000: 20 9a 44 29 02 00 00 00 0c c8 66 ef 01 00 00 00   .D)......f.....0x10052c010: 18 a5 52 00 01 00 00 00 24 a5 52 00 01 00 00 00  ..R.....$.R.....&#x2F;&#x2F; 这是一个栈block(lldb) po 0x10052c000&lt;__NSStackBlock__: 0x10052c000&gt;&#x2F;&#x2F; 这里拿到的是0x10052c010地址指向的内存区域，这个就是block的invoke。(lldb) dis -s 0x010052a518    0x10052a518: ldr    w16, 0x10052a520    0x10052a51c: b      0x10052a500    0x10052a520: udf    #0x0    0x10052a524: ldr    w16, 0x10052a52c    0x10052a528: b      0x10052a500    0x10052a52c: udf    #0xd    0x10052a530: ldr    w16, 0x10052a538    0x10052a534: b      0x10052a500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里看一下block的源码：</p><pre class="line-numbers language-none"><code class="language-none">struct Block_layout &#123;    void *isa;      &#x2F;&#x2F; 8个字节    volatile int32_t flags; &#x2F;&#x2F; contains ref count   &#x2F;&#x2F;4个字节    int32_t reserved;   &#x2F;&#x2F; 4个字节    BlockInvokeFunction invoke;    struct Block_descriptor_1 *descriptor;    &#x2F;&#x2F; imported variables&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>block也是一个结构体，invoke所在的位置，就是isa之后的16个字节。所以我在内存中取的invoke的实现就是偏移了0x10。</p><p>接下来，我们用hopper看一下:</p><p><img src="/images/learn/arm-asm/arm-5-block.jpg"></p><p><img src="/images/learn/arm-asm/arm-5-block-invoke.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> DISASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编(4)-指针</title>
      <link href="/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(4)-%E6%8C%87%E9%92%88.html"/>
      <url>/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(4)-%E6%8C%87%E9%92%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-指针"><a href="#1-指针" class="headerlink" title="1. 指针"></a>1. 指针</h1><blockquote><p>指针也就是内存地址，指针变量是用来存放内存地址的变量。不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。<br>可使用 &amp; 运算符访问地址。</p></blockquote><p>之前的文章中有过说明，指针在内存中占8个字节。<br>可以是用sizeof来打印指针的size。</p><pre class="line-numbers language-none"><code class="language-none">void func() &#123;    int *a;    a &#x3D; (int *)100;    a ++;    printf(&quot;%d&quot;, a);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里定义一个int类型的指针a，然后赋值位100，我们知道指针的size是8个字节，a++之后打印多少？</p><p>答案是104。是的，没有看错，这里是因为指针的自增和自减操作，与执行的数据类型的宽度有关。</p><p>如果<code>a = (char *)100</code>,则打印的就是101。</p><pre class="line-numbers language-none"><code class="language-none">void func() &#123;    int *a;    a &#x3D; (int *)100;    a &#x3D; a + 1;    printf(&quot;%d&quot;, a);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个不是指针的自增、自减了，这个时候就跟指针的size有关了，打印108。</p><pre class="line-numbers language-none"><code class="language-none">void func_add() &#123;    int *a;    a &#x3D; (int *)100;        int *b;    b &#x3D; (int *)200;        int x &#x3D; a - b;    printf(&quot;x &#x3D; %d&quot;, x);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先说答案，打印的结果是<code>x = -25</code>。</p><p>a - b = -100, 然后除以4就得到了这个结果。</p><blockquote><p>指针的运算单位是执行的数据类型的宽度。</p></blockquote><h2 id="1-1-二级指针"><a href="#1-1-二级指针" class="headerlink" title="1.1 二级指针"></a>1.1 二级指针</h2><pre class="line-numbers language-none"><code class="language-none">void func() &#123;    int **a;    a &#x3D; (int **)100;    a &#x3D; a + 1;    printf(&quot;%d&quot;, a);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候a运算时，执行的类型就是 <code>char *</code>类型，这是一个指针，8个字节。所以结果就是108。</p><h1 id="2-指针的汇编"><a href="#2-指针的汇编" class="headerlink" title="2. 指针的汇编"></a>2. 指针的汇编</h1><pre class="line-numbers language-none"><code class="language-none">void func() &#123;    int *a;    int b &#x3D; 10;    a &#x3D; &amp;b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照我们正常的理解，上述代码的意思就是把b的地址给到a，这个时候<code>*a=10</code>。</p><p>看一下上面的代码汇编之后是什么样子的。</p><pre class="line-numbers language-none"><code class="language-none">Demo&#96;func:    0x100206130 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10     &#x2F;&#x2F; 1. x8 &#x3D; sp + 0x4，x8指向这个位置    0x100206134 &lt;+4&gt;:  add    x8, sp, #0x4              ; &#x3D;0x4     &#x2F;&#x2F; 2. 局部变量，w9&#x3D;10    0x100206138 &lt;+8&gt;:  mov    w9, #0xa    &#x2F;&#x2F; 3. 把w9的值放在x8所在的地址上。    0x10020613c &lt;+12&gt;: str    w9, [sp, #0x4]    &#x2F;&#x2F; 4. 把x8存储的地址放在sp + 0x8的位置上。-&gt;  0x100206140 &lt;+16&gt;: str    x8, [sp, #0x8]    0x100206144 &lt;+20&gt;: add    sp, sp, #0x10             ; &#x3D;0x10     0x100206148 &lt;+24&gt;: ret    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过lldb打印一下相关数据：</p><pre class="line-numbers language-none"><code class="language-none">(lldb) register read sp      sp &#x3D; 0x000000016fbff880(lldb) register read x8      x8 &#x3D; 0x000000016fbff884   (lldb) register read x9      x9 &#x3D; 0x000000000000000a&#x2F;&#x2F; 打印一下x8寄存器里的内存地址情况，里头存的值是0xa(lldb) x 0x000000016fbff8840x16fbff884: 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................0x16fbff894: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................   &#x2F;&#x2F; x8的地址放在了sp+0x8的位置，打印一下内存，就是x8存储的地址。(lldb) x 0x000000016fbff8880x16fbff888: 84 f8 bf 6f 01 00 00 00 00 00 00 00 00 00 00 00  ...o............0x16fbff898: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2><pre class="line-numbers language-none"><code class="language-none">void func() &#123;    int arr[5] &#x3D; &#123;1,2,3,4,5&#125;;    for (int i &#x3D; 0; i &lt; 5; i++) &#123;        printf(&quot;%d\n&quot;, *(arr + i));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-野指针"><a href="#2-2-野指针" class="headerlink" title="2.2 野指针"></a>2.2 野指针</h2><pre class="line-numbers language-none"><code class="language-none">void func() &#123;    char *p;    char a &#x3D; *p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过代码，我们知道，只是把*p的值给了a<br>为什么会发生野指针呢？</p><pre class="line-numbers language-none"><code class="language-none">Demo&#96;func:    0x100812134 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10     &#x2F;&#x2F; 1. 因为p是指针。把sp + 0x8的地址中的值给x8-&gt;  0x100812138 &lt;+4&gt;:  ldr    x8, [sp, #0x8]    &#x2F;&#x2F; 2. 把x8寄存器中存的地址的值给w9    0x10081213c &lt;+8&gt;:  ldrb   w9, [x8]    0x100812140 &lt;+12&gt;: strb   w9, [sp, #0x7]    0x100812144 &lt;+16&gt;: add    sp, sp, #0x10             ; &#x3D;0x10     0x100812148 &lt;+20&gt;: ret    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li> 第一步寻址操作，获取x8寄存器的值的地址</li></ol><pre class="line-numbers language-none"><code class="language-none">(lldb) register read sp      sp &#x3D; 0x000000016f5f3880&#x2F;&#x2F; sp + 0x8 &#x3D; 0x000000016f5f3888(lldb) x 0x000000016f5f38880x16f5f3888: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................0x16f5f3898: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................(lldb) register read x8  x8 &#x3D; 0x0000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>这里发现 x8寄存器中存的地址是空，全是0。</code></pre><ol start="2"><li>把x8寄存器中地址所在的值给w9。寻址操作<br> 这里寻址是从0x00000000上找值，从空地址上找值，就会发生crash。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> DISASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编(3)-状态寄存器</title>
      <link href="/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(3)-%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8.html"/>
      <url>/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(3)-%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-状态寄存器"><a href="#1-状态寄存器" class="headerlink" title="1. 状态寄存器"></a>1. 状态寄存器</h1><p>CPU内部的寄存器中,有一种特殊的寄存器(对于不同的处理器,个数和结构都可能不同)。这种寄存器在ARM中，被称为状态寄存器就是CPSR(current program status register)寄存器。</p><p>CPSR和其他寄存器不一样,其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而CPSR寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p><blockquote><p>CPSR寄存器是32位的。</p></blockquote><ul><li>  CPSR的低8位（包括I、F、T和M[4：0]）称为控制位，程序无法修改,除非CPU运行于特权模式下,程序才能修改控制位!</li><li>  N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行！</li></ul><p><img src="/images/learn/arm-asm/status-register.jpeg"></p><h2 id="1-1-N-（Negative）"><a href="#1-1-N-（Negative）" class="headerlink" title="1.1 N （Negative）"></a>1.1 N （Negative）</h2><p>cpsr的第31位是N，它记录相关指令执行后的结果，结果是负数，则N=1，非负数则N=0。</p><blockquote><p>在ARM64的指令集中，逻辑运算或者算数运算（add、sub、or等）指令的执行会影响状态寄存器的值。</p></blockquote><p>n=1：结果是负数<br>n=0：结果位非负数，包括0</p><h2 id="1-2-Z（Zero）"><a href="#1-2-Z（Zero）" class="headerlink" title="1.2 Z（Zero）"></a>1.2 Z（Zero）</h2><p>cpsr的第30位是Z，0标志位。它记录相关指令执行后其结果是否为。如果结果为0，那么Z = 1；如果结果不为0，那么Z = 0.</p><p>z=1：结果为0<br>z=0：结果不为0</p><h2 id="1-3-C（Carry）"><a href="#1-3-C（Carry）" class="headerlink" title="1.3 C（Carry）"></a>1.3 C（Carry）</h2><p>cpsr第29位是c进位标志位，一般情况进行下无符号述的运算。</p><p>加法运算：当运算结果产生了进位时（无符号数溢出）c=1，没有溢出c=0<br>减法运算：包括（CPM）当运算时产生了借位（无符号数溢出），c=0，没有溢出c=1</p><h3 id="1-3-1-进位"><a href="#1-3-1-进位" class="headerlink" title="1.3.1 进位"></a>1.3.1 进位</h3><p>两个数据相加，比如正常的十进制运算，5+5=10，向十位数进1，个位数为0。但是超过其最大的位数时，发生溢出，导致进位的值无法保存，也就是说进位的值丢失了。但是CPU在运算的时候，并不会丢弃这个进位的值，二手放在寄存器里了，也就是cpsr的c位。</p><h3 id="1-3-2-借位"><a href="#1-3-2-借位" class="headerlink" title="1.3.2 借位"></a>1.3.2 借位</h3><p>两个数据做减法操作，有可能向更高位借位。比如：10-5=5，各位不够减，需要向十位去借。这时候会用c位来标记借位。</p><h2 id="1-4-V（Overflow）"><a href="#1-4-V（Overflow）" class="headerlink" title="1.4 V（Overflow）"></a>1.4 V（Overflow）</h2><p>cpsr的第28位是V，溢出标志位。在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出。</p><ul><li>  正数 + 正数 = 负数。溢出</li><li>  负数 + 负数 = 正数。溢出</li><li>  正数 + 负数 不可能发生溢出</li></ul><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h2><p>NZ：是否为0，判断正负<br>CV：无符号，有符号判断是否溢出</p><h1 id="2-全局变量、常量"><a href="#2-全局变量、常量" class="headerlink" title="2. 全局变量、常量"></a>2. 全局变量、常量</h1><p>开始这一节之前，先知道我们的内存分区划分：</p><p>代码区：存放代码，可读，可执行<br>栈区：参数、局部变量、临时数据，可读可写<br>堆区：动态申请，可读可写</p><p>全局变量：可读可写<br>常量区：只读</p><p>接下来，我们分析代码：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 定义一个全局变量int g &#x3D; 12;&#x2F;&#x2F; 定义一个方法int func(int a,int b)&#123;    &#x2F;&#x2F; &#39;haha&#39;就是一个常量，在常量区    printf(&quot;haha&quot;);    &#x2F;&#x2F; 局部变量c    int c &#x3D; a + g + b;    return c;&#125;int main(int argc, char * argv[]) &#123;       func(10, 20);        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行之后，走汇编流程，进行查看</p><pre class="line-numbers language-none"><code class="language-none">Demo&#96;func:-&gt;  0x100bc211c &lt;+0&gt;:  sub    sp, sp, #0x20             ; &#x3D;0x20     0x100bc2120 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]    0x100bc2124 &lt;+8&gt;:  add    x29, sp, #0x10            ; &#x3D;0x10     0x100bc2128 &lt;+12&gt;: stur   w0, [x29, #-0x4]    0x100bc212c &lt;+16&gt;: str    w1, [sp, #0x8]    0x100bc2130 &lt;+20&gt;: adrp   x0, 1    0x100bc2134 &lt;+24&gt;: add    x0, x0, #0xf9f            ; &#x3D;0xf9f     &#x2F;&#x2F; ① 这里执行了printf操作，大致可以判断，x0中存的就是&#39;haha&#39;    0x100bc2138 &lt;+28&gt;: bl     0x100bc25b0               ; symbol stub for: printf    0x100bc213c &lt;+32&gt;: ldur   w8, [x29, #-0x4]    &#x2F;&#x2F; ② 这里获取的是全局变量    0x100bc2140 &lt;+36&gt;: adrp   x9, 3    0x100bc2144 &lt;+40&gt;: add    x9, x9, #0x648            ; &#x3D;0x648     0x100bc2148 &lt;+44&gt;: ldr    w10, [x9]    0x100bc214c &lt;+48&gt;: add    w8, w8, w10    0x100bc2150 &lt;+52&gt;: ldr    w10, [sp, #0x8]    0x100bc2154 &lt;+56&gt;: add    w8, w8, w10    0x100bc2158 &lt;+60&gt;: str    w8, [sp, #0x4]    0x100bc215c &lt;+64&gt;: ldr    w8, [sp, #0x4]    0x100bc2160 &lt;+68&gt;: mov    x0, x8    0x100bc2164 &lt;+72&gt;: ldp    x29, x30, [sp, #0x10]    0x100bc2168 &lt;+76&gt;: add    sp, sp, #0x20             ; &#x3D;0x20     0x100bc216c &lt;+80&gt;: ret  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①这里执行了printf操作，这里看一些是否真的打印了’haha’。我们追一下x0寄存器的变化。</p><pre class="line-numbers language-none"><code class="language-none">0x100bc2130 &lt;+20&gt;: adrp   x0, 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里有一个关键字需要注意一下：<br>adrp: 针对address page操作<br>这一行代码有三个操作：</p><ol><li> 将1左移12位（即在1后加3个0变成1000）</li><li> 将当前寄存器的地址的低12位清0，即当前行的地址的后3位清0。0x1002b2184 -&gt; 0x100bc2130</li><li> 把0x1000+0x100bc2000赋值给x0，x0=0x100bc3000，即当前行地址的倒数第4位与x0后面的数字相加</li></ol><p>说白了，这句代码的意思就是找到某一页地址的开始。我们走断点，打印一下x0.</p><pre class="line-numbers language-none"><code class="language-none">(lldb) register read x0x0 &#x3D; 0x0000000100bc3000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下一句的代码是，<code>add x0, x0, #0xf9f</code>，就x0的地址+0x0xf9f<br>获取x0的值位0x100bc3f9f</p><pre class="line-numbers language-none"><code class="language-none">(lldb) register read x0x0 &#x3D; 0x0000000100bc3f9f  &quot;haha&quot;(lldb) x 0x0000000100bc3f9f0x100bc3f9f: 68 61 68 61 00 01 00 00 00 1c 00 00 00 02 00 00  haha............0x100bc3faf: 00 24 00 00 00 00 00 00 00 24 00 00 00 02 00 00  .$.......$......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们知道’h’的ASCII码是97，对应的16进制就行0x61，’a’是0x68。就是我们的常量’haha’。</p><p>这样也就拿到了常量的值。<br>需要注意的是，我们的常量是在编译的时候就已经确定了地址。这里通过当前寄存器的地址为参照，偏移一定的值来获取常量所在的页数。</p><p>那继续看一下全局变量</p><pre class="line-numbers language-none"><code class="language-none">0x100bc2140 &lt;+36&gt;: adrp   x9, 30x100bc2144 &lt;+40&gt;: add    x9, x9, #0x648            ; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们使用相同的方式，打印一下x9的值。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; adrp的断点(lldb) register read x9x9 &#x3D; 0x0000000100bc5000  &#x2F;&#x2F; add 的断点lldb) register read x9x9 &#x3D; 0x0000000100bc5648  g  &#x2F;&#x2F; 这里拿到的是变量g，而g在内存中的值是0c(lldb) x 0x0000000100bc56480x100bc5648: 0c 00 00 00 0c 00 00 00 38 5e 44 29 02 00 00 00  ........8^D)....0x100bc5658: f0 33 bc 00 01 00 00 00 d0 4f bc 00 01 00 00 00  .3.......O......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以通过相同的方式获取全局变量的值，g=12。</p><p>所以局部变量和全局变量都是通过adrp以当前寄存器的地址为参照来查找address来获取值的。</p><h2 id="2-1-汇编还原高级语言"><a href="#2-1-汇编还原高级语言" class="headerlink" title="2.1 汇编还原高级语言"></a>2.1 汇编还原高级语言</h2><p>这里使用一个牛逼的工具Hopper，可以查看对应的方法转化成汇编之后的代码。</p><ol><li> build成功之后，在我们的工程里有一个’Products’文件，里头有对应的<code>xxx.app</code>。</li><li> 点击show in finder，找到对应的app，右键显示包内容。</li><li> 找到与项目同名的黑乎乎的东西（可执行文件），直接拖到Hopper里头就可以了。</li></ol><p>我们找到对应的方法func</p><pre class="line-numbers language-none"><code class="language-none">_func:000000010000611c         sub        sp, sp, #0x20    ; CODE XREF&#x3D;_main+320000000100006120         stp        x29, x30, [sp, #0x10]0000000100006124         add        x29, sp, #0x10&#x2F;&#x2F; 这里我们可以知道有两个变量，w0、w1分别存起来0000000100006128         stur       w0, [x29, #-0x4]000000010000612c         str        w1, [sp, #0x8]&#x2F;&#x2F; adrp操作，获取页数0000000100006130         adrp       x0, #0x100007000 ; argument #1 for method imp___stubs__printf&#x2F;&#x2F; 这里直接把结果给出来了。haha存放在x00000000100006134         add        x0, x0, #0xf9f   ; &quot;haha&quot;&#x2F;&#x2F; 执行printf0000000100006138         bl         imp___stubs__printf&#x2F;&#x2F; 取值，这个位置的值就是w0000000010000613c         ldur       w8, [x29, #-0x4]&#x2F;&#x2F; adrp操作，根据页数获取值0000000100006140         adrp       x9, #0x100009000&#x2F;&#x2F; 获取变量_g。我们可以通过地址去找对应的值。可以在Hopper中找到对应的值0000000100006144         add        x9, x9, #0x648   ; _g&#x2F;&#x2F; 赋值w10 &#x3D; _g 0000000100006148         ldr        w10, x9&#x2F;&#x2F; 执行加法操作 w8 +&#x3D; w10000000010000614c         add        w8, w8, w10&#x2F;&#x2F; 取值。也就是获取第二个参数的值w10000000100006150         ldr        w10, [sp, #0x8]&#x2F;&#x2F; 执行加法操作 w8 +&#x3D; w100000000100006154         add        w8, w8, w10&#x2F;&#x2F; 把w8的值存起来0000000100006158         str        w8, [sp, #0x4]&#x2F;&#x2F; 取值w8000000010000615c         ldr        w8, [sp, #0x4]&#x2F;&#x2F; 把w8的值给x0（x0存放返回值）0000000100006160         mov        x0, x8&#x2F;&#x2F; 释放内存，return0000000100006164         ldp        x29, x30, [sp, #0x10]0000000100006168         add        sp, sp, #0x20000000010000616c         ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>汇编的代码逻辑已经直接表示出来了。最终可以得出一个函数的方法</p><pre class="line-numbers language-none"><code class="language-none">int func(int w1, int w2) &#123;    printf(&quot;haha&quot;);    return w1 + _g + w2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-条件判断"><a href="#2-条件判断" class="headerlink" title="2. 条件判断"></a>2. 条件判断</h1><h2 id="2-1-cmp（Compare）比较指令"><a href="#2-1-cmp（Compare）比较指令" class="headerlink" title="2.1 cmp（Compare）比较指令"></a>2.1 cmp（Compare）比较指令</h2><p>cmp把一个寄存器的内容和另一个寄存器的内容（或立即数）进行比较。但不存储结果，只是更改标志。</p><p>一般cmp做完判断后会进行跳转，后面通常会跟上b指令。</p><p>cmp比较，其实是一个减法操作，但是不会改变两个比较的值。通过减法的结果去比较。</p><ul><li>  BL 标号：跳转到标号处执行</li><li>  B.LT 标号：比价结果是<strong>小于（less than）</strong>，执行标号，否则不跳转</li><li>  B.LE 标号：比较结果是<strong>小于等于（less than or qeual to）</strong>，执行标号，否则不跳转</li><li>  B.GT 标号：比较结果是<strong>大于（greater than）</strong>，执行标号，否则不跳转</li><li>  B.GE 标号：比较结果是<strong>大于等于（greater than or equal to）</strong>，执行标号，否则不跳转</li><li>  B.EQ 标号：比较结果是**等于(equal to)**，执行标号，否则不跳转</li><li>  B.NE 标号：比较结果是<strong>不等于（not equal to）</strong>，执行标号，否则不跳转</li><li>  B.LS 标号：比较结果是<strong>无符号小于等于</strong>，执行标号，否则不跳转</li><li>  B.LO 标号：比较结果是<strong>无符号小于</strong>，执行标号，否则不跳转</li><li>  B.HI 标号：比较结果是<strong>无符号大于</strong>，执行标号，否则不跳转</li><li>  B.HS 标号：比较结果是<strong>无符号大于等于</strong>，执行标号，否则不跳转</li></ul><p>b.gt #0x10000f8d:这个地址是else的跳转地址</p><p>知乎上有网友汇总了一张表格，如下：<br><img src="/images/learn/arm-asm/arm-condition.png"></p><h1 id="3-循环"><a href="#3-循环" class="headerlink" title="3. 循环"></a>3. 循环</h1><blockquote><p>使用汇编的时候一定是在真机上运行。或者直接选中真机，直接<code>Command+B</code>buid之后，找到对应的可执行文件，直接放在Hopper里就行。</p></blockquote><h2 id="3-1-do-while"><a href="#3-1-do-while" class="headerlink" title="3.1 do-while"></a>3.1 do-while</h2><pre class="line-numbers language-none"><code class="language-none">void loopFunc() &#123;    int nsum &#x3D; 0;    int i &#x3D; 0;    do &#123;        nsum +&#x3D; 10;        i ++;    &#125; while (i &lt; 100);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看一下汇编下是什么代码逻辑：</p><pre class="line-numbers language-none"><code class="language-none">FunctionDemo&#96;loopFunc:-&gt;  0x102c2a764 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10     &#x2F;&#x2F; 这里是把0放在sp+0xc里头，w：低32位，zr&#x3D;&#x3D;zero    0x102c2a768 &lt;+4&gt;:  str    wzr, [sp, #0xc]   &#x2F;&#x2F; 假设#0xc存的是a    0x102c2a76c &lt;+8&gt;:  str    wzr, [sp, #0x8]   &#x2F;&#x2F; 假设#0x8存的是b,之后用的都是w8，会比较乱    &#x2F;&#x2F; ① 读取a的值    0x102c2a770 &lt;+12&gt;: ldr    w8, [sp, #0xc]    &#x2F;&#x2F; 执行a +&#x3D; 10的操作。    0x102c2a774 &lt;+16&gt;: add    w8, w8, #0xa              ; &#x3D;0x1     &#x2F;&#x2F; 然后把a的值存起来。    0x102c2a778 &lt;+20&gt;: str    w8, [sp, #0xc]    &#x2F;&#x2F; 取值b    0x102c2a77c &lt;+24&gt;: ldr    w8, [sp, #0x8]    &#x2F;&#x2F; b +&#x3D; 1    0x102c2a780 &lt;+28&gt;: add    w8, w8, #0x1              ; &#x3D;0x1     &#x2F;&#x2F; 把b存起来    0x102c2a784 &lt;+32&gt;: str    w8, [sp, #0x8]    0x102c2a788 &lt;+36&gt;: ldr    w8, [sp, #0x8]    &#x2F;&#x2F; 比较b的值，b与100比较    0x102c2a78c &lt;+40&gt;: cmp    w8, #0x64                 ; &#x3D;0x64     &#x2F;&#x2F; 如果 lt（小于）if b &lt; 100 跳转到0x102c2a770继续执行。执行①    0x102c2a790 &lt;+44&gt;: b.lt   0x102c2a770               ; &lt;+12&gt; at main.m:22:14    0x102c2a794 &lt;+48&gt;: add    sp, sp, #0x10             ; &#x3D;0x10     0x102c2a798 &lt;+52&gt;: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们直接使用Hopper工具查看汇编，其实比在Xcode中更方便。</p><p><img src="/images/learn/arm-asm/do-while.png"></p><h2 id="3-2-while"><a href="#3-2-while" class="headerlink" title="3.2 while"></a>3.2 while</h2><pre class="line-numbers language-none"><code class="language-none">void whileFunc() &#123;    int i &#x3D; 0;    int nsum &#x3D; 0;    while (i &lt; 10) &#123;        nsum +&#x3D; 10;        i +&#x3D; 1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在Hopper里查看源码：</p><p><img src="/images/learn/arm-asm/while.jpg"></p><p>①处是一个比较，判断w8的值和10的大小，如果<code>b.ge</code>则执行<code>loc_100006128</code>的代码。b.ge是大于等于。<br>②是直接跳转到<code>loc_10000610c</code>的代码。</p><h2 id="3-3-for"><a href="#3-3-for" class="headerlink" title="3.3 for"></a>3.3 for</h2><pre class="line-numbers language-none"><code class="language-none">void forFunc() &#123;    int nsum &#x3D; 0;    for (int i &#x3D; 0; i &lt; 10; i ++) &#123;        nsum +&#x3D; i;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在Hopper里查看源码：</p><p><img src="/images/learn/arm-asm/for.jpg"></p><p>for循环与while循环区别不大。</p><h1 id="4-switch"><a href="#4-switch" class="headerlink" title="4. switch"></a>4. switch</h1><h2 id="4-1-三个case的switch"><a href="#4-1-三个case的switch" class="headerlink" title="4.1 三个case的switch"></a>4.1 三个case的switch</h2><pre class="line-numbers language-none"><code class="language-none">void switchFunc(int a) &#123;    int nsum &#x3D; 0;    switch (a) &#123;        case 1:            printf(&quot;1&quot;);            break;        case 2:            printf(&quot;2&quot;);            break;        case 3:            printf(&quot;3&quot;);            break;        default:            printf(&quot;default&quot;);            break;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是运行xCode，查看汇编源码：</p><pre class="line-numbers language-none"><code class="language-none">Demo&#96;switchFunc:-&gt;  0x100bea0e8 &lt;+0&gt;:   sub    sp, sp, #0x10             ; &#x3D;0x10     0x100bea0ec &lt;+4&gt;:   str    w0, [sp, #0xc]    0x100bea0f0 &lt;+8&gt;:   str    wzr, [sp, #0x8]    0x100bea0f4 &lt;+12&gt;:  ldr    w8, [sp, #0xc]    0x100bea0f8 &lt;+16&gt;:  cmp    w8, #0x1                  ; &#x3D;0x1     0x100bea0fc &lt;+20&gt;:  str    w8, [sp, #0x4]    0x100bea100 &lt;+24&gt;:  b.eq   0x100bea128               ; &lt;+64&gt; at main.m:48:18    0x100bea104 &lt;+28&gt;:  b      0x100bea108               ; &lt;+32&gt; at main.m    0x100bea108 &lt;+32&gt;:  ldr    w8, [sp, #0x4]    0x100bea10c &lt;+36&gt;:  cmp    w8, #0x2                  ; &#x3D;0x2     0x100bea110 &lt;+40&gt;:  b.eq   0x100bea138               ; &lt;+80&gt; at main.m:51:18    0x100bea114 &lt;+44&gt;:  b      0x100bea118               ; &lt;+48&gt; at main.m    0x100bea118 &lt;+48&gt;:  ldr    w8, [sp, #0x4]    0x100bea11c &lt;+52&gt;:  cmp    w8, #0x3                  ; &#x3D;0x3     0x100bea120 &lt;+56&gt;:  b.eq   0x100bea148               ; &lt;+96&gt; at main.m:54:18    0x100bea124 &lt;+60&gt;:  b      0x100bea158               ; &lt;+112&gt; at main.m:60:18    0x100bea128 &lt;+64&gt;:  ldr    w8, [sp, #0x8]    0x100bea12c &lt;+68&gt;:  add    w8, w8, #0x1              ; &#x3D;0x1     0x100bea130 &lt;+72&gt;:  str    w8, [sp, #0x8]    0x100bea134 &lt;+76&gt;:  b      0x100bea164               ; &lt;+124&gt; at main.m:63:1    0x100bea138 &lt;+80&gt;:  ldr    w8, [sp, #0x8]    0x100bea13c &lt;+84&gt;:  add    w8, w8, #0xa              ; &#x3D;0xa     0x100bea140 &lt;+88&gt;:  str    w8, [sp, #0x8]    0x100bea144 &lt;+92&gt;:  b      0x100bea164               ; &lt;+124&gt; at main.m:63:1    0x100bea148 &lt;+96&gt;:  ldr    w8, [sp, #0x8]    0x100bea14c &lt;+100&gt;: add    w8, w8, #0x14             ; &#x3D;0x14     0x100bea150 &lt;+104&gt;: str    w8, [sp, #0x8]    0x100bea154 &lt;+108&gt;: b      0x100bea164               ; &lt;+124&gt; at main.m:63:1    0x100bea158 &lt;+112&gt;: ldr    w8, [sp, #0x8]    0x100bea15c &lt;+116&gt;: subs   w8, w8, #0x1              ; &#x3D;0x1     0x100bea160 &lt;+120&gt;: str    w8, [sp, #0x8]    0x100bea164 &lt;+124&gt;: add    sp, sp, #0x10             ; &#x3D;0x10     0x100bea168 &lt;+128&gt;: ret <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看汇编源码，其实就是简单的if-else比较，只不过这里换成了b.eq(等于)，然后跳转到对应的代码块。</p><h2 id="4-2-四个case的switch"><a href="#4-2-四个case的switch" class="headerlink" title="4.2 四个case的switch"></a>4.2 四个case的switch</h2><pre class="line-numbers language-none"><code class="language-none">void switchFunc(int a) &#123;    int nsum &#x3D; 0;    switch (a) &#123;        case 1:            printf(&quot;1&quot;);            break;        case 2:            printf(&quot;2&quot;);            break;        case 3:            printf(&quot;3&quot;);            break;        case 4:            printf(&quot;4&quot;);            break;        default:            printf(&quot;default&quot;);            break;    &#125;&#125;int main(int argc, char * argv[]) &#123;    switchFunc(4);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们改变一下代码，再加一个case，运行一下：</p><pre class="line-numbers language-none"><code class="language-none">Demo&#96;switchFunc:    0x1005460ac &lt;+0&gt;:   sub    sp, sp, #0x20             ; &#x3D;0x20     0x1005460b0 &lt;+4&gt;:   stp    x29, x30, [sp, #0x10]    0x1005460b4 &lt;+8&gt;:   add    x29, sp, #0x10            ; &#x3D;0x10     &#x2F;&#x2F; 1. 把w0的值存起来，w0 &#x3D; 4    0x1005460b8 &lt;+12&gt;:  stur   w0, [x29, #-0x4]    &#x2F;&#x2F; 2. 把0存起来    0x1005460bc &lt;+16&gt;:  str    wzr, [sp, #0x8]    &#x2F;&#x2F; 3. 取值w8 &#x3D; 4    0x1005460c0 &lt;+20&gt;:  ldur   w8, [x29, #-0x4]    &#x2F;&#x2F; 4. 这里是第一个case 1. w8 &#x3D; w8 - 1 &#x3D; 3    0x1005460c4 &lt;+24&gt;:  subs   w8, w8, #0x1              ; &#x3D;0x1     &#x2F;&#x2F; 5. 把x8的值给x9，x9 &#x3D; 0x0000000000000003    0x1005460c8 &lt;+28&gt;:  mov    x9, x8    &#x2F;&#x2F; 6. 这个ubfx语法，往下翻有详细解释。把x9的高32位清零，x9 &#x3D; 0x0000000000000003    0x1005460cc &lt;+32&gt;:  ubfx   x9, x9, #0, #32    &#x2F;&#x2F; 7. x9的值和3进行比较    0x1005460d0 &lt;+36&gt;:  cmp    x9, #0x3                  ; &#x3D;0x3     &#x2F;&#x2F; 8. 把x9的值放在sp对应的内存地址中    0x1005460d4 &lt;+40&gt;:  str    x9, [sp]    &#x2F;&#x2F; 9. 如果7中比较的结果是一个【无符号大于】，则执行0x100546134，其实就是执行了default操作-&gt;  0x1005460d8 &lt;+44&gt;:  b.hi   0x100546134               ; &lt;+136&gt; at main.m    &#x2F;&#x2F; 10. adrp:地址操作，x8&#x3D;0x100546000，左边的地址标号后12位清零，然后加上0x0000    0x1005460dc &lt;+48&gt;:  adrp   x8, 0    &#x2F;&#x2F; 11. x8 &#x3D; 0x10054614c，然后通过view memory，看里头的值。    0x1005460e0 &lt;+52&gt;:  add    x8, x8, #0x14c            ; &#x3D;0x14c     &#x2F;&#x2F; 12. 取值x11 &#x3D; 3    0x1005460e4 &lt;+56&gt;:  ldr    x11, [sp]    &#x2F;&#x2F; 13. ldrsw：取值，先计算中括号内部x11, lsl #2:意思是x11左移2位，    &#x2F;&#x2F;     然后加上x8获取一个地址，把地址里的值给x10    &#x2F;&#x2F; 3&lt;&lt;2 &#x3D; 二进制数3：11&lt;&lt;2 &#x3D; 1100，也就是十进制12，    &#x2F;&#x2F; x8+12 &#x3D; 0x10054614c+0xc &#x3D; 0x100546158    &#x2F;&#x2F; 这是一个寻址操作，把0x100546158地址的值给x10，    &#x2F;&#x2F; 通过view memory查看x10 &#x3D; 0xffffffd8 &#x3D; -40,是一个负值    0x1005460e8 &lt;+60&gt;:  ldrsw  x10, [x8, x11, lsl #2]    &#x2F;&#x2F; x9 &#x3D; 0x10054614c + (-40) &#x3D; 0x100546124    0x1005460ec &lt;+64&gt;:  add    x9, x8, x10    &#x2F;&#x2F; 执行跳转到 0x100546124    0x1005460f0 &lt;+68&gt;:  br     x9        &#x2F;&#x2F; 从这里开始就是case的位置了。    0x1005460f4 &lt;+72&gt;:  adrp   x0, 1    0x1005460f8 &lt;+76&gt;:  add    x0, x0, #0xf8c            ; &#x3D;0xf8c     0x1005460fc &lt;+80&gt;:  bl     0x100546598               ; symbol stub for: printf    0x100546100 &lt;+84&gt;:  b      0x100546140               ; &lt;+148&gt; at main.m:63:1    0x100546104 &lt;+88&gt;:  adrp   x0, 1    0x100546108 &lt;+92&gt;:  add    x0, x0, #0xf8e            ; &#x3D;0xf8e     0x10054610c &lt;+96&gt;:  bl     0x100546598               ; symbol stub for: printf    0x100546110 &lt;+100&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1    0x100546114 &lt;+104&gt;: adrp   x0, 1    0x100546118 &lt;+108&gt;: add    x0, x0, #0xf90            ; &#x3D;0xf90     0x10054611c &lt;+112&gt;: bl     0x100546598               ; symbol stub for: printf    0x100546120 &lt;+116&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1    &#x2F;&#x2F; 直接跳转到这里，执行adrp操作，获取x0    0x100546124 &lt;+120&gt;: adrp   x0, 1    0x100546128 &lt;+124&gt;: add    x0, x0, #0xf92            ; &#x3D;0xf92     &#x2F;&#x2F; 执行printf操作。    0x10054612c &lt;+128&gt;: bl     0x100546598               ; symbol stub for: printf    0x100546130 &lt;+132&gt;: b      0x100546140               ; &lt;+148&gt; at main.m:63:1    0x100546134 &lt;+136&gt;: adrp   x0, 1    0x100546138 &lt;+140&gt;: add    x0, x0, #0xf94            ; &#x3D;0xf94     0x10054613c &lt;+144&gt;: bl     0x100546598               ; symbol stub for: printf    0x100546140 &lt;+148&gt;: ldp    x29, x30, [sp, #0x10]    0x100546144 &lt;+152&gt;: add    sp, sp, #0x20             ; &#x3D;0x20     0x100546148 &lt;+156&gt;: ret <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现不一样了啊，不是if-else判断了。</p><p><code>0x10092e0e0 &lt;+24&gt;: ubfx x9, x9, #0, #32</code><br>x9寄存器是64位，w8是32位，相当于x9的低32位。<br>这里的目的就是x9从0位开始到32位清零，也就x9的高32位清零然后赋值给x9</p><p><code>b.hi</code> 无符号大于</p><p><code>br x9</code>：b是跳转，br是不影响lr寄存器的跳转。直接跳到x9（x9是一个地址标号）</p><p><code>ldrsw x10, [x8, x11, lsl #2]</code>： 这里先计算中括号内部。而在中括号内部先计算x11。</p><ol><li> lsl表示左移，<code>x11, lsl #2</code>表示x11左移2位。</li><li> 加上x8的值。生成一个新的地址。</li><li> []表示寻址，也就是说把生成的地址中的值给x10。</li></ol><p>看一下我们获取参数是否正确。看一下view memory</p><p><img src="/images/learn/arm-asm/switch-viewmemory.jpg"></p><p>偏移表中为什么存储的是地址的偏移量？为什么不直接存对应的地址？</p><blockquote><p>是因为地址只有在运行的时候才会开辟的，每次运行的值都不一样，所以直接存偏移量，然后通过偏移表的起始位置进行计算就可以直接定位了。</p></blockquote><h3 id="4-2-1-switch-case-偏移表"><a href="#4-2-1-switch-case-偏移表" class="headerlink" title="4.2.1 switch case 偏移表"></a>4.2.1 switch case 偏移表</h3><p>我们看第11. x8 = 0x10054614c，这个地址正好是当前汇编函数的末尾0x100546148+0x4。所以，这个函数栈空间后有一堆数据，存放一些值，这一堆数据就是case创建的偏移表。而这些值就是我们要偏移的值。</p><p>偏移表中的个数是由 (case的最大值 - case的最小值) + 1。看一下上面的图<code>0x10054614c</code>的位置存放的4个值，分别是0xffffffa8=-88, 0xffffffb8=-72, 0xffffffc8=-56, 0xffffffd8=-40</p><p>偏移值是一个负数，是因为是以<code>x8 = 0x10054614c</code>寄存器中存的地址为基数，偏移一个负数得到一个地址，这个地址就是在函数开辟的栈空间内。</p><p>我们通过一张图重新看一下这个过程：</p><p><img src="/images/learn/arm-asm/switch-2.jpg"></p><h2 id="4-3-四个不连续case的switch"><a href="#4-3-四个不连续case的switch" class="headerlink" title="4.3 四个不连续case的switch"></a>4.3 四个不连续case的switch</h2><p>我们知道了，3个连续的case是if-else比较，4个连续的case就不是if-else了，而是会生成一个表。那么4个不连续的case呢？</p><pre class="line-numbers language-none"><code class="language-none">void switchFunc(int a) &#123;    int nsum &#x3D; 0;    switch (a) &#123;        case 1:            printf(&quot;1&quot;);            break;        case 200:            printf(&quot;2&quot;);            break;        case 30:            printf(&quot;3&quot;);            break;        case 4:            printf(&quot;4&quot;);            break;        default:            printf(&quot;default&quot;);            break;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就不在放汇编源码了，4个不连续的case，与3个case一样，也是通过if-else比较来执行代码块的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li> 假设switch语句的分支比较少的时候（例如3，少于4的时候没有意义）没有必要使用此结构，相当于if。</li><li> 各个case分支常量的差值较大的时候，编译器会在效率还是内存进行取舍，这个时候编译器还是会编译成类似于if，else的结构。</li><li> 在分支比较多的时候：在编译的时候会生成一个表（跳转表每个地址四个字节）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> DISASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编(2)-函数</title>
      <link href="/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(2)-%E5%87%BD%E6%95%B0.html"/>
      <url>/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(2)-%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-关于CPU的补充"><a href="#1-关于CPU的补充" class="headerlink" title="1. 关于CPU的补充"></a>1. 关于CPU的补充</h1><h2 id="1-1-寄存器"><a href="#1-1-寄存器" class="headerlink" title="1.1 寄存器"></a>1.1 寄存器</h2><p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p><blockquote><p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p></blockquote><p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p><h2 id="1-2-高速缓存"><a href="#1-2-高速缓存" class="headerlink" title="1.2 高速缓存"></a>1.2 高速缓存</h2><p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p><blockquote><p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个高速缓存存储区域.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p></blockquote><h2 id="1-3-寄存器"><a href="#1-3-寄存器" class="headerlink" title="1.3 寄存器"></a>1.3 寄存器</h2><h3 id="1-3-1-数据地址寄存器"><a href="#1-3-1-数据地址寄存器" class="headerlink" title="1.3.1 数据地址寄存器"></a>1.3.1 数据地址寄存器</h3><p>数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。<br>ARM64中：</p><ul><li>  64位 x0-x30，XZR（零寄存器）</li><li>  32位 w0-w30，WZR（零寄存器）</li></ul><h3 id="1-3-2-浮点和向量寄存器"><a href="#1-3-2-浮点和向量寄存器" class="headerlink" title="1.3.2 浮点和向量寄存器"></a>1.3.2 浮点和向量寄存器</h3><p>因为浮点数的存储以及其运算的特殊性，CPU中专门提供浮点数寄存器来处理浮点数。</p><ul><li>  64位: d0-d31</li><li>  32位: d0-d31</li></ul><p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p><p>向量寄存器 128位:V0-V31</p><h3 id="1-3-3-SP、FP寄存器"><a href="#1-3-3-SP、FP寄存器" class="headerlink" title="1.3.3 SP、FP寄存器"></a>1.3.3 SP、FP寄存器</h3><p>说这两个，需要先说一下栈。</p><p><img src="/images/learn/arm-asm/stack.jpg"></p><p>栈是一种具有特殊的访问方式的存储空间，先进后处，后进先出。(Last In Out First)</p><ul><li>  sp寄存器在任意时刻会保存栈顶的地址。</li><li>  fp寄存器也成为x29寄存器。属于通用寄存器，在默写时刻我们利用它保存栈底的地址。</li></ul><blockquote><p>需要注意的是，ARM64里面对栈的操作是16个字节对齐的。</p></blockquote><p><img src="/images/learn/arm-asm/stack_1.jpg"></p><p>这个图很好的说明了栈是从高地址往低地址开始读写操作的，堆是从低地址向高地址开始的，当栈不断的开辟空间，堆也不断的开辟空间，导致两个区域重叠，就会导致崩溃。也就是常说的堆栈溢出。（堆、栈上的空间是不固定的）</p><p>这里我们说个题外话，是不是所有的死循环都会导致崩溃？答案是否定的，只有不断的开辟空间的死循环才会导致崩溃，上一章我们最后的例子就是很好的说明，因为没有开辟空间。</p><h1 id="2-函数调用栈"><a href="#2-函数调用栈" class="headerlink" title="2. 函数调用栈"></a>2. 函数调用栈</h1><p>以下代码是常见的函数调用开辟和恢复栈空间。</p><pre class="line-numbers language-ARMASM" data-language="ARMASM"><code class="language-ARMASM">sub    sp, sp, #0x40             ; 拉伸0x40（64字节）空间stp    x29, x30, [sp, #0x30]     ; x29, x30 寄存器入栈保护add    x29, sp, #0x30            ; x29指向栈帧的底部... ldp    x29, x30, [sp, #0x30]     ; 恢复x29&#x2F;x30 寄存器的值add    sp, sp, #0x40             ; 栈平衡ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里需要注意的是： 读、写数据都是往高地址读、写。</p></blockquote><h2 id="2-1-内存读写指令"><a href="#2-1-内存读写指令" class="headerlink" title="2.1 内存读写指令"></a>2.1 内存读写指令</h2><ul><li>  str指令：store register，将数据从寄存器中读出来，存在内存中。每次操作8个字节</li><li>  ldr指令：load register，将数据从内存中读出来，存在寄存器中。每次操作8个字节</li><li>  stp指令：str指令的变种，每次操作16个字节。</li><li>  ldp指令：ldr指令的变种，每次操作16个字节。</li></ul><h2 id="2-2-堆栈操作"><a href="#2-2-堆栈操作" class="headerlink" title="2.2 堆栈操作"></a>2.2 堆栈操作</h2><pre class="line-numbers language-ARMASM" data-language="ARMASM"><code class="language-ARMASM">_ABTest:    sub sp, sp, #0x20       ; 开辟栈空间，在当前sp所在的位置减去32个字节。    stp x0, x1, [sp, #0x10] ; 之所以用[],是因为sp存的是一个地址,这里的操作是寻址，把x0，x1的值放在对应的位置，但是栈的读写都是在高位，所以这里还需要加上一个值，写在高位    ldp x1, x0, [sp, #0x10] ; 这里是交换x0，x1的值。注意，当前的操作不会改变sp的值，寄存器中的值进行交换    add sp, sp, #0x20       ; 这里恢复栈空间。    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li> 我们将上面的代码放在“.s”文件中，在ViewControler中声明<code>int ABTest();</code>方法.</li><li> 在viewDidLoad中调用<code>ABTest();</code>，并在这一行打上断点。运行触发断点之后，按住ctrl键的同时点击小箭头，进入汇编，（按住ctrl是为了不让程序执行下一步）</li><li> 在右下命令行中输入<code>register read sp</code>查看当前sp所在的位置，是<code>sp = 0x000000016fbf1290</code></li><li> 点击下一步，开辟栈空间，重复第3步的操作，查看<code>sp = 0x000000016fbf1270</code></li><li> 进入View Memory，定位到sp所在的位置，查看在<code>0x000000016fbf1280</code>位置的值是什么。</li><li> 这个时候，分别执行<code>register write x0 0x0a</code>， <code>register write x1 0x0b</code>，修改x0，x1的值，执行下一步。</li><li> 发现在左边通用寄存器中x0，x1的值已经发生变化。这时候重复第5步操作。查看是否已经发生变化。（需要切换页）</li><li> 执行下一步，交换x0，x1的值。我们发现左边，通用寄存器中x0，x1的值已经发生了变化，这时候重复第5步，查看内存中的值是否有变化？是没有发生变化的哈~</li><li> 销毁当前栈空间。重复第3步，查看当前sp的地址。是<code>sp = 0x000000016fbf1290</code></li></ol><p>如图：</p><p><img src="/images/learn/arm-asm/ABTest.jpg"></p><h1 id="3-bl和ret指令"><a href="#3-bl和ret指令" class="headerlink" title="3. bl和ret指令"></a>3. bl和ret指令</h1><h2 id="3-1-bl"><a href="#3-1-bl" class="headerlink" title="3.1 bl"></a>3.1 bl</h2><p>bl其实存在两个操作：</p><ol><li> 将下一条指令的地址放入lr（x30）寄存器。也就是保存回家的路。</li><li> 转到对应的跳转中执行指令，当指令执行完成后，会根据lr中的地址，返回继续执行。</li></ol><p>通俗的讲就是离家出走了，执行ret的时候，根据lr中的地址，找到回家的路。</p><h2 id="3-2-ret"><a href="#3-2-ret" class="headerlink" title="3.2 ret"></a>3.2 ret</h2><p>默认使用lr（x30）寄存器的值，通过底层指令提示CPU此处作为下条指令地址。这是ARM64平台的特色指令，它面向硬件方面做了优化处理。</p><h2 id="3-3-x30寄存器（lr寄存器）"><a href="#3-3-x30寄存器（lr寄存器）" class="headerlink" title="3.3 x30寄存器（lr寄存器）"></a>3.3 x30寄存器（lr寄存器）</h2><p>x30寄存器存放的是函数的返回地址，当ret指令执行时，会寻找x30寄存器保存的地址值。</p><p>这也就是，为啥上一章，最后的代码会造成循环引用的原因，因为x30寄存器的地址指向的就是当前bl的下一行代码。</p><h2 id="3-4-操作"><a href="#3-4-操作" class="headerlink" title="3.4 操作"></a>3.4 操作</h2><p>我们简写一下上一章的代码</p><pre class="line-numbers language-ARMASM" data-language="ARMASM"><code class="language-ARMASM">_A:    mov x0, 0xaa    bl _B    mov x0, 0xaa    ret_B:    mov x0, #0xbb    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>在ViewDidLoad中执行A()，并打断点。执行上面的代码。按住ctrl键点击小剪头，进入A的汇编。查看当前lr寄存器中存放的地址是谁。然后按照下图所示进行操作，进入ViewDidLoad的汇编。 <img src="/images/learn/arm-asm/viewdidload.jpg"></li><li>我们看到了19行执行了 bl A的操作，也就是在ViewDidLoad中执行A()操作。而lr寄存器所存储的地址就是第20行所在的位置，也就是存储了执行A之后返回ViewDidLoad的地址。0x1003ce56c</li><li>点击继续执行，修改x0寄存器的值，继续下一步。执行bl B</li><li>这时候我们发现lr寄存器中存储的值已经被修改了，变成了A汇编代码中bl B下一行的地址。<code>lr = 0x1003ce904</code>，这里修改了x0的值。</li><li>下一步。继续执行B中的ret操作，发现回到了A，回到了<code>0x1003ce904</code>，继续执行发现修改了x0的值。</li><li>下一步，执行ret，发现又回到了A中的<code>0x1003ce904</code>，不断的执行，发现压根回不去ViewDidLoad了。</li></ol><p>这就是上一章中说的问题，lr寄存器的值被修改了，导致回不去了。那我们应该怎么处理呢？</p><p>最合理的方案是在执行bl操作之前，将bl的下一行地址存放在栈中。如果将值存放在其他寄存器中是绝对不安全的，因为你不知道什么时候就会被系统覆盖。</p><h3 id="3-4-1-解决死循环"><a href="#3-4-1-解决死循环" class="headerlink" title="3.4.1 解决死循环"></a>3.4.1 解决死循环</h3><p>我们为了解决上面的问题，我们查看系统是怎么处理这个问题的。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void c() &#123;    d();    return;&#125;void d() &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样，在ViewDidLoad中执行<code>c()</code>。</p><pre class="line-numbers language-TEXT" data-language="TEXT"><code class="language-TEXT">Demo&#96;c:-&gt;  0x1005464e0 &lt;+0&gt;:  stp    x29, x30, [sp, #-0x10]!    0x1005464e4 &lt;+4&gt;:  mov    x29, sp    0x1005464e8 &lt;+8&gt;:  bl     0x1005464f4               ; d at ViewController.m:38:1    0x1005464ec &lt;+12&gt;: ldp    x29, x30, [sp], #0x10    0x1005464f0 &lt;+16&gt;: ret <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在c的汇编里头，我们仔细看下系统是什么处理lr寄存器的。<br>我们看到了x29和x30两个寄存器。x29是fp寄存器，指向栈底；x30寄存器就是lr寄存器。</p><ol><li> <code>stp x29, x30, [sp, #-0x10]!</code> 这是汇编代码简写的形式的。这句话的意思是sp -= 0x10开辟空间，把x29和x30寄存器的值存放在开辟的空间里。“!”的操作是针对sp的，“[]”的操作是针对x29，x30寻址的。需要注意的是，先存值，在改变sp。</li><li> <code>mov x29, sp</code> 将sp的值赋给x29寄存器。啥意思，fp跟sp指向相同的位置。栈顶栈底指向同一位置，啥情况？之后说哈~</li><li> bl操作，执行d()</li><li> <code>ldp x29, x30, [sp], #0x10</code> 跟第一句差不多，“[]”就是寻址，将sp对应的两个地址的值赋值给x29，x30。第一步是存，这一步是取。然后执行 sp += 0x10的操作，释放栈空间。</li><li> 执行ret操作，我们就能轻松的回到ViewDidLoad了。因为lr寄存器中的地址正是我们一开始存的值。</li></ol><p>在执行的过程中，我们一步步查看lr寄存器的值看是怎么变化的。就能清晰明了了。</p><p>这个时候，我们就可以修改上面的代码了</p><pre class="line-numbers language-ARMASM" data-language="ARMASM"><code class="language-ARMASM">_A:    str x30, [sp, #-0x10]!  ;仿造系统方法，因为x29寄存器暂时没有用处，所以只使用x30。    mov x0, 0xaa    bl _B    mov x0, 0xaa    ldr x30, [sp], #0x10    ret_B:    mov x0, #0xbb    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行该代码，我们按照栈操作3.4的流程，查看整体流程，看x30寄存器存放读取的过程，配合View Memory使用会更爽哈~</p><p>这里把代码做一下修改，在A中<code>str x30, [sp, #-0x8]!</code>将16个字节改成8个字节会怎样？跑一遍试试看</p><p>会发生crash对不对。<strong>因为在ARM64里面，对栈的操作是16个字节对齐的。所以开辟空间操作一定是16字节的倍数来进行的。</strong></p><h1 id="4-函数的参数和返回值"><a href="#4-函数的参数和返回值" class="headerlink" title="4. 函数的参数和返回值"></a>4. 函数的参数和返回值</h1><p>ARM64下，函数的参数是存放在x0-x7(32位w0-w7)这个8个寄存器里面的。如果超过8个参数，就会入栈。<br>函数的返回值是放在x0(32位是w0)寄存器里的。</p><p>这里有一个点，在OC中，一般情况下，定义函数最多可以有几个参数？这里有一个小坑哈~<br>在runtime里，我们知道，函数调用都是通过objc_msgsend来处理的，而这里个里头已经存在了两个默认参数，一个是self，一个obj</p><p>当我们不知道怎么处理带参数的函数时，就看系统是怎么实现的。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;&#x2F; 我们定义一个函数，在viewDidLoad中执行。int sumA(int a, int b) &#123;    return a + b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行之后，按住control点击进汇编：</p><pre class="line-numbers language-TEXT" data-language="TEXT"><code class="language-TEXT">首先我们来到viewDidLoad中，-[ViewController viewDidLoad]:    ; 这里我们有看到赋值，sumA(10+20)，我们看到w0&#x3D;10，w1&#x3D;20    0x104d125d4 &lt;+68&gt;: mov    w0, #0xa              0x104d125d8 &lt;+72&gt;: mov    w1, #0x14-&gt;  0x104d125dc &lt;+76&gt;: bl     0x104d12570               ; sumA at ViewController.m:16  ; 这里有bl指令，继续执行跳转到sumA操作。    0x104d125e0 &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]    0x104d125e4 &lt;+84&gt;: add    sp, sp, #0x30             ; &#x3D;0x30     0x104d125e8 &lt;+88&gt;: ret        ---------------------------------------------------------------------FunctionDemo sumA:-&gt;  0x100d3a4dc &lt;+0&gt;:  sub    sp, sp, #0x10     ; 开辟16个字节的空间    0x100d3a4e0 &lt;+4&gt;:  str    w0, [sp, #0xc]    ; 寻址把w0存放在sp+0xC的位置    0x100d3a4e4 &lt;+8&gt;:  str    w1, [sp, #0x8]    ; 寻址把w1存放在sp+0x8的位置    0x100d3a4e8 &lt;+12&gt;: ldr    w8, [sp, #0xc]    ; 把sp+0xC位置的值给w8    0x100d3a4ec &lt;+16&gt;: ldr    w9, [sp, #0x8]    ; 把sp+0x8位置的值给w9    0x100d3a4f0 &lt;+20&gt;: add    w0, w8, w9        ; 执行加法操作，并赋值给w0    0x100d3a4f4 &lt;+24&gt;: add    sp, sp, #0x10     ; 释放栈空间    0x100d3a4f8 &lt;+28&gt;: ret    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面汇编之后的代码，我们可以看到整个的流程，相当于生成了两个临时量变去存储传进来的值，然后把返回值存储在w0寄存器里。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;&#x2F; 我们定义一个函数，在viewDidLoad中执行。int sumA(int a, int b) &#123;    int a1 &#x3D; 1;     &#x2F;&#x2F; 生成局部变量a1，b1    int b1 &#x3D; b;    return a1 + b1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面系统的实现方案，我们就可以自己写一个带有参数，返回值的方法。在“.s”文件中实现</p><pre class="line-numbers language-ARMASM" data-language="ARMASM"><code class="language-ARMASM">.global _sumB_sumB:    add x0, x0, x1    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2-验证超过8个参数的情况"><a href="#4-2-验证超过8个参数的情况" class="headerlink" title="4.2 验证超过8个参数的情况"></a>4.2 验证超过8个参数的情况</h2><p>多余的参数会存放在调用方法所在的栈空间里，然后在调用的方法里去取别人的栈中存放的参数。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int test(int a, int b, int c, int d, int e, int f, int g, int h, int i) &#123;    return a+b+c+d+e+f+g+h+i;&#125;- (void)viewDidLoad &#123;    [super viewDidLoad];    test(1,2,3,4,5,6,7,8,9);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行代码，我们看汇编之后的代码：</p><pre class="line-numbers language-LIST" data-language="LIST"><code class="language-LIST">-[ViewController viewDidLoad]:...... 这中间省略了一大部分代码，我们直接从这里看    ; 这里打印 sp &#x3D; 0x000000016f4c53c0    0x10093e594 &lt;+64&gt;:  bl     0x10093e9b4               ; symbol stub for: objc_msgSendSuper2      ; 这个是调用super viewDidLoad    0x10093e598 &lt;+68&gt;:  mov    w0, #0x1     ; 将1存到w0寄存器中    0x10093e59c &lt;+72&gt;:  mov    w1, #0x2    0x10093e5a0 &lt;+76&gt;:  mov    w2, #0x3    0x10093e5a4 &lt;+80&gt;:  mov    w3, #0x4    0x10093e5a8 &lt;+84&gt;:  mov    w4, #0x5    0x10093e5ac &lt;+88&gt;:  mov    w5, #0x6    0x10093e5b0 &lt;+92&gt;:  mov    w6, #0x7     ; 这些值我们是可以在通用寄存器里看到的    0x10093e5b4 &lt;+96&gt;:  mov    w7, #0x8     ; 将8存到w7寄存器中    ; x8 &#x3D; 0x0000000100940ce8  &quot;viewDidLoad&quot;    0x10093e5b8 &lt;+100&gt;: mov    x8, sp       ; 这里是把sp栈顶的位置放在x8寄存器中。    ; x8 &#x3D; 0x000000016f4c53c0    0x10093e5bc &lt;+104&gt;: mov    w10, #0x9    ; 把9放在w10寄存器    0x10093e5c0 &lt;+108&gt;: str    w10, [x8]    ; 把w10寄存器中的值，放在x8寄存器所在的地址里    ; 也就是在sp的位置，存放了9这个变量。-&gt;  0x10093e5c4 &lt;+112&gt;: bl     0x10093e4dc               ; sumA at ViewController.m:16      ; 这里执行 sumA    0x10093e5c8 &lt;+116&gt;: ldp    x29, x30, [sp, #0x30]    ; x29,x30取值，是为了函数返回    0x10093e5cc &lt;+120&gt;: add    sp, sp, #0x40             ; &#x3D;0x40 ; 释放栈空间    0x10093e5d0 &lt;+124&gt;: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们看test的汇编代码情况：</p><pre class="line-numbers language-LIST" data-language="LIST"><code class="language-LIST">test:    ; 开辟空间之前 sp &#x3D; 0x000000016f4c53c0-&gt;  0x10093e4dc &lt;+0&gt;:   sub    sp, sp, #0x30 ; &#x3D;0x30    ; 开辟栈空间后，sp&#x3D;0x000000016f4c5390    0x10093e4e0 &lt;+4&gt;:   ldr    w8, [sp, #0x30]  ; 这是从sp+0x30的位置取值，放在w8寄存器里。    ; sp+0x30就是开辟当前栈空间之前的位置，也就是viewDidLoad开辟空间的栈顶位置，这个位置是x8寄存器指向的位置，存放的是变量9    0x10093e4e4 &lt;+8&gt;:   str    w0, [sp, #0x2c]  ; 把w0寄存器的值存放在栈sp+0x2c里头，也就是sp偏移4个字节，正好存放一个int类型的数据。    0x10093e4e8 &lt;+12&gt;:  str    w1, [sp, #0x28]    0x10093e4ec &lt;+16&gt;:  str    w2, [sp, #0x24]    0x10093e4f0 &lt;+20&gt;:  str    w3, [sp, #0x20]    0x10093e4f4 &lt;+24&gt;:  str    w4, [sp, #0x1c]    0x10093e4f8 &lt;+28&gt;:  str    w5, [sp, #0x18]    0x10093e4fc &lt;+32&gt;:  str    w6, [sp, #0x14]    0x10093e500 &lt;+36&gt;:  str    w7, [sp, #0x10]    0x10093e504 &lt;+40&gt;:  str    w8, [sp, #0xc]   ; w8寄存器的值放在sp+0xc里，w8&#x3D;9    0x10093e508 &lt;+44&gt;:  ldr    w8, [sp, #0x2c]  ; 赋值操作 w8&#x3D;1    0x10093e50c &lt;+48&gt;:  ldr    w9, [sp, #0x28]  ; w9 &#x3D; 2    0x10093e510 &lt;+52&gt;:  add    w8, w8, w9       ; w8 &#x3D; w8+w9 &#x3D; 1+2 &#x3D; 3    0x10093e514 &lt;+56&gt;:  ldr    w9, [sp, #0x24]  ; w9 &#x3D; 3    0x10093e518 &lt;+60&gt;:  add    w8, w8, w9       ; w8 +&#x3D; w9 &#x3D; 3 + 3    0x10093e51c &lt;+64&gt;:  ldr    w9, [sp, #0x20]    0x10093e520 &lt;+68&gt;:  add    w8, w8, w9    0x10093e524 &lt;+72&gt;:  ldr    w9, [sp, #0x1c]    0x10093e528 &lt;+76&gt;:  add    w8, w8, w9    0x10093e52c &lt;+80&gt;:  ldr    w9, [sp, #0x18]    0x10093e530 &lt;+84&gt;:  add    w8, w8, w9    0x10093e534 &lt;+88&gt;:  ldr    w9, [sp, #0x14]    0x10093e538 &lt;+92&gt;:  add    w8, w8, w9    0x10093e53c &lt;+96&gt;:  ldr    w9, [sp, #0x10]    0x10093e540 &lt;+100&gt;: add    w8, w8, w9    0x10093e544 &lt;+104&gt;: ldr    w9, [sp, #0xc]    0x10093e548 &lt;+108&gt;: add    w0, w8, w9       ; 计算完成    0x10093e54c &lt;+112&gt;: add    sp, sp, #0x30    ; &#x3D;0x30 ，释放栈空间    0x10093e550 &lt;+116&gt;: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里会把9这个参数存放在<code>viewDidLoad</code>所开辟的栈空间里。执行test后，1-8会存放在<code>test</code>函数所开辟的空间中，然后把9这个参数从<code>viewDidLoad</code>所开辟的栈空间里拿回来，是通过x8寄存器来定位地址获取9这个参数的。相当于从别人家借东西，会存在sp计算的问题，会影响效率。</p><p>我们一定要知道的一点是，栈的读写都是从高位往低位进行读写，栈空间的读写都是基于上述原则进行操作的。<br>以上操作，配合View Memory查看内存中的数据会更清晰。</p><h3 id="4-2-1-release下操作"><a href="#4-2-1-release下操作" class="headerlink" title="4.2.1 release下操作"></a>4.2.1 release下操作</h3><p>我们的这一系列操作都是在debug模式下进行的，加法的计算产生的汇编代码竟然是如此繁杂。如果我们切换到release下运行，会有什么情况发生？</p><p>在release下，编译器会进行优化，我们的test方法，只是做了调用，没有任何实际意义，所以在release下根本不会有bl指令。</p><p>如果我们执行<code>printf(&quot;%d&quot;, sumA(1,2,3,4,5,6,7,8,9));</code>呢？</p><p>其实差别不大，经过系统优化之后，就只剩下<code>mov w8, #0x2d</code>这一句代码了，0x2d = 45。就是这么简单直接。</p><h2 id="4-3-验证返回值"><a href="#4-3-验证返回值" class="headerlink" title="4.3 验证返回值"></a>4.3 验证返回值</h2><p>如果返回值超过8个字节，x0寄存器存不下的时候，会通过栈空间来返回。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct NumA getStructA(int a, int b, int c, int d, int e, int f) &#123;    struct NumA num;    num.a &#x3D; a;    num.b &#x3D; b;    num.c &#x3D; c;    num.d &#x3D; d;    num.e &#x3D; e;    num.f &#x3D; f;    return num;&#125;- (void)viewDidLoad &#123;    [super viewDidLoad];    struct NumA num &#x3D; getStructA(1,2,3,4,5,6);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里呢，我们返回一个结构体，正常来说，结构体的大小是根据结构体中的变量决定的。这里有6个int类型的变量也就是24个字节。</p><pre class="line-numbers language-LIST" data-language="LIST"><code class="language-LIST">getStructA:-&gt;  0x1025424a0 &lt;+0&gt;:  sub    sp, sp, #0x20    ; &#x3D;0x20 开辟栈空间    0x1025424a4 &lt;+4&gt;:  str    w0, [sp, #0x1c]    0x1025424a8 &lt;+8&gt;:  str    w1, [sp, #0x18]    0x1025424ac &lt;+12&gt;: str    w2, [sp, #0x14]    0x1025424b0 &lt;+16&gt;: str    w3, [sp, #0x10]    0x1025424b4 &lt;+20&gt;: str    w4, [sp, #0xc]    0x1025424b8 &lt;+24&gt;: str    w5, [sp, #0x8]    0x1025424bc &lt;+28&gt;: ldr    w9, [sp, #0x1c]    0x1025424c0 &lt;+32&gt;: str    w9, [x8]    0x1025424c4 &lt;+36&gt;: ldr    w9, [sp, #0x18]    0x1025424c8 &lt;+40&gt;: str    w9, [x8, #0x4]    0x1025424cc &lt;+44&gt;: ldr    w9, [sp, #0x14]    0x1025424d0 &lt;+48&gt;: str    w9, [x8, #0x8]    0x1025424d4 &lt;+52&gt;: ldr    w9, [sp, #0x10]    0x1025424d8 &lt;+56&gt;: str    w9, [x8, #0xc]    0x1025424dc &lt;+60&gt;: ldr    w9, [sp, #0xc]    0x1025424e0 &lt;+64&gt;: str    w9, [x8, #0x10]    0x1025424e4 &lt;+68&gt;: ldr    w9, [sp, #0x8]    0x1025424e8 &lt;+72&gt;: str    w9, [x8, #0x14]    0x1025424ec &lt;+76&gt;: add    sp, sp, #0x20             ; &#x3D;0x20     0x1025424f0 &lt;+80&gt;: ret  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们又看到了一个熟悉的x8寄存器。然后通过w9寄存器，不断的赋值给x8寄存器对应的空间里。那这个x8寄存器是怎么个情况呢，我们返回<code>viewDidLoad</code>对应的汇编代码</p><pre class="line-numbers language-LIST" data-language="LIST"><code class="language-LIST">-[ViewController viewDidLoad]:...... ;这里也是截取部分代码0x1025425ac &lt;+64&gt;:  bl     0x1025429b4               ; symbol stub for: objc_msgSendSuper2    0x1025425b0 &lt;+68&gt;:  add    x8, sp, #0x8              ; &#x3D;0x8     0x1025425b4 &lt;+72&gt;:  mov    w0, #0x1    0x1025425b8 &lt;+76&gt;:  mov    w1, #0x2    0x1025425bc &lt;+80&gt;:  mov    w2, #0x3    0x1025425c0 &lt;+84&gt;:  mov    w3, #0x4    0x1025425c4 &lt;+88&gt;:  mov    w4, #0x5    0x1025425c8 &lt;+92&gt;:  mov    w5, #0x6    0x1025425cc &lt;+96&gt;:  bl     0x1025424a0               ; getStructB at ViewController.m:46-&gt;  0x1025425d0 &lt;+100&gt;: ldp    x29, x30, [sp, #0x40]    0x1025425d4 &lt;+104&gt;: add    sp, sp, #0x50             ; &#x3D;0x50     0x1025425d8 &lt;+108&gt;: ret    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到x8寄存器的位置是sp偏移8个字节。也就是返回值所在的空间是在<code>viewDidLoad</code>开辟的栈空间里。</p><p>这里会当前返回值存放在<code>viewDidLoad</code>所开辟的栈空间里，因为知道返回的是什么类型的数据，在<code>viewDidLoad</code>开辟空间时，就已经把返回值所需要的空间给预留出来了。通过x8寄存器来定位返回值所在的空间。</p><p>那么，这里为什么要偏移8个字节？</p><p>我们知道，ARM64对栈的操作是16个字节进行对齐的。而结构体占有24个字节，我们只能通过补齐来确保是16个字节的倍数来开辟空间。</p><p>执行对应的方法，对返回值的变量进行存储（根据x8寄存器来定位相应的地址存储变量的值）。</p><h1 id="5-函数的局部变量"><a href="#5-函数的局部变量" class="headerlink" title="5. 函数的局部变量"></a>5. 函数的局部变量</h1><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int sumC(int a, int b) &#123;    int c &#x3D; 10;    return a+b+c;&#125;- (void)viewDidLoad &#123;    [super viewDidLoad];        sumC(1,2);  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行，进入汇编模式</p><pre class="line-numbers language-LIST" data-language="LIST"><code class="language-LIST">Demo&#96;-[ViewController viewDidLoad]:    0x1026ae45c &lt;+68&gt;: mov    w0, #0x1    0x1026ae460 &lt;+72&gt;: mov    w1, #0x2-&gt;  0x1026ae464 &lt;+76&gt;: bl     0x1026ae3e8               ; sumC at ViewController.m:75    0x1026ae468 &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]    0x1026ae46c &lt;+84&gt;: add    sp, sp, #0x30             ; &#x3D;0x30     0x1026ae470 &lt;+88&gt;: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sumC(1, 2)：1和2分别放在了w0、w1寄存器中。然后执行bl，进入函数sumC</p><pre class="line-numbers language-LIST" data-language="LIST"><code class="language-LIST">Demo&#96;sumC:-&gt;  0x1026ae3e8 &lt;+0&gt;:  sub    sp, sp, #0x10             ; &#x3D;0x10     0x1026ae3ec &lt;+4&gt;:  str    w0, [sp, #0xc]    0x1026ae3f0 &lt;+8&gt;:  str    w1, [sp, #0x8]    0x1026ae3f4 &lt;+12&gt;: mov    w8, #0xa    0x1026ae3f8 &lt;+16&gt;: str    w8, [sp, #0x4]    0x1026ae3fc &lt;+20&gt;: ldr    w8, [sp, #0xc]    0x1026ae400 &lt;+24&gt;: ldr    w9, [sp, #0x8]    0x1026ae404 &lt;+28&gt;: add    w8, w8, w9    0x1026ae408 &lt;+32&gt;: ldr    w9, [sp, #0x4]    0x1026ae40c &lt;+36&gt;: add    w0, w8, w9    0x1026ae410 &lt;+40&gt;: add    sp, sp, #0x10             ; &#x3D;0x10     0x1026ae414 &lt;+44&gt;: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li> 开辟16个字节的内存空间</li><li> 把w0放在[sp+0xc]，w1放在[sp+0x8]</li><li> w8赋值等于0xa，这里就是我们的局部变量c=10</li><li> 然后把w8放在[sp+0x4]里头</li><li> 一堆操作，ret</li></ol><p>看到了吧，函数的参数和局部变量都是放在栈里的。</p><h1 id="6-函数嵌套"><a href="#6-函数嵌套" class="headerlink" title="6. 函数嵌套"></a>6. 函数嵌套</h1><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int funcSum(int a, int b, int c) &#123;    int d &#x3D; a + b + c;    printf(&quot;%d&quot;, d);    return d;&#125;int totalSum(int a, int b) &#123;    int c &#x3D; 10;    int d &#x3D; funcSum(a, b, c);    return d;&#125;- (void)viewDidLoad &#123;    [super viewDidLoad];    totalSum(1, 2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们执行上面的含有局部变量的嵌套函数，看是怎么在汇编下执行的。</p><pre class="line-numbers language-LIST" data-language="LIST"><code class="language-LIST">Demo&#96;-[ViewController viewDidLoad]:    ...    ...    0x1002fa43c &lt;+64&gt;: bl     0x1002fa8d0               ; symbol stub for: objc_msgSendSuper2    &#x2F;&#x2F; totalSum(1, 2)    0x1002fa440 &lt;+68&gt;: mov    w0, #0x1  &#x2F;&#x2F; 将1存在w0寄存器里    0x1002fa444 &lt;+72&gt;: mov    w1, #0x2  &#x2F;&#x2F; 2存放在w1寄存器里-&gt;  0x1002fa448 &lt;+76&gt;: bl     0x1002fa3bc               ; totalSum at ViewController.m:86    0x1002fa44c &lt;+80&gt;: ldp    x29, x30, [sp, #0x20]     ; x29、x30寄存器取值（lr寄存器获取回家的路）    0x1002fa450 &lt;+84&gt;: add    sp, sp, #0x30             ; &#x3D;0x30     0x1002fa454 &lt;+88&gt;: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一坨汇编代码，已经看过无数次了，这里不细说了，直接走totalSum看看是怎么处理的。</p><pre class="line-numbers language-LIST" data-language="LIST"><code class="language-LIST">Demo&#96;totalSum:-&gt;  0x1002fa3bc &lt;+0&gt;:  sub    sp, sp, #0x20             ; &#x3D;0x20     0x1002fa3c0 &lt;+4&gt;:  stp    x29, x30, [sp, #0x10]    0x1002fa3c4 &lt;+8&gt;:  add    x29, sp, #0x10            ; &#x3D;0x10     0x1002fa3c8 &lt;+12&gt;: stur   w0, [x29, #-0x4]  ; 把totalSum的参数w0存放在栈底的位置    0x1002fa3cc &lt;+16&gt;: str    w1, [sp, #0x8]    ; 把w1的值放在栈顶+8个字节的位置    0x1002fa3d0 &lt;+20&gt;: mov    w8, #0xa          ; 获取局部变量10，放在w8寄存器    0x1002fa3d4 &lt;+24&gt;: str    w8, [sp, #0x4]    ; w8的值放在sp+4个字节的位置    0x1002fa3d8 &lt;+28&gt;: ldur   w0, [x29, #-0x4]  ; 重新对w0赋值，取值的位置就是之前w0存放的位置 w0&#x3D;1    0x1002fa3dc &lt;+32&gt;: ldr    w1, [sp, #0x8]    ; w1取值w1&#x3D;2    0x1002fa3e0 &lt;+36&gt;: ldr    w2, [sp, #0x4]    ; w2 &#x3D; 10    0x1002fa3e4 &lt;+40&gt;: bl     0x1002fa35c       ; funcSum at ViewController.m:80 ;执行嵌套函数 funcSum。    0x1002fa3e8 &lt;+44&gt;: str    w0, [sp]          ; 把w0的值存在sp对应的位置。    0x1002fa3ec &lt;+48&gt;: ldr    w0, [sp]          ; 获取w0    0x1002fa3f0 &lt;+52&gt;: ldp    x29, x30, [sp, #0x10] ; 找到回家的路    0x1002fa3f4 &lt;+56&gt;: add    sp, sp, #0x20     ; &#x3D;0x20 释放    0x1002fa3f8 &lt;+60&gt;: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里用到了<code>stur</code>和<code>ldur</code>。这两个的本质与<code>str</code>和<code>ldr</code>没有区别，只是带<code>u</code>的偏移的是一个负值。</p><p>这里也有用到x29寄存器，还有印象吗？x29寄存器就是fp寄存器，指向的是栈底的位置。从栈的存储空间来看，栈底的地址比栈顶大，所以sp栈顶开辟空间都是减去一个值，而用栈底fp做关键值时，要想获取数据都必须在sp-fp之间拿值，所以基于fp的操作都是【减】。</p><p>这里为什么把局部变量的值存在w8里面，就是因为w0-w7是存放函数参数的参数，之前说过，w8用来获取局部变量。</p><p>funcSum函数的汇编就不说了，与之前的没什么区别。</p><p>这里需要提一句的是，为啥要把参数先存放在内存里，然后再取出来，难道就不嫌麻烦吗？其主要目的就是为了保护参数，防止被改变。</p><p>到最后w0/x0寄存器还是用来存放返回值。</p><h1 id="7-补充内容"><a href="#7-补充内容" class="headerlink" title="7. 补充内容"></a>7. 补充内容</h1><ol><li> 一个函数的参数，在函数执行完毕之后，是否能拿到这个参数的值？我们用4.2小结的代码来解释一下。</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int test(int a, int b, int c, int d, int e, int f, int g, int h, int i) &#123;    return a+b+c+d+e+f+g+h+i;&#125;- (void)viewDidLoad &#123;    [super viewDidLoad];    test(1,2,3,4,5,6,7,8,9);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>这个test函数有9个参数，我们知道，x0-x7（w0-w7）这个8个寄存器是存放函数变量的，如果超过8个参数，则会存放在viewDidLoad函数开辟的栈空间内，也就是说1-8这8个参数是在test函数开辟的栈空间。这8个参数在test函数执行完毕之后，随着空间的释放就拿不到了，而9这个参数存放在`viewDidLoad`的栈空间，我们还可以拿到。</code></pre><ol start="2"><li> 在4.3小结，我们返回的是一个结构体，而不是一个指针，假如，我们添加一个函数，来调用这个返回的结构体，这个结构体能不能用。</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct NumA getStructA(int a, int b, int c, int d, int e, int f) &#123;    struct NumA num;    num.a &#x3D; a;    num.b &#x3D; b;    num.c &#x3D; c;    num.d &#x3D; d;    num.e &#x3D; e;    num.f &#x3D; f;    return num;&#125;struct NumA returnStruct() &#123;    struct NumA num &#x3D; getStructA(1,2,3,4,5,6);    return num;&#125;- (void)viewDidLoad &#123;    [super viewDidLoad];    struct NumB num &#x3D; returnStruct();    printf(&quot;a &#x3D; %d\n&quot;, num.a);  &#x2F;&#x2F; 这里是否能输出，还是会crash&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>肯定是可以输出的，在`viewDidLoad`函数执行时，就已经创建了`struct NumB`所需要的空间了，返回的数据都存在于`viewDidLoad`的栈空间里，所以还是可以正常执行的。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li> 栈：引出SP、FP寄存器。SP：保存栈顶地址，FP：保存栈底的地址。（栈顶的地址比栈底的地址小，所以获取栈顶的值都是通过sub sp, sp #0x10,是减去一个空间，在存值的时候一般都是[sp+#0x08]）</li><li> stp/str 存值（16个字节/8个字节）</li><li> ldp/ldr 取值（16个字节/8个字节）</li><li> stur/ldur 本质上与str/ldr没有区别，带【u】的操作的是一个负值。</li><li> bl指令：通过lr(x30)寄存器，保存回家的路，bl跳转到对应的方法</li><li> lr寄存器的值会通过保存在栈空间，来确保能够正确的返回。</li><li> 函数的参数：存放在x0-x7寄存器，超过8个，则放在栈里。</li><li> 返回值：使用x0寄存器保存，如果大于8个字节，会利用栈空间传递。</li><li> 函数的局部变量放在栈里，嵌套函数的值也是放在栈里</li><li> 会把变量的值放在内存里保护起来，用的时候在去取值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> DISASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编(1)-初识汇编</title>
      <link href="/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(1)-%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96.html"/>
      <url>/20230601/Disasm_asm/ARM%E6%B1%87%E7%BC%96(1)-%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-初识汇编"><a href="#1-初识汇编" class="headerlink" title="1. 初识汇编"></a>1. 初识汇编</h1><blockquote><p>汇编语言（Assembly Language）是任何一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。</p></blockquote><p>一个APP安装在手机上面的可执行文件本质上是二进制文件。因为iPhone手机本质上执行的指令是二进制，是由手机上的CPU执行的。所以静态分析是建立在分析二进制上面。</p><h1 id="2-发展历程"><a href="#2-发展历程" class="headerlink" title="2. 发展历程"></a>2. 发展历程</h1><h2 id="2-1-编程语言"><a href="#2-1-编程语言" class="headerlink" title="2.1 编程语言"></a>2.1 编程语言</h2><p>从1946年第一台电子计算机问世，人类和机器的交流方式和语言就成为了软件工程师和计算机从业者的主要研究方向。在过去的几十年，编程语言有了长足的发展。</p><h2 id="2-2-机器语言"><a href="#2-2-机器语言" class="headerlink" title="2.2 机器语言"></a>2.2 机器语言</h2><p>计算机的硬件作为一种电路元件，它的输出和输入只能是有电或者没电，也就是所说的高电平和低电平，所以计算机传递的数据是由“0” 和“1”组成的二进制数，所以说二进制的语言是计算机语言的本质。</p><h2 id="2-3-汇编语言"><a href="#2-3-汇编语言" class="headerlink" title="2.3 汇编语言"></a>2.3 汇编语言</h2><p>不难看出机器语言作为一种编程语言，灵活性较差可阅读性也很差，为了减轻机器语言带给软件工程师的不适应，人们对机器语言进行了升级和改进：用一些容易理解和记忆的字母，单词来代替一个特定的指令。这就是助记符。</p><h2 id="2-4-高级语言"><a href="#2-4-高级语言" class="headerlink" title="2.4 高级语言"></a>2.4 高级语言</h2><p>人们需要设计一个能够不依赖于计算机硬件，能够在不同机器上运行的程序。这样可以免去很多编程的重复过程，提高效率，同时这种语言又要接近于数学语言或人的自然语言。这就诞生了高级编程语言。比如：C、C++、Java、OC、Swift。</p><p>我们的代码在终端设备上的执行过程，如下图：<br><img src="/images/learn/arm-asm/v2-f4e7f04b38f34f4d294e48815910b5e2_b.gif"></p><ul><li>  汇编语言与机器语言一一对应，每一条机器指令都有与之对应的汇编指令</li><li>  汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言</li><li>  高级语言可以通过编译得到汇编语言\机器语言，但汇编语言\机器语言几乎不可能还原成高级语言</li></ul><h2 id="2-5-汇编语言的特点"><a href="#2-5-汇编语言的特点" class="headerlink" title="2.5 汇编语言的特点"></a>2.5 汇编语言的特点</h2><ul><li>  可以直接访问、控制各种硬件设备，比如存储器、CPU等，能最大限度地发挥硬件的功能</li><li>  能够不受编译器的限制，对生成的二进制代码进行完全的控制</li><li>  目标代码简短，占用内存少，执行速度快</li><li>  汇编指令是机器指令的助记符,同机器指令一一对应。每一种CPU都有自己的机器指令集\汇编指令集，所以汇编语言不具备可移植性</li><li>  不区分大小写，比如mov和MOV是一样的</li><li>  知识点过多，开发者需要对CPU等硬件结构有所了解，不易于编写、调试、维护</li></ul><h2 id="2-6-用途"><a href="#2-6-用途" class="headerlink" title="2.6 用途"></a>2.6 用途</h2><ul><li>  编写驱动程序、操作系统（比如Linux内核的某些关键部分）</li><li>  对性能要求极高的程序或者代码片段，可与高级语言混合使用（内联汇编）</li><li>软件安全<ul><li>  病毒分析与防治</li><li>  逆向\加壳\脱壳\破解\外挂\免杀\加密解密\漏洞\黑客</li></ul></li><li>  理解整个计算机系统的最佳起点和最有效途径</li><li>  为编写高效代码打下基础</li><li>  弄清代码的本质</li></ul><p>越底层越单纯，但是使用起来越困难，同时也是程序员都需要了解的非常重要的语言。</p><h2 id="2-7-汇编语言的分类"><a href="#2-7-汇编语言的分类" class="headerlink" title="2.7 汇编语言的分类"></a>2.7 汇编语言的分类</h2><ul><li>  8086汇编 （8086处理器时16bit的CPU）</li><li>  Win32汇编</li><li>  Win64汇编</li><li>  ARM汇编（Mac，iOS）</li></ul><p>在iPhone里面，用的的ARM汇编，又根据CPU的架构不同而有差异。</p><table><thead><tr><th>架构</th><th>设备</th></tr></thead><tbody><tr><td>armv6</td><td>古老的iPhone3G之前，iPod Touch（第一代，第二代）</td></tr><tr><td>armv7</td><td>iPhone3GS, iPhone4, iPhone4S, iPad, iPad2, iPad3, iPad Mini, iPod Touch 3G, iPod Touch4</td></tr><tr><td>armv7s</td><td>iPhone5, iPhone5C, iPad4</td></tr><tr><td>armv64</td><td>iPhone5S及以后的设备，iPad Air，iPad Mini2以后</td></tr></tbody></table><h1 id="3-几个必要的知识点"><a href="#3-几个必要的知识点" class="headerlink" title="3. 几个必要的知识点"></a>3. 几个必要的知识点</h1><h2 id="3-1-bit"><a href="#3-1-bit" class="headerlink" title="3.1 bit"></a>3.1 bit</h2><p>bit：表示『位』或者『比特』，是计算机运算的基础单位，是二进制数的最小单元。1 bit就是1位二进制数，只能存放0或者1。</p><h2 id="3-2-Byte"><a href="#3-2-Byte" class="headerlink" title="3.2 Byte"></a>3.2 Byte</h2><p>Byte：表示『字节』，是计算机文件大小的基本单位。1Byte = 8bit，表示一个字节可以存放8位无符号数。一个汉子是2个字节，16位。一个英文字母是1个字节。</p><p>1个字节可以表示为：0000 0000，1111 1111。</p><h2 id="3-3-总线"><a href="#3-3-总线" class="headerlink" title="3.3 总线"></a>3.3 总线</h2><p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。</p><p>总线是一种内部结构，它是cpu、内存、输入、输出设备传递信息的公用通道，主机的各个部件通过总线相连接，外部设备通过相应的接口电路再与总线相连接，从而形成了计算机硬件系统。</p><p>在计算机系统中，各个部件之间传送信息的公共通路叫总线，微型计算机是以总线结构来连接各个功能部件的。</p><p>简单来说</p><ul><li>  每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件交互。</li><li>  总线就是一根根导线的集合</li></ul><h3 id="3-3-1-总线分类"><a href="#3-3-1-总线分类" class="headerlink" title="3.3.1 总线分类"></a>3.3.1 总线分类</h3><p>一般情况下分为5大类：</p><ol><li> 数据总线：在CPU与RAM之间来回传送需要处理或需要存储的数据。它的宽度决定了CPU单次数据传送量，也就是数据传送的速度。例如：8086微处理器子长16位，其数据总线宽度也是16位，所以单次最大传递2个字节的数据。</li><li> 地址总线：用来指定在RAM之中存储的数据的地址。它的宽度决定了CPU的寻址能力。例如8086的地址总线宽度是20位，那么它的寻址能力是1M（2^20）。</li><li> 控制总线：将微处理器控制单元的信号，传送到周边设备。它的宽度决定了CPU对其他器件的控制能力。</li><li> 扩展总线：外部设备和计算机主机进行数据通信的总线，例如ISA，PCI总线。</li><li> 局部总线：取代更高速数据传输的扩展总线。</li></ol><p>其中数据总线、地址总线、控制总线也统称为系统总线。</p><h2 id="3-4-进制"><a href="#3-4-进制" class="headerlink" title="3.4 进制"></a>3.4 进制</h2><p>常用的进制有2进制，8进制，10进制，16进制。<br>2进制：00 11 11 100 101，逢2进1<br>8进制 0 1 2 3 4 5 6 7 10， 逢8进1<br>16进制 0 1 2 3 4 5 6 7 8 9 A B C D E F 10， 逢16进1</p><p>还有一些可以自己定义的进制，约定几个符合来表示对应的数据：<br>比如3进制 我们用a 3 1表示，通常约定好一些符合来表示对应的数据，以此来达到加密的效果。</p><p>运算等一些列就不说了~~~</p><h2 id="3-5-数据的宽度"><a href="#3-5-数据的宽度" class="headerlink" title="3.5 数据的宽度"></a>3.5 数据的宽度</h2><p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int test() &#123;    int cTemp &#x3D; 0x1FFFFFFFF;    return cTemp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，我们定义了一个int类型的变量，但是赋值的是9位16进制数。但是这里打印cTemp的值发现是-1</p><pre class="line-numbers language-TEXT" data-language="TEXT"><code class="language-TEXT">(lldb) p cTemp(int) $0 &#x3D; -1(lldb) p &amp;cTemp(int *) $1 &#x3D; 0x000000016f8e926c(lldb) x 0x000000016f8e926c0x16f8e926c: ff ff ff ff b0 92 8e 6f 01 00 00 00 88 a5 51 00  .......o......Q.0x16f8e927c: 01 00 00 00 10 00 00 00 00 00 00 00 02 00 00 00  ................(lldb) p (uint)cTemp$0 &#x3D; 4294967295<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的打印，发现cTemp所在的地址钟存放的是ff ff ff ff，而前面的1没有了，这就是发生了溢出。但是通过转换无符号数，发现是可以正常打印的。这就说明了，地址钟存放的数据是没有发生变化的，只是由于位数的限制导致的有符号和无符号的区别，导致的数据不一致。</p><p>在通常的二进制中，第一位表示正负，0表示正 1表示负。</p><pre class="line-numbers language-TEXT" data-language="TEXT"><code class="language-TEXT">&#x2F;&#x2F; int 4个字节，表示32位。第一位为符号为。 F    F    F    F    F    F    F    F1111 1111 1111 1111 1111 1111 1111 1111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里提一嘴我们经常用的宽带，都是100M的，200M的，但是这个的意思是100Mbps，说的也是宽度，除以8才是对应的数据传输速度。</p><h1 id="4-CPU-amp-寄存器"><a href="#4-CPU-amp-寄存器" class="headerlink" title="4. CPU &amp; 寄存器"></a>4. CPU &amp; 寄存器</h1><p>CPU除了有控制器、运算器还有寄存器。其中寄存器的作用就是进行数据的临时存储。</p><p>CPU的运算速度是非常快的，为了性能CPU在内部开辟一小块临时存储区域，并在进行运算时先将数据从内存复制到这一小块临时存储区域中，运算时就在这一小快临时存储区域内进行。我们称这一小块临时存储区域为寄存器。</p><p>对于arm64系的CPU来说， 如果寄存器以x开头则表明的是一个64位的寄存器，如果以w开头则表明是一个32位的寄存器，在系统中没有提供16位和8位的寄存器供访问和使用。其中32位的寄存器是64位寄存器的低32位部分并不是独立存在的。</p><ul><li>  对程序员来说，CPU中最主要部件是寄存器，可以通过改变寄存器的内容来实现对CPU的控制。</li><li>  不同的CPU，寄存器的个数、结构是不相同的。</li></ul><h2 id="4-1-浮点和向量寄存器"><a href="#4-1-浮点和向量寄存器" class="headerlink" title="4.1 浮点和向量寄存器"></a>4.1 浮点和向量寄存器</h2><p>因为浮点数的存储以及其运算的特殊性,CPU中专门提供浮点数寄存器来处理浮点数</p><ul><li>  浮点寄存器 64位: D0 - D31 32位: S0 - S31</li></ul><p>现在的CPU支持向量运算.(向量运算在图形处理相关的领域用得非常的多)为了支持向量计算系统了也提供了众多的向量寄存器.</p><ul><li>  向量寄存器 128位:V0-V31</li></ul><h2 id="4-2-通用寄存器"><a href="#4-2-通用寄存器" class="headerlink" title="4.2 通用寄存器"></a>4.2 通用寄存器</h2><p>通用寄存器也称数据地址寄存器通常用来做数据计算的临时存储、做累加、计数、地址保存等功能。定义这些寄存器的作用主要是用于在CPU指令中保存操作数，在CPU中当做一些常规变量来使用。</p><p>ARM64拥有有32个64位的通用寄存器 x0 到 x30，以及XZR(零寄存器),这些通用寄存器有时也有特定用途。</p><ul><li>  那么w0 到 w28 这些是32位的. 因为64位CPU可以兼容32位.所以可以只使用64位寄存器的低32位.</li><li>  比如 w0 就是 x0的低32位!</li></ul><p><img src="/images/learn/arm-asm/arm-register.jpg"></p><p>图片上标注了1、2、3、4分别有所对应。<br>1 - 点击进入汇编<br>2 - 进入汇编之后，选择『All Variables, register』，会显示如图所示<br>3 - 浮点和向量寄存器，存放对应的v0-v31，d0-d31，s0-s31<br>4 - 通用寄存器，存放x0-x28，fp，lr，sp，pc，w0-w28</p><pre class="line-numbers language-ARMASM" data-language="ARMASM"><code class="language-ARMASM">mov x0, #0xa0           ; x0 &#x3D; 0xa0mov x1,#0x00            ; x1 &#x3D; 0x00add x1, x0, #0x14       ; x1 &#x3D; x0 + 0x14mov x0,x1               ; x0 &#x3D; x1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-3-pc寄存器-program-counter"><a href="#4-3-pc寄存器-program-counter" class="headerlink" title="4.3 pc寄存器(program counter)"></a>4.3 pc寄存器(program counter)</h2><ul><li>为指令指针寄存器，它指示了CPU当前要读取指令的地址</li><li>在内存或者磁盘上，指令和数据没有任何区别，都是二进制信息</li><li>CPU在工作的时候把有的信息看做指令，有的信息看做数据，为同样的信息赋予了不同的意义<ul><li>  比如 1110 0000 0000 0011 0000 1000 1010 1010</li><li>  可以当做数据 0xE003008AA</li><li>  也可以当做指令 mov x0, x8</li></ul></li><li>CPU根据什么将内存中的信息看做指令？<ul><li>  CPU将pc指向的内存单元的内容看做指令</li><li>  如果内存中的某段内容曾被CPU执行过，那么它所在的内存单元必然被pc指向过</li></ul></li></ul><h2 id="4-4-高速缓存"><a href="#4-4-高速缓存" class="headerlink" title="4.4 高速缓存"></a>4.4 高速缓存</h2><p>iPhoneX上搭载的ARM处理器A11它的1级缓存的容量是64KB，2级缓存的容量8M.</p><p>CPU每执行一条指令前都需要从内存中将指令读取到CPU内并执行。而寄存器的运行速度相比内存读写要快很多,为了性能,CPU还集成了一个高速缓存存储区域.当程序在运行时，先将要执行的指令代码以及数据复制到高速缓存中去(由操作系统完成).CPU直接从高速缓存依次读取指令来执行.</p><h2 id="4-5-bl指令"><a href="#4-5-bl指令" class="headerlink" title="4.5 bl指令"></a>4.5 bl指令</h2><p>CPU从何处执行指令是由pc中的内容决定的，我们可以通过改变pc的内容来控制CPU执行目标指令。</p><p>ARM64提供了一个mov指令（传送指令），可以用来修改大部分寄存器的值，比如<br>mov x0,#10、mov x1,#20。但是，mov指令不能用于设置pc的值，ARM64没有提供这样的功能</p><p>ARM64提供了另外的指令来修改PC的值，这些指令统称为转移指令，最简单的是bl指令</p><h3 id="4-5-1-bl指令-–-练习"><a href="#4-5-1-bl指令-–-练习" class="headerlink" title="4.5.1 bl指令 – 练习"></a>4.5.1 bl指令 – 练习</h3><p>现在有两段代码!假设程序先执行A,请写出指令执行顺序.最终寄存器x0的值是多少?</p><pre class="line-numbers language-ARMASM" data-language="ARMASM"><code class="language-ARMASM">.text.global _A,_B_A:    mov x0,#0xa0    mov x1,#0x00    add x1, x0, #0x14    mov x0,x1    bl _B    mov x0,#0x0    ret    _B:    add x0, x0, #0x10    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>打开Xcode，新建一个工程，在新建文件是选择 『Assembly File』，生成的是『.s』文件。然后将上面的代码复制粘贴。</li><li> 在ViewController中，进行函数声明。这里需要注意的是，方法明需要一致。</li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;函数的声明~~int A();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li> 在<code>viewDidLoad</code>中直接调用<code>A()</code>，打断点，然后跳转到汇编。</li></ol><pre class="line-numbers language-ARMASM" data-language="ARMASM"><code class="language-ARMASM">_A:    mov x0, #0xa0        ; x0 &#x3D; a0    mov x1,#0x00         ; x1 &#x3D; 0    add x1, x0, #0x14    ; x1 &#x3D; x0 + 0x14    mov x0,x1            ; x0 &#x3D; x1    bl _B                ; 跳转到方法 _B --&gt; 执行B    mov x0, #0x0         ; 从B回来之后执行 x0 &#x3D; 0    ret                  ; return, 继续点击会发现啥？_B:  add x0, x0, #0x10      ; x0 +&#x3D; 10  ret                    ; return，方法结束回到A继续执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里会有一点问的哈~会导致循环了。为啥会导致循环了呢？翻下一章。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><ol><li> 汇编基础知识，发展、用途、特点</li><li> 几个知识点：bit，Byte，总线，数据宽度</li><li> CPU 寄存器。浮点寄存器（64位: D0 - D31 32位: S0 - S31）；向量寄存器（128位:V0-V31）；通用寄存器（32位w0-w28，64位x0-x28），PC寄存器。</li><li> bl指令</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> DISASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAN通信基础知识</title>
      <link href="/20230601/learn_base/CAN%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
      <url>/20230601/learn_base/CAN%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="CAN是什么？"><a href="#CAN是什么？" class="headerlink" title="CAN是什么？"></a>CAN是什么？</h1><p>CAN 是 Controller Area Network 的缩写，中文是控制器局域网路,是 ISO 国际标准化的串行通信协议之一。<br><img src="/images/learn/can/MzU0MjY5MDQwNw-001.png" alt="图片"><br>CAN: 控制器局域网( Controller Area Network)属于现场总线的范畴，是一种有效支持分布式控制系统的串行通信网络</p><blockquote><p>CAN是由德国博世公司在20世纪80年代专门为汽车行业开发的一种串行通信总线。由于其高性能、高可靠性以及独特的设计而越来越受到人们的重视，被广泛应用于汽车业、航空业、工业控制、安全防护等领域。随着CAN总线在各个行业和领域的广泛应用，对其的通信格式标准化也提出了更严格的要求。1991年CAN总线技术规范（Version2.0）制定并发布。该技术规范共包括A和B两个部分。其中2.0A给出了CAN报文标准格式，而2.0B给出了标准的和扩展的两种格式。CAN总线协议是一种ISO 国际标准化的串行通信协议，有ISO-11898 和 ISO-11519两个系列。</p></blockquote><p>其定义有：<br>ISO-11898 定义了通信速率为 125 Kbps ~1Mbps 的高速 CAN 通信标准，属于闭环总线，传输速率可达1Mbps，总线长度 ≤ 40米，如图1。<br><img src="/images/learn/can/MzU0MjY5MDQwNw-002.jpg" alt="图片"></p><p>ISO11519 定义了通信速率为 10～125 kbps 的低速 CAN 通信标准，属于开环总线，传输速率为40kbps时，总线长度可达1000米，如图2。<br><img src="/images/learn/can/MzU0MjY5MDQwNw-003.jpg" alt="图片"></p><p>现在，CAN 的高性能和可靠性已被认同，并被广泛地应用于工业自动化、船舶、医疗设备、工业设备等方面。图 3 是车载网络的构想示意图。CAN 通信协议的开发，使多种 LAN 通过网关进行数据交换得以实现。<br><img src="/images/learn/can/MzU0MjY5MDQwNw-004.png" alt="图片"></p><h1 id="Controller是什么？"><a href="#Controller是什么？" class="headerlink" title="Controller是什么？"></a>Controller是什么？</h1><p>通常意义上指控制器，多个控制器之间进行通信，可以通过CAN线使其进行连接<br><img src="/images/learn/can/MzU0MjY5MDQwNw-005.png" alt="图片"></p><h1 id="典型用例："><a href="#典型用例：" class="headerlink" title="典型用例："></a>典型用例：</h1><p><img src="/images/learn/can/MzU0MjY5MDQwNw-006.png" alt="图片"></p><h1 id="CAN线如何连接呢"><a href="#CAN线如何连接呢" class="headerlink" title="CAN线如何连接呢"></a>CAN线如何连接呢</h1><p>两根线：</p><blockquote><p>CAN_H线<br>CAN_L线<br><img src="/images/learn/can/MzU0MjY5MDQwNw-007.png" alt="图片"></p></blockquote><h1 id="CAN的两种电平"><a href="#CAN的两种电平" class="headerlink" title="CAN的两种电平"></a>CAN的两种电平</h1><p>总线上的电平有显性电平和隐性电平两种。总线上执行逻辑上的线“与”时，显性电平的逻辑值为“0”，隐性电平为“1”。“显性”具有“优先”的意味，只要有一个单元输出显性电平，总线上即为显性电平。并且，“隐 性”具有“包容”的意味，只有所有的单元都输出隐性电平，总线上才为隐性电平。（显性电平比 隐性电平更强）</p><blockquote><p><strong><strong>显性电平：</strong></strong>逻辑0：CAN_H 和 CAN_L 的电压一个3.5V一个1.5V 电位差是2V<br><strong><strong>隐形电平：</strong></strong>逻辑1：CAN_H 和 CAN_L 的电压都是是2.5V     电位差是0V</p></blockquote><p>CAN 协议经 ISO 标准化后有 ISO11898 标准和 ISO11519-2 标准两种。ISO11898 和 ISO11519-2 标准对于数据 链路层的定义相同，但物理层不同。</p><ol><li>ISO11898 是通信速度为 125kbps-1Mbps 的 CAN 高速通信标准。目前，ISO11898 追加新规约后，成为 ISO11898-1 新标准。</li><li>ISO11519 是通信速度为 125kbps 以下的 CAN 低速通信标准<br><img src="/images/learn/can/MzU0MjY5MDQwNw-008.png" alt="图片"></li><li>ISO11898和ISO11519的主要不同点<br><img src="/images/learn/can/MzU0MjY5MDQwNw-009.jpg" alt="图片"></li></ol><p>下图是描述的就是压差为2V的逻辑0，跟压差为0V的逻辑1<br><img src="/images/learn/can/MzU0MjY5MDQwNw-010.png" alt="图片"></p><h1 id="单片机如何进行CAN通信"><a href="#单片机如何进行CAN通信" class="headerlink" title="单片机如何进行CAN通信"></a>单片机如何进行CAN通信</h1><p>串行电平转换成差分电平<br><img src="/images/learn/can/MzU0MjY5MDQwNw-011.png" alt="图片"></p><h1 id="为什么要用差分线呢"><a href="#为什么要用差分线呢" class="headerlink" title="为什么要用差分线呢"></a>为什么要用差分线呢</h1><p>主要是下面两个原因</p><ol><li>抗干扰性：双绞线可以有效地减少电磁干扰的影响。CAN总线常常被应用于工业环境和汽车领域，这些环境中存在大量的电磁干扰源，如电机、继电器等。双绞线通过将两根导线紧密地绞合在一起，可以减少对外部电磁干扰的敏感性，从而提高通信的可靠性。</li><li>抗噪声性：双绞线还可以降低信号传输中的串扰噪声。当信号通过一根导线传输时，周围的导线可能会产生电磁场，从而对信号产生干扰。双绞线中的两根导线通过彼此绞合，可以减小这种串扰噪声的影响，提高信号的完整性和准确性。<br><img src="/images/learn/can/MzU0MjY5MDQwNw-012.png" alt="图片"></li></ol><p>这也就是CAN通信比串口通信传输更远的原因可以达到1000米。</p><h1 id="CAN的协议桢"><a href="#CAN的协议桢" class="headerlink" title="CAN的协议桢"></a>CAN的协议桢</h1><p>CAN（Controller Area Network）协议定义了几种不同类型的数据帧，用于在CAN总线上进行通信。以下是CAN协议中常见的几种数据帧及其作用：</p><ol><li>数据帧（Data Frame）：数据帧是CAN协议中最常用的帧类型。它用于在CAN总线上传输数据信息。数据帧包括数据域（Data Field），用于携带有效数据，以及标识符（Identifier），用于标识消息的发送者和接收者。</li><li>远程帧（Remote Frame）：远程帧用于请求特定CAN节点发送数据。发送远程帧的节点向目标节点发送一个标识符，目标节点接收到远程帧后，会以数据帧的形式返回请求的数据。远程帧在需要获取其他节点数据时非常有用。有时候也叫遥控桢</li><li>错误帧（Error Frame）：错误帧用于在CAN总线上报告错误情况。当节点检测到总线上的错误时，它可以发送错误帧来通知其他节点发生了错误。错误帧中包含有关错误类型和错误位置的信息，用于诊断和故障排除。</li><li>过载帧（Overload Frame）：过载帧用于指示CAN节点附近存在过载条件。当节点无法及时处理接收到的消息时，它可以发送过载帧来通知其他节点，以便调整通信负载或采取其他措施。</li><li>错误被动帧（Error Passive Frame）：错误被动帧用于指示发送节点处于错误被动状态。当节点连续发送错误帧数量达到一定阈值时，它会进入错误被动状态，此时会发送错误被动帧来通知其他节点。</li><li>帧间隔 ：在CAN（Controller Area Network）通信中，帧间隔（Frame Interval）指的是两个连续CAN数据帧之间的时间间隔。帧间隔包括发送帧的间隔和接收帧的间隔</li></ol><p>这些数据帧类型在CAN总线上的使用有助于实现可靠的通信和故障诊断。数据帧用于传输实际的数据信息，远程帧用于请求数据，错误帧用于报告错误情况，过载帧用于指示过载条件，而错误被动帧用于指示节点处于错误被动状态。通过这些数据帧，CAN协议能够提供高效、可靠的通信机制，并支持诊断和故障处理。</p><p>另外，数据帧和遥控帧有标准格式和扩展格式两种格式,</p><p>标准格式有 11 个位的标识符（Identifier: 以下称 ID），</p><p>扩展格式有 29 个位的 ID;<br><img src="/images/learn/can/MzU0MjY5MDQwNw-013.png" alt="图片"></p><h1 id="标准的一串数据帧是什么样的"><a href="#标准的一串数据帧是什么样的" class="headerlink" title="标准的一串数据帧是什么样的"></a>标准的一串数据帧是什么样的</h1><p><img src="/images/learn/can/MzU0MjY5MDQwNw-014.png" alt="图片"></p><p>标准帧（Standard Frame）是CAN（Controller Area Network）协议中常用的一种数据帧格式，用于在CAN总线上传输数据。以下是标准帧的格式及其各个字段的解释：</p><ol><li>帧起始位（Start of Frame，SOF）：一个固定为低电平的位，用于指示帧的开始。</li><li>标识符（Identifier）：标识符用于唯一地标识发送的消息。它通常是11位长，但在CAN 2.0A协议中，标识符可以是11位或29位长。标识符中的位定义了消息的优先级、发送节点和接收节点等信息。</li><li>远程传输请求位（Remote Transmission Request，RTR）：该位用于指示消息是否是远程帧。如果该位为1，则表示发送节点请求接收节点发送数据；如果该位为0，则表示消息是数据帧。</li><li>数据长度码（Data Length Code，DLC）：DLC字段指定了数据域中所包含的字节数。它可以是0到8之间的值，表示数据域的长度。</li><li>数据域（Data Field）：数据域是用于携带有效数据的部分。它的长度由DLC字段确定，可以包含0到8个字节的数据。</li><li>CRC（Cyclic Redundancy Check）：CRC字段用于检测数据帧中的错误。它是通过对标识符、RTR、DLC和数据域进行计算得出的校验值。</li><li>CRC分隔位（CRC Delimiter）：一个固定为1的位，用于分隔CRC字段和确认槽位。</li><li>确认槽位（Acknowledge Slot）：确认槽位用于接收节点发送一个确认位（ACK）来指示数据的接收情况。如果接收节点成功接收到数据，则发送一个高电平ACK；如果接收节点检测到错误，则发送低电平ACK错误。</li><li>结束帧位（End of Frame，EOF）：一个固定为高电平的位，用于指示帧的结束。</li></ol><p>以上是标准帧的基本格式。CAN总线上的节点根据这个格式来发送和接收数据。标准帧通过使用固定长度的标识符和较短的数据域，提供了一种简单、高效的通信方式，适用于许多应用领域，如汽车、工业控制等。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 通讯传输 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令汇总</title>
      <link href="/20230601/learn_base/Git%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB.html"/>
      <url>/20230601/learn_base/Git%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB.html</url>
      
        <content type="html"><![CDATA[<p>Git目前是各大互联网公司使用的版本控制工具，进大厂，必须要学会Git的基本使用。<br>于是乎，我熬夜整理了这篇文章。这篇文章主要是汇总讲解Git的使用命令。</p><h1 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h1><p>通过 <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>  ，git官网下载需要的版本，一路下一步安装即可<br>装好后，在电脑文件夹的任意位置右键，即可看到git相关的命令。<br>git bash是命令行工具<br>git gui是图形化工具<br>打开git bash后，输入git –version ，能正确输出版本号，则证明安装成功。</p><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h2><p>git config –global <a href="http://user.name/">user.name</a> ‘自己的名字’<br>git config –global <a href="http://user.name/">user.name</a> ‘自己的邮箱’<br>local 只对当前仓库有效<br>global 所有仓库有效<br>system 对系统所有用户有效</p><h2 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h2><p>git config –list –local<br>git config –list –global<br>git config –list –system</p><h2 id="清除配置"><a href="#清除配置" class="headerlink" title="清除配置"></a>清除配置</h2><p>git config –unset –local <a href="http://user.name/">user.name</a><br>git config –unset –global <a href="http://user.name/">user.name</a><br>git config –unset –system <a href="http://user.name/">user.name</a></p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>进入要被托管的文件夹，执行<br>git init<br>添加文件至暂存区<br>git add 文件名<br>提交文件<br>git commit -m ‘描述’<br>查看git状态<br>git status<br>查看修改内容<br>git diff 文件名<br>修改文件名字<br>git mv 原文件名   新文件名</p><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>功能为查看日志<br>git log<br>查看日志，以单行显示<br>git log –pretty=oneline<br>功能为查看历史操作记录，比如回退版本后想要重返“未来”可以查看最新的提交版本<br>git reflog<br>通过可视化工具查看提交信息<br>gitk</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>退回到上一个版本<br>git reset –hard head<br>当知道对应的版本号时，可以用这个命令，适用于回退和前往之前的新版本<br>git reset –hard 版本号</p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>新版本git提示用该命令进行撤销<br>git restore 文件名<br>旧版本用此命令做撤销，新版本也可以用<br>git checkout – 文件名<br>如果已经add进暂存区<br>git restore –staged 文件名<br>新版本git用该命令此为旧版本git命令，新版本也可以用<br>git reset head 文件名</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>git rm -f 文件名  </p><h2 id="使用分支"><a href="#使用分支" class="headerlink" title="使用分支"></a>使用分支</h2><h3 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h3><p>git branch<br>创建dev分支并切换过去<br>-b表示创建并切换，相当于下面两条命令<br>git checkout -b dev</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>git branch dev</p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>git checkout dev<br>注意：上面是老版本的命令，创建分支和撤销都用checkout容易分不清，因此新版本创建分支推荐用<br>switch<br>创建并切换到dev<br>git switch -c dev<br>直接切换到已有的dev分支<br>git switch dev</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>将dev分支合并到当前分支，合并后会丢失原来分支的信息<br>git merge dev<br>合并dev到当前分支，–no-ff表示禁用fast forwad,之后查看日志时是可以看到已被删除分支的信息<br>git merge –no-ff -m “merge with no-ff” dev</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>git branch -d dev<br>git branh -D dev<br>如果dev没有被合并过用大写 -D</p><h3 id="查看分支合并情况"><a href="#查看分支合并情况" class="headerlink" title="查看分支合并情况"></a>查看分支合并情况</h3><p>git log –graph –pretty=oneline –abbrev-commit<br>stash的使用（bug分支）<br>保存当前的工作现场<br>git stash</p><h3 id="查看所有被保存的工作"><a href="#查看所有被保存的工作" class="headerlink" title="查看所有被保存的工作"></a>查看所有被保存的工作</h3><p>git stash list<br>恢复并删除工作现场，等价于git stash apply + git stash drop<br>git stash pop<br>开发环境在dev分支下，bug修复是提交在master中，如何快速合并至dev下：转移至dev分支下，执行下面命令<br>git cherry-pick bug分支的提交版本号</p><h2 id="远程克隆到本地"><a href="#远程克隆到本地" class="headerlink" title="远程克隆到本地"></a>远程克隆到本地</h2><p>git clone 自己的git项目地址<br>如果是本地没有项目，从远程往下拉项目则是克隆</p><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>git remote add origin 自己的git项目地址<br>如果本地先建好了项目，那么执行这个命令将本地仓库与远程仓库关联</p><h2 id="拉取远程的更新"><a href="#拉取远程的更新" class="headerlink" title="拉取远程的更新"></a>拉取远程的更新</h2><p>git pull<br>第一和远程关联上之后，在提交之前要先pull一下远程的更新才行</p><h2 id="基本推送"><a href="#基本推送" class="headerlink" title="基本推送"></a>基本推送</h2><p>第一次推送是要加上-u，可以把本地的master和远程的master关联起来，方便以后的推送或者拉取<br>git push -u origin master<br>之后推送可以直接用该命令<br>git push origin master<br>查看远程仓库信息<br>git remote<br>此命令可显示更详细信息<br>git remote -v</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>git checkout -b 分支名 origin/分支名，在本地创建和远程分支对应的分支，名称最好一致<br>git branch –set-upstream-to=origin/dev dev，建立本地分支和远程分支的关联<br>git pull，先抓取远程的更新，如果有冲突，手动解决冲突<br>git push origin 分支名，解决冲突后推送</p><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>标签的作用可以简单理解为给版本起名字</p><h3 id="查看所有标签"><a href="#查看所有标签" class="headerlink" title="查看所有标签"></a>查看所有标签</h3><p>git tag</p><p>把当前分支的最新提交打上标签，标签名字自己起<br>git tag 标签名</p><p>把某个版本号的提交打上标签<br>git tag 标签名 对应commit版本号</p><p>可以用这种方式给标签增加说明，-a对应标签名，-m对应描述信息<br>git tag -a v0.1 -m “描述信息” 版本号</p><h3 id="查看标签具体信息"><a href="#查看标签具体信息" class="headerlink" title="查看标签具体信息"></a>查看标签具体信息</h3><p>git show 标签名</p><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>git tag -d 标签名</p><h3 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h3><p>推送某个标签到远程<br>git push origin 标签名</p><h3 id="推送所有标签到远程"><a href="#推送所有标签到远程" class="headerlink" title="推送所有标签到远程"></a>推送所有标签到远程</h3><p>git push origin –tags</p><h3 id="删除远程标签："><a href="#删除远程标签：" class="headerlink" title="删除远程标签："></a>删除远程标签：</h3><p>先删除本地标签<br>git tag -d 标签名<br>然后从远程删除<br>git push origin: refs/tags/标签名</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode搭建STM32开发环境</title>
      <link href="/20230601/learn_base/VSCode%E6%90%AD%E5%BB%BASTM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"/>
      <url>/20230601/learn_base/VSCode%E6%90%AD%E5%BB%BASTM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html</url>
      
        <content type="html"><![CDATA[<p>玩过单片机的都知道，Keil是一款收费软件，虽然有相应的方法可以正常使用，但还是少不了很多麻烦，并且keil的界面对于我们开发者来说非常不友好。那么这时VSCode的出现就很好的解决了这一问题。今天我们就来使用VSCode搭建STM32的开发环境。<br>老样子，后台回复“stm32”领取本节相关文件。 </p><h1 id="工具下载及环境配置"><a href="#工具下载及环境配置" class="headerlink" title="工具下载及环境配置"></a>工具下载及环境配置</h1><p>1、STM32CubeMX， ST官方的初始化代码生成工具<br>2、Visual Studio Code，代码编辑器<br>3、MingGW，gcc，主要用于make<br>4、GNU Arm Embedded Toolchain，交叉编译工具链<br>5、OpenOCD，烧录工具</p><p>其中MingGW，GNU Arm Embedded Toolchain，openocd需要将其解压后的bin目录添加要path环境变量<br>MingGW中需要进入到x:\mingw64\bin目录下（x代表解压后的存放盘符），将mingw32-make.exe复制一份，修改为make.exe<br>添加完成后通过命令行测试是否成功</p><pre class="line-numbers language-none"><code class="language-none">make -varm-none-eabi-gcc -vopenocd -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如配置正确，将会得到相应的版本信息。</p><h1 id="VSCode插件安装"><a href="#VSCode插件安装" class="headerlink" title="VSCode插件安装"></a>VSCode插件安装</h1><p>1、C/C++ Extension Pack<br>2、Cortex-Debug<br>3、One Dark Pro（主题插件）<br>4、vscode-icons（文件图标插件）<br>5、Rainbow Brackets（彩虹括号插件）<br>其中前两个为必须安装，后三个强烈建议，但可不用</p><p>#使用STM32CubeMX生成初始化代码<br>在Project Manager中的Toolchain/IDE选择Makefile（如下图），其余时钟外设等该怎么配置就怎么配置，配置好后点GENERATE CODE 生成。<br><img src="/images/learn/env/2ccjxkZl51ljp0V9S4p6GA_001.png" alt="图片"></p><h1 id="使用VSCode开发"><a href="#使用VSCode开发" class="headerlink" title="使用VSCode开发"></a>使用VSCode开发</h1><p>生成后使用VSCode打开文件夹，文件如下<br><img src="/images/learn/env/2ccjxkZl51ljp0V9S4p6GA_002.png" alt="图片"><br>这时我们打开Makefile，可以看到宏定义，以及头文件和源文件<br><img src="/images/learn/env/2ccjxkZl51ljp0V9S4p6GA_003.png" alt="图片"><br><img src="/images/learn/env/2ccjxkZl51ljp0V9S4p6GA_004.png" alt="图片"></p><p>我们随机打开一个.c文件，可以看到有非常多波浪线的错误提示，虽然不影响编译，但是看着总是有点不舒服，只是因为VSCode不知去哪里索引。这时我们按下ctrl+shift+p快捷键，输入 c/c++自动弹出<br><img src="/images/learn/env/2ccjxkZl51ljp0V9S4p6GA_005.png" alt="图片"><br>我们点击编辑配置(JSON)，会在.vscode下自动创建一个c_cpp_properties.json文件，将Makefile中的两个宏定义添加到c_cpp_properties.json文件的defines处，删去前面的-D，同时核对自己的compilerPath路径是否正确，此为MinGW的gcc路径，最后修改后的如下所示</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;Win32&quot;,            &quot;includePath&quot;: [                &quot;$&#123;workspaceFolder&#125;&#x2F;**&quot;            ],            &quot;defines&quot;: [                &quot;_DEBUG&quot;,                &quot;UNICODE&quot;,                &quot;_UNICODE&quot;,                &quot;USE_HAL_DRIVER&quot;,                &quot;STM32L475xx&quot;            ],            &quot;windowsSdkVersion&quot;: &quot;10.0.19041.0&quot;,            &quot;compilerPath&quot;: &quot;D:&#x2F;mingw64&#x2F;bin&#x2F;gcc.exe&quot;,            &quot;cStandard&quot;: &quot;c17&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;,            &quot;intelliSenseMode&quot;: &quot;gcc-arm&quot;,            &quot;configurationProvider&quot;: &quot;ms-vscode.makefile-tools&quot;        &#125;    ],    &quot;version&quot;: 4&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后打开终端，输入make即可编译，成功生成bin和hex文件，如果觉得输出的信息太乱，可以设置为静默编译，修改Makefile文件，在命令前加@，同时echo当前编译的文件</p><pre class="line-numbers language-none"><code class="language-none">$(BUILD_DIR)&#x2F;%.o: %.c Makefile | $(BUILD_DIR)   @echo &quot;build $&lt;&quot;  @$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms&#x3D;$(BUILD_DIR)&#x2F;$(notdir $(&lt;:.c&#x3D;.lst)) $&lt; -o $@$(BUILD_DIR)&#x2F;%.o: %.s Makefile | $(BUILD_DIR)  @echo &quot;build $&lt;&quot;  @$(AS) -c $(CFLAGS) $&lt; -o $@$(BUILD_DIR)&#x2F;$(TARGET).elf: $(OBJECTS) Makefile  @echo &quot;build $&lt;&quot;  @$(CC) $(OBJECTS) $(LDFLAGS) -o $@  $(SZ) $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后的效果如下图所示<br><img src="/images/learn/env/2ccjxkZl51ljp0V9S4p6GA_006.png" alt="图片"><br>由于window并不支持-rm -fR命令，所以需要将Makefile文件中的clean命令做相应修改</p><pre class="line-numbers language-none"><code class="language-none">clean:  del &#x2F;Q $(BUILD_DIR)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>之后我们可以通过命令make clean测试一下，发现成功删除编译生成的文件。</p><h1 id="使用openocd烧写代码"><a href="#使用openocd烧写代码" class="headerlink" title="使用openocd烧写代码"></a>使用openocd烧写代码</h1><p>目录openocd-20211118\OpenOCD-20211118-0.11.0\share\openocd\scripts\interface 下载器的配置文件<br>目录openocd-20211118\OpenOCD-20211118-0.11.0\share\openocd\scripts\target 芯片的配置文件<br>在以上两个目录中找到你所使用的烧写器的配置文件和芯片配置文件，我使用的是stlinkv2和stm32l475<br>将他们复制到你的工程目录下<br><img src="/images/learn/env/2ccjxkZl51ljp0V9S4p6GA_007.png" alt="图片"><br>在前面的编译中，敲命令的方式多少有点繁琐，所以我们将其添加为一个任务，通过点击这个任务按钮完成编译及下载等操作。<br>在VSCode中的终端-&gt;运行任务-&gt;添加配置任务-&gt;使用模板创建tasks.json文件-&gt;others，编辑tasks.json文件</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        &#123;            &quot;label&quot;: &quot;build&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;make&quot;,            &quot;args&quot;: [            ],            &quot;group&quot;: &quot;build&quot;        &#125;,        &#123;            &quot;label&quot;: &quot;download&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;openocd&quot;,            &quot;args&quot;: [                &quot;-f&quot;,                &quot;stlink-v2.cfg&quot;,                &quot;-f&quot;,                &quot;stm32l4x.cfg&quot;,                &quot;-c&quot;,                &quot;program build&#x2F;Test_L475.elf verify reset exit&quot;            ],            &quot;group&quot;: &quot;build&quot;        &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后可以在终端-&gt;运行任务中多出build和download两个选项，点击即可相应的构建及下载代码。</p><h1 id="配置单步调试"><a href="#配置单步调试" class="headerlink" title="配置单步调试"></a>配置单步调试</h1><p>在最左侧的debug标签点击创建launch.json文件，选择Cortex Debug会生成一个初始模板。<br><img src="/images/learn/env/2ccjxkZl51ljp0V9S4p6GA_008.png" alt="图片"><br>点击添加配置，选择Cortex Debug：OPENOCD会自动添加一个代码修改模板，对它的参数进行修改。</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,            &quot;executable&quot;: &quot;.&#x2F;build&#x2F;Test_L475.elf&quot;,            &quot;name&quot;: &quot;Debug with OpenOCD&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;type&quot;: &quot;cortex-debug&quot;,            &quot;servertype&quot;: &quot;openocd&quot;,            &quot;configFiles&quot;: [                &quot;stlink-v2.cfg&quot;,                &quot;stm32l4x.cfg&quot;            ],            &quot;showDevDebugOutput&quot;: &quot;none&quot;            &#x2F;&#x2F; &quot;svdFile&quot;: &quot;.&#x2F;STM32L4x5.svd&quot;     &#x2F;&#x2F;此为片上外设寄存器文件，可不添加        &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完后，设置断点，按F5进入调试模式，即可调试自己的程序。<br><img src="/images/learn/env/2ccjxkZl51ljp0V9S4p6GA_009.png" alt="图片"><br>完成以上所有配置后，即可完全摆脱keil，使用VSCode开发STM32</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在gcc里面重定向用的不是fputc，重定向函数为</p><pre class="line-numbers language-none"><code class="language-none">int _write(int file, char *ptr, int len)&#123;  HAL_UART_Transmit(&amp;huart1, (uint8_t *)ptr, len, 0xFFFF);  return len;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加后即可使用串口打印</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAT穿透技术、穿透原理和方法详解</title>
      <link href="/20230601/learn_nathole/NAT%E7%A9%BF%E9%80%8F%E6%8A%80%E6%9C%AF%E3%80%81%E7%A9%BF%E9%80%8F%E5%8E%9F%E7%90%86%E5%92%8C%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
      <url>/20230601/learn_nathole/NAT%E7%A9%BF%E9%80%8F%E6%8A%80%E6%9C%AF%E3%80%81%E7%A9%BF%E9%80%8F%E5%8E%9F%E7%90%86%E5%92%8C%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="NAT分类"><a href="#NAT分类" class="headerlink" title="NAT分类"></a>NAT分类</h1><p><img src="/images/learn/nathole/sp_sZnWg_eN3LoFB9lvXxg_001.png" alt="图片"></p><h1 id="穿透流程图"><a href="#穿透流程图" class="headerlink" title="穿透流程图"></a>穿透流程图</h1><p><img src="/images/learn/nathole/sp_sZnWg_eN3LoFB9lvXxg_006.jpg" alt="图片"></p><p>推荐视频<br>P2P技术—NAT原理，NAT类型，网络穿透原理</p><p>从50道腾讯面试题，分析腾讯c++后端工程的技能树</p><p>学习地址：C/C++Linux服务器开发/后台架构师【零声教育】-学习视频教程-腾讯课堂</p><h2 id="基础型NAT"><a href="#基础型NAT" class="headerlink" title="基础型NAT"></a>基础型NAT</h2><p>仅将内网主机的私有IP地址转换成公网的IP地址，并不将TCP/UDP端口信息进行转换，分为静态NAT和动态NAT。</p><h2 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h2><p>NAPT不但会改变经过这个NAT设备的IP数据报的IP地址，还会改变IP数据报的TCP/UDP端口。</p><h3 id="锥型NAT"><a href="#锥型NAT" class="headerlink" title="锥型NAT"></a>锥型NAT</h3><blockquote><ul><li>完全锥型（Full Cone NAT）：在不同内网的主机A和B各自连接到服务器C，服务器收到A和B的连接后知道了他们的公网地址和NAT分配给他们的端口号，然后把这些NAT地址和端口号交叉告诉B和A。A和B给服务器所打开的“孔”可以给任何主机使用。如一私网主机地址是192.168.1.100:30000发至公网的所有请求都映射成一个公网地址172.1.20.100:20000，192.168.1.100:30000可以接收任何主机发给172.1.20.100:20000的数据报文。</li><li>受限制锥型（Restricted cone）：主机A和B同样需要各自连接服务器C，同时把A和B的地址告诉B和A，但一般情况下它们只能与服务器通信。要想直接通信需要发送消息给服务器C，如主机A发送一个UDP消息到主机B的公网地址上，与此同时，A又通过服务器C中转发送一个邀请信息给主机B，请求主机B也给主机A发送一个UDP消息到主机A的公网地址上。这时主机A向主机B的公网IP发送的信息导致NAT A打开一个处于主机A的和主机B之间的会话，与此同时，NAT B也打开了一个处于主机B和主机A的会话。一旦这个新的UDP会话各自向对方打开了，主机A和主机B之间才可以直接通信。</li><li>端口受限锥型（Port-restricted）：与受限制锥型类似，与之不同的是还要指定端口号。</li></ul></blockquote><h3 id="对称NAT（Symmetric）"><a href="#对称NAT（Symmetric）" class="headerlink" title="对称NAT（Symmetric）"></a>对称NAT（Symmetric）</h3><p>对不同的外网IP地址都会分配不同的端口号。</p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>对称NAT是一个请求对应一个端口，非对称NAT是多个请求对应一个端口(象锥形，所以叫Cone NAT)。</p><h2 id="安全系数"><a href="#安全系数" class="headerlink" title="安全系数"></a>安全系数</h2><p>对称型 &gt; 端口受限锥型 &gt; 受限锥型 &gt; 全锥型</p><h1 id="网络打洞"><a href="#网络打洞" class="headerlink" title="网络打洞"></a>网络打洞</h1><h2 id="打洞条件"><a href="#打洞条件" class="headerlink" title="打洞条件"></a>打洞条件</h2><p>中间服务器保存信息、并能发出建立UDP隧道的命令<br>网关均要求为Cone NAT类型。Symmetric NAT不适合。<br>完全圆锥型网关可以无需建立udp隧道，但这种情况非常少，要求双方均为这种类型网关的更少。</p><blockquote><p>假如X1网关为Symmetric NAT， Y1为Address Restricted Cone NAT 或Full Cone NAT型网关，各自建立隧道后，A1可通过X1发送数据报给Y1到B1(因为Y1最多只进行IP级别的甄别)，但B2发送给X1的将会被丢弃（因为发送来的数据报中端口与X1上存在会话的端口不一致，虽然IP地址一致），所以同样没有什么意义。<br>假如双方均为Symmetric NAT的情形，新开了端口，对方可以在不知道的情况下尝试猜解，也可以达到目的，但这种情形成功率很低，且带来额外的系统开支，不是个好的解决办法。pwnat工具据说可以实现。<br>不同网关型设置的差异在于，对内会采用替换IP的方式、使用不同端口不同会话的方式，使用相同端口不同会话的方式；对外会采用什么都不限制、限制IP地址、限制IP地址及端口。<br>这里还没有考虑同一内网不同用户同时访问同一服务器的情形，如果此时网关采用AddressRestricted Cone NAT 或Full Cone NAT型，有可能导致不同用户客户端可收到别人的数据包，这显然是不合适的。</p></blockquote><h2 id="打洞流程"><a href="#打洞流程" class="headerlink" title="打洞流程"></a>打洞流程</h2><p>不同的网络拓扑NAT打洞的方法和流程有所区别。</p><h3 id="同一个NAT设备下"><a href="#同一个NAT设备下" class="headerlink" title="同一个NAT设备下"></a>同一个NAT设备下</h3><p><img src="/images/learn/nathole/sp_sZnWg_eN3LoFB9lvXxg_002.png" alt="图片"></p><blockquote><p>clinet A与Server S建立UDP连接，公共NAT（155.99.25.11）给client A分配一个公网端口62000；<br>client B与Server S建立UDP连接，公共NAT（155.99.25.11）给client A分配一个公网端口62005；<br>client A通过Server S发送一个消息要求连接client B，S给A回应B的公网和私网地址，并转发A的公网和私网地址给B；<br>A和B根据获取的地址试图直接发送UDP数据报文；是否成功取决于NAT设备是否支持hairpin translation（端口回流）。——打开端口回流相当于与client A的数据经过NAT设备转发后才到达client B，即从外网NAT接口绕了一圈再访问到同一个子网里的client B。（优点是可以防止内部攻击）</p></blockquote><h3 id="不同NAT设备下"><a href="#不同NAT设备下" class="headerlink" title="不同NAT设备下"></a>不同NAT设备下</h3><p><img src="/images/learn/nathole/sp_sZnWg_eN3LoFB9lvXxg_003.png" alt="图片"></p><blockquote><p>1、A使用4321端口与S连接，NAT给回话在NAT分配外网62000端口（155.99.25.11:62000）与S连接；同理B以相同的方式与S连接，分配的外网地址端口是138.76.29.7:31000。<br>2、A往S注册消息包里包含里A的私有地址10.0.0.1:4321，此时S保存了A的地址；S给A临时分配了一个用于公网的地址（155.99.25.11:62000），同时用于观察外网数据包。<br>3、同理B往S注册的消息包里也包含里B的地址，NAT同样给B临时分类了一个外网地址（138.76.29.7:31000）。<br>4、Client A根据以上已知信息通过打洞的方式与B连接UDP通信：</p><blockquote><p>  Client A发送请求消息，寻求连接B；<br>  S给A回应B的外网和内网地址，通给给B发送A的外网和内网地址；<br>  A和B开始利用这些地址尝试直接发送UDP报文给彼此，不幸的是，此时A和B都无法接收对应的消息。因为A和B都是在不同的私有网络中，A和B之前都是与S通信回话，并没有与对方建立回话；即A没有为B打开一个洞，B也没有为A打开一个洞。这个过程的第一个报文需要会被拒绝同时打开对应的“洞”，随后才可以直接通信，具体如下：<br>  A给B公网地址（10.0.0.1:4321 to 138.76.29.7:31000）发送的第一个报文，实际上是在A的NAT私有网络上“打洞”来为新识别的地址(10.0.0.1:4321 138.76.29.7:31000) 建立UDP会话,并经主网地址(155.99.25.11:62000 138.76.29.7:31000)来传送。<br>  如果A发送到B的公网地址的消息在B发送到A的第一个消息越过B自己的NAT之前到达B的NAT，那么B的NAT可能会将A的入站消息解释为非请求的传入通信量并丢弃它。<br>  同理，B给A公网地址方法的第一个消息也会在B的NAT上“打洞”来为地址（10.1.1.3:4321, 155.99.25.11:62000）建立回话。<br>  随后可以正常P2P通信。</p></blockquote></blockquote><h3 id="多层NAT下"><a href="#多层NAT下" class="headerlink" title="多层NAT下"></a>多层NAT下</h3><p><img src="/images/learn/nathole/sp_sZnWg_eN3LoFB9lvXxg_004.png" alt="图片"></p><blockquote><p>说明：NAT C 是一个大型的工业NAT设备，由ISP（Internet Service Provider，互联网服务提供商）部署，用于将许多客户多路复用到几个公共IP地址上。<br>Client A和client B无法通道NAT A和NAT A进行P2P通信，因为它们属于NAT C的局域网地址，因此client A和client B只能通道NAT C的hairpin translation进行P2P通信，如果NAT C不支持hairpin translation，则它们很难进行P2P通信。<br>每个客户机像前面方式一样启动到服务器S的连接，引起NAT A和B各自创建一个单独的公共/私有转化——session A-S（18.181.0.31:1234 10.0.0.1:4321）和session B-S（18.181.0.31:1234 10.1.1.3:4321），并引起NAT C为每个会话建立一个公共/私有翻译——session A-S（18.181.0.31:1234 10.0.1.1:45000）和session B-S（18.181.0.31:1234 10.0.1.2:5500）。</p><blockquote><p>  首先client A给client B的公网地址（155.99.25.11:62005）发送消息；<br>  NAT A翻译原数据报文从10.0.0.1:4321带10.0.0.1:45000；<br>  数据报现在到达NAT C，它识别出数据报的目标地址是NAT C自己翻译的公共地址之一；<br>  如果NAT C是好的，那么其能翻译出数据报文的源地址和目标地址（155.99.25.11:62000和10.0.1.2:55000），同时通过“回环”返回数据包到私有网络；<br>  NAT B 翻译数据报文得到NAT B私网地址，最终到达client B。<br>  Client B给client A发送数据报文与上述步骤类似。</p></blockquote></blockquote><h2 id="打洞组合"><a href="#打洞组合" class="headerlink" title="打洞组合"></a>打洞组合</h2><p>不同的NAT组合打洞的方式也有所不同，有点可以打洞，有的则不能打洞，如两个都是对称型设备则无法实现打洞。不同组合打洞结果如下：</p><p><img src="/images/learn/nathole/sp_sZnWg_eN3LoFB9lvXxg_005.png" alt="图片"></p><h1 id="关联技术"><a href="#关联技术" class="headerlink" title="关联技术"></a>关联技术</h1><blockquote><ul><li>ALG：即应用程序级网关技术：传统的NAT技术只对IP层和传输层头部进行转换处理，但是一些应用层协议，在协议数据报文中包含了地址信息。为了使得这些应用也能透明地完成NAT转换，NAT使用一种称作ALG的技术，它能对这些应用程序在通信时所包含的地址信息也进行相应的NAT转换。主要类似与在网关上专门开辟一个通道，用于建立内网与外网的连接，也就是说，这是一种定制的网关。更多只适用于使用他们的应用群体内部之间。</li><li>UpnP：它是让网关设备在进行工作时寻找一个全球共享的可路由IP来作为通道，这样避免端口造成的影响。要求设备支持且开启upnp功能，但大部分时候，这些功能处于安全考虑，是被关闭的。即时开启，实际应用效果还没经过测试。</li><li>STUN（Simple Traversalof UDP Through Network）：这种方式即是类似于我们上面举例中服务器C的处理方式。也是目前普遍采用的方式。但具体实现要比我们描述的复杂许多，光是做网关Nat类型判断就由许多工作，RFC3489中详细描述了。</li><li>TURN(Traveral Using Relay NAT)：该方式是将所有的数据交换都经由服务器来完成，这样NAT将没有障碍，但服务器的负载、丢包、延迟性就是很大的问题。目前很多游戏均采用该方式避开NAT的问题。这种方式不叫p2p。</li><li>ICE(Interactive Connectivity Establishment)：是对上述各种技术的综合，但明显带来了复杂性。</li></ul></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="对称NAT设备常用场景"><a href="#对称NAT设备常用场景" class="headerlink" title="对称NAT设备常用场景"></a>对称NAT设备常用场景</h2><p>1 使用第三方宽带公司提供的宽带，这类宽带给用户分配的是局域网IP，连接公网的NAT是运营商的，这类运营商一般采用对称NAT。<br>2 移动互联网，如3G、4G终端设备；<br>3 大公司路由器一般采用对称NAT；</p><h2 id="影响“打洞”的因素"><a href="#影响“打洞”的因素" class="headerlink" title="影响“打洞”的因素"></a>影响“打洞”的因素</h2><blockquote><p>许多对称nat以一种相当可预测的方式为连续的会话分配端口号，而有时分配到的端口刚好被别的应用使用了。<br>Client有可能分到多个公网地址，例如：在NAT将公网地址155.99.25.11:62000分配给client A与S的会话之后，NAT可能会将另一个公网地址(如155.99.25.11:62001)分配给A试图发起与B的P2P会话。在这种情况下，依据提供的连接打洞过程将失败，因为后续来自B的传入消息到达NAT A的错误端口号<br>其他</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 网络穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2P之UDP穿透NAT的原理与实现</title>
      <link href="/20230601/learn_nathole/P2P%E4%B9%8BUDP%E7%A9%BF%E9%80%8FNAT%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.html"/>
      <url>/20230601/learn_nathole/P2P%E4%B9%8BUDP%E7%A9%BF%E9%80%8FNAT%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.html</url>
      
        <content type="html"><![CDATA[<p>日期：2004-5-25<br>出处：P2P中国(PPcn.net)<br>作者：shootingstars (有容乃大，无欲则刚)</p><p>论坛上经常有对P2P原理的讨论，但是讨论归讨论，很少有实质的东西产生（源代码）。呵呵，在这里我就用自己实现的一个源代码来说明UDP穿越NAT的原理。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>NAT(Network Address Translators)，网络地址转换：网络地址转换是在IP地址日益缺乏的情况下产生的，它的主要目的就是为了能够地址重用。NAT分为两大类，基本的NAT和NAPT(Network Address/Port Translator)。<br>最开始NAT是运行在路由器上的一个功能模块。</p><h1 id="穿透流程"><a href="#穿透流程" class="headerlink" title="穿透流程"></a>穿透流程</h1><p><img src="/images/learn/nathole/sp_sZnWg_eN3LoFB9lvXxg_006.jpg" alt="图片"> </p><p>最先提出的是基本的NAT，它的产生基于如下事实：一个私有网络（域）中的节点中只有很少的节点需要与外网连接（呵呵，这是在上世纪90年代中期提出的）。那么这个子网中其实只有少数的节点需要全球唯一的IP地址，其他的节点的IP地址应该是可以重用的。<br>因此，基本的NAT实现的功能很简单，在子网内使用一个保留的IP子网段，这些IP对外是不可见的。子网内只有少数一些IP地址可以对应到真正全球唯一的IP地址。如果这些节点需要访问外部网络，那么基本NAT就负责将这个节点的子网内IP转化为一个全球唯一的IP然后发送出去。(基本的NAT会改变IP包中的原IP地址，但是不会改变IP包中的端口)关于基本的NAT可以参看RFC 1631</p><p>另外一种NAT叫做NAPT，从名称上我们也可以看得出，NAPT不但会改变经过这个NAT设备的IP数据报的IP地址，还会改变IP数据报的TCP/UDP端口。基本NAT的设备可能我们见的不多（呵呵，我没有见到过），NAPT才是我们真正讨论的主角。看下图：<br><img src="/images/learn/nathole/sp_sZnWg_eN3LoFB9lvXxg_001.png" alt="图片"></p><p>有一个私有网络10.<em>.</em>.*，Client A是其中的一台计算机，这个网络的网关（一个NAT设备）的外网IP是155.99.25.11(应该还有一个内网的IP地址，比如10.0.0.10)。如果Client A中的某个进程（这个进程创建了一个UDP Socket,这个Socket绑定1234端口）想访问外网主机18.181.0.31的1235端口，那么当数据包通过NAT时会发生什么事情呢？<br>首先NAT会改变这个数据包的原IP地址，改为155.99.25.11。接着NAT会为这个传输创建一个Session（Session是一个抽象的概念，如果是TCP，也许Session是由一个SYN包开始，以一个FIN包结束。而UDP呢，以这个IP的这个端口的第一个UDP开始，结束呢，呵呵，也许是几分钟，也许是几小时，这要看具体的实现了）并且给这个Session分配一个端口，比如62000，然后改变这个数据包的源端口为62000。所以本来是（10.0.0.1:1234-&gt;18.181.0.31:1235）的数据包到了互联网上变为了（155.99.25.11:62000-&gt;18.181.0.31:1235）。<br>一旦NAT创建了一个Session后，NAT会记住62000端口对应的是10.0.0.1的1234端口，以后从18.181.0.31发送到62000端口的数据会被NAT自动的转发到10.0.0.1上。（注意：这里是说18.181.0.31发送到62000端口的数据会被转发，其他的IP发送到这个端口的数据将被NAT抛弃）这样Client A就与Server S1建立以了一个连接。<br>呵呵，上面的基础知识可能很多人都知道了，那么下面是关键的部分了。</p><p>看看下面的情况：</p><pre class="line-numbers language-none"><code class="language-none">   Server S1                                     Server S218.181.0.31:1235                              138.76.29.7:1235       |                                             |       |                                             |       +----------------------+----------------------+                              |  ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^  |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |  v 155.99.25.11:62000 v      |      v 155.99.25.11:62000 v                              |                           Cone NAT                         155.99.25.11                              |  ^  Session 1 (A-S1)  ^      |      ^  Session 2 (A-S2)  ^  |  18.181.0.31:1235  |      |      |  138.76.29.7:1235  |  v   10.0.0.1:1234    v      |      v   10.0.0.1:1234    v                              |                           Client A                        10.0.0.1:1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接上面的例子，如果Client A的原来那个Socket(绑定了1234端口的那个UDP Socket)又接着向另外一个Server S2发送了一个UDP包，那么这个UDP包在通过NAT时会怎么样呢？<br>这时可能会有两种情况发生，一种是NAT再次创建一个Session，并且再次为这个Session分配一个端口号（比如：62001）。另外一种是NAT再次创建一个Session，但是不会新分配一个端口号，而是用原来分配的端口号62000。前一种NAT叫做Symmetric NAT，后一种叫做Cone NAT。我们期望我们的NAT是第二种，呵呵，如果你的NAT刚好是第一种，那么很可能会有很多P2P软件失灵。（可以庆幸的是，现在绝大多数的NAT属于后者，即Cone NAT）<br>好了，我们看到，通过NAT,子网内的计算机向外连结是很容易的（NAT相当于透明的，子网内的和外网的计算机不用知道NAT的情况）。<br>但是如果外部的计算机想访问子网内的计算机就比较困难了（而这正是P2P所需要的）。<br>那么我们如果想从外部发送一个数据报给内网的计算机有什么办法呢？首先，我们必须在内网的NAT上打上一个“洞”（也就是前面我们说的在NAT上建立一个Session），这个洞不能由外部来打，只能由内网内的主机来打。而且这个洞是有方向的，比如从内部某台主机（比如：192.168.0.10）向外部的某个IP(比如：219.237.60.1)发送一个UDP包，那么就在这个内网的NAT设备上打了一个方向为219.237.60.1的“洞”，（这就是称为UDP Hole Punching的技术）以后219.237.60.1就可以通过这个洞与内网的192.168.0.10联系了。（但是其他的IP不能利用这个洞）。<br>呵呵，现在该轮到我们的正题P2P了。有了上面的理论，实现两个内网的主机通讯就差最后一步了：那就是鸡生蛋还是蛋生鸡的问题了，两边都无法主动发出连接请求，谁也不知道谁的公网地址，那我们如何来打这个洞呢？我们需要一个中间人来联系这两个内网主机。<br>现在我们来看看一个P2P软件的流程，以下图为例：<br><img src="/images/learn/nathole/sp_sZnWg_eN3LoFB9lvXxg_007.png" alt="图片"> </p><p>首先，Client A登录服务器，NAT A为这次的Session分配了一个端口60000，那么Server S收到的Client A的地址是202.187.45.3:60000，这就是Client A的外网地址了。同样，Client B登录Server S，NAT B给此次Session分配的端口是40000，那么Server S收到的B的地址是187.34.1.56:40000。<br>此时，Client A与Client B都可以与Server S通信了。如果Client A此时想直接发送信息给Client B，那么他可以从Server S那儿获得B的公网地址187.34.1.56:40000，是不是Client A向这个地址发送信息Client B就能收到了呢？答案是不行，因为如果这样发送信息，NAT B会将这个信息丢弃（因为这样的信息是不请自来的，为了安全，大多数NAT都会执行丢弃动作）。现在我们需要的是在NAT B上打一个方向为202.187.45.3（即Client A的外网地址）的洞，那么Client A发送到187.34.1.56:40000的信息,Client B就能收到了。这个打洞命令由谁来发呢，呵呵，当然是Server S。<br>总结一下这个过程：如果Client A想向Client B发送信息，那么Client A发送命令给Server S，请求Server S命令Client B向Client A方向打洞。呵呵，是不是很绕口，不过没关系，想一想就很清楚了，何况还有源代码呢（侯老师说过：在源代码面前没有秘密 8）），然后Client A就可以通过Client B的外网地址与Client B通信了。</p><p>注意：以上过程只适合于Cone NAT的情况，如果是Symmetric NAT，那么当Client B向Client A打洞的端口已经重新分配了，Client B将无法知道这个端口（如果Symmetric NAT的端口是顺序分配的，那么我们或许可以猜测这个端口号，可是由于可能导致失败的因素太多，我们不推荐这种猜测端口的方法）。</p><h1 id="参考源代码"><a href="#参考源代码" class="headerlink" title="参考源代码"></a>参考源代码</h1><p>下面是一个模拟P2P聊天的过程的源代码，过程很简单，P2PServer运行在一个拥有公网IP的计算机上，P2PClient运行在两个不同的NAT后（注意，如果两个客户端运行在一个NAT后，本程序很可能不能运行正常，这取决于你的NAT是否支持loopback translation，详见<code>http://midcom-p2p.sourceforge.net/draft-ford-midcom-p2p-01.txt</code>，当然，此问题可以通过双方先尝试连接对方的内网IP来解决，但是这个代码只是为了验证原理，并没有处理这些问题），后登录的计算机可以获得先登录计算机的用户名，后登录的计算机通过send username message的格式来发送消息。如果发送成功，说明你已取得了直接与对方连接的成功。<br>程序现在支持三个命令：send , getu , exit</p><h2 id="lt-send-gt-命令"><a href="#lt-send-gt-命令" class="headerlink" title="&lt;send&gt; 命令"></a>&lt;send&gt; 命令</h2><p>格式：send username message<br>功能：发送信息给username</p><h2 id="lt-getu-gt-命令"><a href="#lt-getu-gt-命令" class="headerlink" title="&lt;getu&gt; 命令"></a>&lt;getu&gt; 命令</h2><p>格式：getu<br>功能：获得当前服务器用户列表</p><h2 id="lt-exit-gt-命令"><a href="#lt-exit-gt-命令" class="headerlink" title="&lt;exit&gt; 命令"></a>&lt;exit&gt; 命令</h2><p>格式：exit<br>功能：注销与服务器的连接（服务器不会自动监测客户是否吊线）</p><p>代码很短，相信很容易懂，如果有什么问题，可以给我发邮件<a href="mailto:&#122;&#x68;&#111;&#117;&#x68;&#117;&#105;&#115;&#x32;&#x32;&#x40;&#115;&#x69;&#x6e;&#x61;&#46;&#99;&#111;&#109;">&#122;&#x68;&#111;&#117;&#x68;&#117;&#105;&#115;&#x32;&#x32;&#x40;&#115;&#x69;&#x6e;&#x61;&#46;&#99;&#111;&#109;</a>  或者在CSDN上发送短消息。同时，欢迎转发此文，但希望保留作者版权8-）。</p><p>最后感谢CSDN网友 PiggyXP 和 Seilfer的测试帮助</p><h2 id="服务端源代码"><a href="#服务端源代码" class="headerlink" title="服务端源代码"></a>服务端源代码</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;* P2P 程序服务端 *  * 文件名：P2PServer.c * * 日期：2004-5-21 * * 作者：shootingstars(zhouhuis22@sina.com) * *&#x2F;#pragma comment(lib, &quot;ws2_32.lib&quot;)#include &quot;windows.h&quot;#include &quot;..\proto.h&quot;#include &quot;..\Exception.h&quot;UserList ClientList;void InitWinSock()&#123; WSADATA wsaData; if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) !&#x3D; 0) &#123;  printf(&quot;Windows sockets 2.2 startup&quot;);  throw Exception(&quot;&quot;); &#125; else&#123;  printf(&quot;Using %s (Status: %s)\n&quot;,   wsaData.szDescription, wsaData.szSystemStatus);  printf(&quot;with API versions %d.%d to %d.%d\n\n&quot;,   LOBYTE(wsaData.wVersion), HIBYTE(wsaData.wVersion),   LOBYTE(wsaData.wHighVersion), HIBYTE(wsaData.wHighVersion));   &#125;&#125;SOCKET mksock(int type)&#123; SOCKET sock &#x3D; socket(AF_INET, type, 0); if (sock &lt; 0) &#123;        printf(&quot;create socket error&quot;);  throw Exception(&quot;&quot;); &#125; return sock;&#125;stUserListNode GetUser(char *username)&#123; for(UserList::iterator UserIterator&#x3D;ClientList.begin();      UserIterator!&#x3D;ClientList.end();       ++UserIterator) &#123;  if( strcmp( ((*UserIterator)-&gt;userName), username) &#x3D;&#x3D; 0 )   return *(*UserIterator); &#125; throw Exception(&quot;not find this user&quot;);&#125;int main(int argc, char* argv[])&#123; try&#123;  InitWinSock();    SOCKET PrimaryUDP;  PrimaryUDP &#x3D; mksock(SOCK_DGRAM);  sockaddr_in local;  local.sin_family&#x3D;AF_INET;  local.sin_port&#x3D; htons(SERVER_PORT);   local.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);  int nResult&#x3D;bind(PrimaryUDP,(sockaddr*)&amp;local,sizeof(sockaddr));  if(nResult&#x3D;&#x3D;SOCKET_ERROR)   throw Exception(&quot;bind error&quot;);  sockaddr_in sender;  stMessage recvbuf;  memset(&amp;recvbuf,0,sizeof(stMessage));  &#x2F;&#x2F; 开始主循环.  &#x2F;&#x2F; 主循环负责下面几件事情:  &#x2F;&#x2F; 一:读取客户端登陆和登出消息,记录客户列表  &#x2F;&#x2F; 二:转发客户p2p请求  for(;;)  &#123;   int dwSender &#x3D; sizeof(sender);   int ret &#x3D; recvfrom(PrimaryUDP, (char *)&amp;recvbuf, sizeof(stMessage), 0, (sockaddr *)&amp;sender, &amp;dwSender);   if(ret &lt;&#x3D; 0)   &#123;    printf(&quot;recv error&quot;);    continue;   &#125;   else   &#123;    int messageType &#x3D; recvbuf.iMessageType;    switch(messageType)&#123;    case LOGIN:     &#123;      &#x2F;&#x2F;  将这个用户的信息记录到用户列表中      printf(&quot;has a user login : %s\n&quot;, recvbuf.message.loginmember.userName);      stUserListNode *currentuser &#x3D; new stUserListNode();      strcpy(currentuser-&gt;userName, recvbuf.message.loginmember.userName);      currentuser-&gt;ip &#x3D; ntohl(sender.sin_addr.S_un.S_addr);      currentuser-&gt;port &#x3D; ntohs(sender.sin_port);            ClientList.push_back(currentuser);      &#x2F;&#x2F; 发送已经登陆的客户信息      int nodecount &#x3D; (int)ClientList.size();      sendto(PrimaryUDP, (const char*)&amp;nodecount, sizeof(int), 0, (const sockaddr*)&amp;sender, sizeof(sender));      for(UserList::iterator UserIterator&#x3D;ClientList.begin();        UserIterator!&#x3D;ClientList.end();        ++UserIterator)      &#123;       sendto(PrimaryUDP, (const char*)(*UserIterator), sizeof(stUserListNode), 0, (const sockaddr*)&amp;sender, sizeof(sender));       &#125;      break;     &#125;    case LOGOUT:     &#123;      &#x2F;&#x2F; 将此客户信息删除      printf(&quot;has a user logout : %s\n&quot;, recvbuf.message.logoutmember.userName);      UserList::iterator removeiterator &#x3D; NULL;      for(UserList::iterator UserIterator&#x3D;ClientList.begin();       UserIterator!&#x3D;ClientList.end();       ++UserIterator)      &#123;       if( strcmp( ((*UserIterator)-&gt;userName), recvbuf.message.logoutmember.userName) &#x3D;&#x3D; 0 )       &#123;        removeiterator &#x3D; UserIterator;        break;       &#125;      &#125;      if(removeiterator !&#x3D; NULL)       ClientList.remove(*removeiterator);      break;     &#125;    case P2PTRANS:     &#123;      &#x2F;&#x2F; 某个客户希望服务端向另外一个客户发送一个打洞消息      printf(&quot;%s wants to p2p %s\n&quot;,inet_ntoa(sender.sin_addr),recvbuf.message.translatemessage.userName);      stUserListNode node &#x3D; GetUser(recvbuf.message.translatemessage.userName);      sockaddr_in remote;      remote.sin_family&#x3D;AF_INET;      remote.sin_port&#x3D; htons(node.port);       remote.sin_addr.s_addr &#x3D; htonl(node.ip);      in_addr tmp;      tmp.S_un.S_addr &#x3D; htonl(node.ip);      printf(&quot;the address is %s,and port is %d\n&quot;,inet_ntoa(tmp), node.port);      stP2PMessage transMessage;      transMessage.iMessageType &#x3D; P2PSOMEONEWANTTOCALLYOU;      transMessage.iStringLen &#x3D; ntohl(sender.sin_addr.S_un.S_addr);      transMessage.Port &#x3D; ntohs(sender.sin_port);                              sendto(PrimaryUDP,(const char*)&amp;transMessage, sizeof(transMessage), 0, (const sockaddr *)&amp;remote, sizeof(remote));      break;     &#125;        case GETALLUSER:     &#123;      int command &#x3D; GETALLUSER;      sendto(PrimaryUDP, (const char*)&amp;command, sizeof(int), 0, (const sockaddr*)&amp;sender, sizeof(sender));      int nodecount &#x3D; (int)ClientList.size();      sendto(PrimaryUDP, (const char*)&amp;nodecount, sizeof(int), 0, (const sockaddr*)&amp;sender, sizeof(sender));      for(UserList::iterator UserIterator&#x3D;ClientList.begin();        UserIterator!&#x3D;ClientList.end();        ++UserIterator)      &#123;       sendto(PrimaryUDP, (const char*)(*UserIterator), sizeof(stUserListNode), 0, (const sockaddr*)&amp;sender, sizeof(sender));       &#125;      break;     &#125;    &#125;   &#125;  &#125; &#125; catch(Exception &amp;e) &#123;  printf(e.GetMessage());  return 1; &#125; return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="客户端源代码"><a href="#客户端源代码" class="headerlink" title="客户端源代码"></a>客户端源代码</h2> <pre class="line-numbers language-none"><code class="language-none">&#x2F;* P2P 程序客户端 *  * 文件名：P2PClient.c * * 日期：2004-5-21 * * 作者：shootingstars(zhouhuis22@sina.com) * *&#x2F;#pragma comment(lib,&quot;ws2_32.lib&quot;)#include &quot;windows.h&quot;#include &quot;..\proto.h&quot;#include &quot;..\Exception.h&quot;#include &lt;iostream&gt;using namespace std;UserList ClientList;#define COMMANDMAXC 256#define MAXRETRY    5SOCKET PrimaryUDP;char UserName[10];char ServerIP[20];bool RecvedACK;void InitWinSock()&#123; WSADATA wsaData; if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) !&#x3D; 0) &#123;  printf(&quot;Windows sockets 2.2 startup&quot;);  throw Exception(&quot;&quot;); &#125; else&#123;  printf(&quot;Using %s (Status: %s)\n&quot;,   wsaData.szDescription, wsaData.szSystemStatus);  printf(&quot;with API versions %d.%d to %d.%d\n\n&quot;,   LOBYTE(wsaData.wVersion), HIBYTE(wsaData.wVersion),   LOBYTE(wsaData.wHighVersion), HIBYTE(wsaData.wHighVersion)); &#125;&#125;SOCKET mksock(int type)&#123; SOCKET sock &#x3D; socket(AF_INET, type, 0); if (sock &lt; 0) &#123;        printf(&quot;create socket error&quot;);  throw Exception(&quot;&quot;); &#125; return sock;&#125;stUserListNode GetUser(char *username)&#123; for(UserList::iterator UserIterator&#x3D;ClientList.begin();      UserIterator!&#x3D;ClientList.end();       ++UserIterator) &#123;  if( strcmp( ((*UserIterator)-&gt;userName), username) &#x3D;&#x3D; 0 )   return *(*UserIterator); &#125; throw Exception(&quot;not find this user&quot;);&#125;void BindSock(SOCKET sock)&#123; sockaddr_in sin; sin.sin_addr.S_un.S_addr &#x3D; INADDR_ANY; sin.sin_family &#x3D; AF_INET; sin.sin_port &#x3D; 0;  if (bind(sock, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0)  throw Exception(&quot;bind error&quot;);&#125;void ConnectToServer(SOCKET sock,char *username, char *serverip)&#123; sockaddr_in remote; remote.sin_addr.S_un.S_addr &#x3D; inet_addr(serverip); remote.sin_family &#x3D; AF_INET; remote.sin_port &#x3D; htons(SERVER_PORT);  stMessage sendbuf; sendbuf.iMessageType &#x3D; LOGIN; strncpy(sendbuf.message.loginmember.userName, username, 10); sendto(sock, (const char*)&amp;sendbuf, sizeof(sendbuf), 0, (const sockaddr*)&amp;remote,sizeof(remote)); int usercount; int fromlen &#x3D; sizeof(remote); int iread &#x3D; recvfrom(sock, (char *)&amp;usercount, sizeof(int), 0, (sockaddr *)&amp;remote, &amp;fromlen); if(iread&lt;&#x3D;0) &#123;  throw Exception(&quot;Login error\n&quot;); &#125; &#x2F;&#x2F; 登录到服务端后，接收服务端发来的已经登录的用户的信息 cout&lt;&lt;&quot;Have &quot;&lt;&lt;usercount&lt;&lt;&quot; users logined server:&quot;&lt;&lt;endl; for(int i &#x3D; 0;i&lt;usercount;i++) &#123;  stUserListNode *node &#x3D; new stUserListNode;  recvfrom(sock, (char*)node, sizeof(stUserListNode), 0, (sockaddr *)&amp;remote, &amp;fromlen);  ClientList.push_back(node);  cout&lt;&lt;&quot;Username:&quot;&lt;&lt;node-&gt;userName&lt;&lt;endl;  in_addr tmp;  tmp.S_un.S_addr &#x3D; htonl(node-&gt;ip);  cout&lt;&lt;&quot;UserIP:&quot;&lt;&lt;inet_ntoa(tmp)&lt;&lt;endl;  cout&lt;&lt;&quot;UserPort:&quot;&lt;&lt;node-&gt;port&lt;&lt;endl;  cout&lt;&lt;&quot;&quot;&lt;&lt;endl; &#125;&#125;void OutputUsage()&#123; cout&lt;&lt;&quot;You can input you command:\n&quot;  &lt;&lt;&quot;Command Type:\&quot;send\&quot;,\&quot;exit\&quot;,\&quot;getu\&quot;\n&quot;  &lt;&lt;&quot;Example : send Username Message\n&quot;  &lt;&lt;&quot;          exit\n&quot;  &lt;&lt;&quot;          getu\n&quot;  &lt;&lt;endl;&#125;&#x2F;* 这是主要的函数：发送一个消息给某个用户(C) *流程：直接向某个用户的外网IP发送消息，如果此前没有联系过 *      那么此消息将无法发送，发送端等待超时。 *      超时后，发送端将发送一个请求信息到服务端， *      要求服务端发送给客户C一个请求，请求C给本机发送打洞消息 *      以上流程将重复MAXRETRY次 *&#x2F;bool SendMessageTo(char *UserName, char *Message)&#123; char realmessage[256]; unsigned int UserIP; unsigned short UserPort; bool FindUser &#x3D; false; for(UserList::iterator UserIterator&#x3D;ClientList.begin();      UserIterator!&#x3D;ClientList.end();      ++UserIterator) &#123;  if( strcmp( ((*UserIterator)-&gt;userName), UserName) &#x3D;&#x3D; 0 )  &#123;   UserIP &#x3D; (*UserIterator)-&gt;ip;   UserPort &#x3D; (*UserIterator)-&gt;port;   FindUser &#x3D; true;  &#125; &#125; if(!FindUser)  return false; strcpy(realmessage, Message); for(int i&#x3D;0;i&lt;MAXRETRY;i++) &#123;  RecvedACK &#x3D; false;  sockaddr_in remote;  remote.sin_addr.S_un.S_addr &#x3D; htonl(UserIP);  remote.sin_family &#x3D; AF_INET;  remote.sin_port &#x3D; htons(UserPort);  stP2PMessage MessageHead;  MessageHead.iMessageType &#x3D; P2PMESSAGE;  MessageHead.iStringLen &#x3D; (int)strlen(realmessage)+1;  int isend &#x3D; sendto(PrimaryUDP, (const char *)&amp;MessageHead, sizeof(MessageHead), 0, (const sockaddr*)&amp;remote, sizeof(remote));  isend &#x3D; sendto(PrimaryUDP, (const char *)&amp;realmessage, MessageHead.iStringLen, 0, (const sockaddr*)&amp;remote, sizeof(remote));    &#x2F;&#x2F; 等待接收线程将此标记修改  for(int j&#x3D;0;j&lt;10;j++)  &#123;   if(RecvedACK)    return true;   else    Sleep(300);  &#125;  &#x2F;&#x2F; 没有接收到目标主机的回应，认为目标主机的端口映射没有  &#x2F;&#x2F; 打开，那么发送请求信息给服务器，要服务器告诉目标主机  &#x2F;&#x2F; 打开映射端口（UDP打洞）  sockaddr_in server;  server.sin_addr.S_un.S_addr &#x3D; inet_addr(ServerIP);  server.sin_family &#x3D; AF_INET;  server.sin_port &#x3D; htons(SERVER_PORT);   stMessage transMessage;  transMessage.iMessageType &#x3D; P2PTRANS;  strcpy(transMessage.message.translatemessage.userName, UserName);  sendto(PrimaryUDP, (const char*)&amp;transMessage, sizeof(transMessage), 0, (const sockaddr*)&amp;server, sizeof(server));  Sleep(100);&#x2F;&#x2F; 等待对方先发送信息。 &#125; return false;&#125;&#x2F;&#x2F; 解析命令，暂时只有exit和send命令&#x2F;&#x2F; 新增getu命令，获取当前服务器的所有用户void ParseCommand(char * CommandLine)&#123; if(strlen(CommandLine)&lt;4)  return; char Command[10]; strncpy(Command, CommandLine, 4); Command[4]&#x3D;&#39;\0&#39;; if(strcmp(Command,&quot;exit&quot;)&#x3D;&#x3D;0) &#123;  stMessage sendbuf;  sendbuf.iMessageType &#x3D; LOGOUT;  strncpy(sendbuf.message.logoutmember.userName, UserName, 10);  sockaddr_in server;  server.sin_addr.S_un.S_addr &#x3D; inet_addr(ServerIP);  server.sin_family &#x3D; AF_INET;  server.sin_port &#x3D; htons(SERVER_PORT);  sendto(PrimaryUDP,(const char*)&amp;sendbuf, sizeof(sendbuf), 0, (const sockaddr *)&amp;server, sizeof(server));  shutdown(PrimaryUDP, 2);  closesocket(PrimaryUDP);  exit(0); &#125; else if(strcmp(Command,&quot;send&quot;)&#x3D;&#x3D;0) &#123;  char sendname[20];  char message[COMMANDMAXC];  int i;  for(i&#x3D;5;;i++)  &#123;   if(CommandLine[i]!&#x3D;&#39; &#39;)    sendname[i-5]&#x3D;CommandLine[i];   else   &#123;    sendname[i-5]&#x3D;&#39;\0&#39;;    break;   &#125;  &#125;  strcpy(message, &amp;(CommandLine[i+1]));  if(SendMessageTo(sendname, message))   printf(&quot;Send OK!\n&quot;);  else    printf(&quot;Send Failure!\n&quot;); &#125; else if(strcmp(Command,&quot;getu&quot;)&#x3D;&#x3D;0) &#123;  int command &#x3D; GETALLUSER;  sockaddr_in server;  server.sin_addr.S_un.S_addr &#x3D; inet_addr(ServerIP);  server.sin_family &#x3D; AF_INET;  server.sin_port &#x3D; htons(SERVER_PORT);  sendto(PrimaryUDP,(const char*)&amp;command, sizeof(command), 0, (const sockaddr *)&amp;server, sizeof(server)); &#125;&#125;&#x2F;&#x2F; 接受消息线程DWORD WINAPI RecvThreadProc(LPVOID lpParameter)&#123; sockaddr_in remote; int sinlen &#x3D; sizeof(remote); stP2PMessage recvbuf; for(;;) &#123;  int iread &#x3D; recvfrom(PrimaryUDP, (char *)&amp;recvbuf, sizeof(recvbuf), 0, (sockaddr *)&amp;remote, &amp;sinlen);  if(iread&lt;&#x3D;0)  &#123;   printf(&quot;recv error\n&quot;);   continue;  &#125;  switch(recvbuf.iMessageType)  &#123;  case P2PMESSAGE:   &#123;    &#x2F;&#x2F; 接收到P2P的消息    char *comemessage&#x3D; new char[recvbuf.iStringLen];    int iread1 &#x3D; recvfrom(PrimaryUDP, comemessage, 256, 0, (sockaddr *)&amp;remote, &amp;sinlen);    comemessage[iread1-1] &#x3D; &#39;\0&#39;;    if(iread1&lt;&#x3D;0)     throw Exception(&quot;Recv Message Error\n&quot;);    else    &#123;     printf(&quot;Recv a Message:%s\n&quot;,comemessage);          stP2PMessage sendbuf;     sendbuf.iMessageType &#x3D; P2PMESSAGEACK;     sendto(PrimaryUDP, (const char*)&amp;sendbuf, sizeof(sendbuf), 0, (const sockaddr*)&amp;remote, sizeof(remote));    &#125;    delete []comemessage;    break;   &#125;  case P2PSOMEONEWANTTOCALLYOU:   &#123;    &#x2F;&#x2F; 接收到打洞命令，向指定的IP地址打洞    printf(&quot;Recv p2someonewanttocallyou data\n&quot;);    sockaddr_in remote;    remote.sin_addr.S_un.S_addr &#x3D; htonl(recvbuf.iStringLen);    remote.sin_family &#x3D; AF_INET;    remote.sin_port &#x3D; htons(recvbuf.Port);    &#x2F;&#x2F; UDP hole punching    stP2PMessage message;    message.iMessageType &#x3D; P2PTRASH;    sendto(PrimaryUDP, (const char *)&amp;message, sizeof(message), 0, (const sockaddr*)&amp;remote, sizeof(remote));                    break;   &#125;  case P2PMESSAGEACK:   &#123;    &#x2F;&#x2F; 发送消息的应答    RecvedACK &#x3D; true;    break;   &#125;  case P2PTRASH:   &#123;    &#x2F;&#x2F; 对方发送的打洞消息，忽略掉。    &#x2F;&#x2F;do nothing      printf(&quot;Recv p2ptrash data\n&quot;);    break;   &#125;  case GETALLUSER:   &#123;    int usercount;    int fromlen &#x3D; sizeof(remote);    int iread &#x3D; recvfrom(PrimaryUDP, (char *)&amp;usercount, sizeof(int), 0, (sockaddr *)&amp;remote, &amp;fromlen);    if(iread&lt;&#x3D;0)    &#123;     throw Exception(&quot;Login error\n&quot;);    &#125;        ClientList.clear();    cout&lt;&lt;&quot;Have &quot;&lt;&lt;usercount&lt;&lt;&quot; users logined server:&quot;&lt;&lt;endl;    for(int i &#x3D; 0;i&lt;usercount;i++)    &#123;     stUserListNode *node &#x3D; new stUserListNode;     recvfrom(PrimaryUDP, (char*)node, sizeof(stUserListNode), 0, (sockaddr *)&amp;remote, &amp;fromlen);     ClientList.push_back(node);     cout&lt;&lt;&quot;Username:&quot;&lt;&lt;node-&gt;userName&lt;&lt;endl;     in_addr tmp;     tmp.S_un.S_addr &#x3D; htonl(node-&gt;ip);     cout&lt;&lt;&quot;UserIP:&quot;&lt;&lt;inet_ntoa(tmp)&lt;&lt;endl;     cout&lt;&lt;&quot;UserPort:&quot;&lt;&lt;node-&gt;port&lt;&lt;endl;     cout&lt;&lt;&quot;&quot;&lt;&lt;endl;    &#125;    break;   &#125;  &#125; &#125;&#125;int main(int argc, char* argv[])&#123; try &#123;  InitWinSock();    PrimaryUDP &#x3D; mksock(SOCK_DGRAM);  BindSock(PrimaryUDP);  cout&lt;&lt;&quot;Please input server ip:&quot;;  cin&gt;&gt;ServerIP;  cout&lt;&lt;&quot;Please input your name:&quot;;  cin&gt;&gt;UserName;  ConnectToServer(PrimaryUDP, UserName, ServerIP);  HANDLE threadhandle &#x3D; CreateThread(NULL, 0, RecvThreadProc, NULL, NULL, NULL);  CloseHandle(threadhandle);  OutputUsage();  for(;;)  &#123;   char Command[COMMANDMAXC];   gets(Command);   ParseCommand(Command);  &#125; &#125; catch(Exception &amp;e) &#123;  printf(e.GetMessage());  return 1; &#125; return 0;&#125;&#x2F;* 异常类 * * 文件名：Exception.h * * 日期：2004.5.5 * * 作者：shootingstars(zhouhuis22@sina.com) *&#x2F;#ifndef __HZH_Exception__#define __HZH_Exception__#define EXCEPTION_MESSAGE_MAXLEN 256#include &quot;string.h&quot;class Exception&#123;private: char m_ExceptionMessage[EXCEPTION_MESSAGE_MAXLEN];public: Exception(char *msg) &#123;  strncpy(m_ExceptionMessage, msg, EXCEPTION_MESSAGE_MAXLEN); &#125; char *GetMessage() &#123;  return m_ExceptionMessage; &#125;&#125;;#endif&#x2F;* P2P 程序传输协议 *  * 日期：2004-5-21 * * 作者：shootingstars(zhouhuis22@sina.com) * *&#x2F;#pragma once#include &lt;list&gt;&#x2F;&#x2F; 定义iMessageType的值#define LOGIN 1#define LOGOUT 2#define P2PTRANS 3#define GETALLUSER  4&#x2F;&#x2F; 服务器端口#define SERVER_PORT 2280&#x2F;&#x2F; Client登录时向服务器发送的消息struct stLoginMessage&#123; char userName[10]; char password[10];&#125;;&#x2F;&#x2F; Client注销时发送的消息struct stLogoutMessage&#123; char userName[10];&#125;;&#x2F;&#x2F; Client向服务器请求另外一个Client(userName)向自己方向发送UDP打洞消息struct stP2PTranslate&#123; char userName[10];&#125;;&#x2F;&#x2F; Client向服务器发送的消息格式struct stMessage&#123; int iMessageType; union _message &#123;  stLoginMessage loginmember;  stLogoutMessage logoutmember;  stP2PTranslate translatemessage; &#125;message;&#125;;&#x2F;&#x2F; 客户节点信息struct stUserListNode&#123; char userName[10]; unsigned int ip; unsigned short port;&#125;;&#x2F;&#x2F; Server向Client发送的消息struct stServerToClient&#123; int iMessageType; union _message &#123;  stUserListNode user; &#125;message;&#125;;&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;&#x2F; 下面的协议用于客户端之间的通信&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;#define P2PMESSAGE 100               &#x2F;&#x2F; 发送消息#define P2PMESSAGEACK 101            &#x2F;&#x2F; 收到消息的应答#define P2PSOMEONEWANTTOCALLYOU 102  &#x2F;&#x2F; 服务器向客户端发送的消息                                     &#x2F;&#x2F; 希望此客户端发送一个UDP打洞包#define P2PTRASH        103          &#x2F;&#x2F; 客户端发送的打洞包，接收端应该忽略此消息&#x2F;&#x2F; 客户端之间发送消息格式struct stP2PMessage&#123; int iMessageType; int iStringLen;         &#x2F;&#x2F; or IP address unsigned short Port; &#125;;using namespace std;typedef list&lt;stUserListNode *&gt; UserList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 网络穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何防止破解？MCU加密技术进化史</title>
      <link href="/20230530/more_reverse/MCU%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E8%BF%9B%E5%8C%96%E5%8F%B2.html"/>
      <url>/20230530/more_reverse/MCU%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E8%BF%9B%E5%8C%96%E5%8F%B2.html</url>
      
        <content type="html"><![CDATA[<p>自从上世纪70年代MCU诞生以来，芯片的破解技术与防止芯片被破解方案就在不断地上演着“道高一尺，魔高一丈”，一山更比一山高的追逐。<br>本文将单片机在安全保护方面的发展历程与大家分享，并在文章的最后，总结了现阶段安全级别最高的智能卡芯片的优点及其缺点。</p><h1 id="单板机时代"><a href="#单板机时代" class="headerlink" title="单板机时代"></a>单板机时代</h1><blockquote><p>上世纪70年代初期，嵌入式系统是由分离部件如：CPU、ROM、RAM、I/O缓存、串口和其他通信与控制接口组成的控制板。<br>这一时期除法律外，几乎没有保护措施来防止侵入者复制单板机上ROM区的数据。</p></blockquote><h1 id="单片机时代"><a href="#单片机时代" class="headerlink" title="单片机时代"></a>单片机时代</h1><blockquote><p>随着大规模集成电路技术的发展，中央处理单元(CPU)、数据存储器(RAM)、程序存储器(ROM)及其他I/O通信口都集成在一块单片机芯片上了，微控制器MCU取代了单板机。如图：<br><img src="/images/learn/hacker/KNhbuuq44zs31loUNWrEXg_001.png" alt="图片"><br>这一时期，内部存储器EEPROM和MCU是分开封在同一封装内部。侵入者可用微探针来获取数据。</p></blockquote><h1 id="安全熔断丝"><a href="#安全熔断丝" class="headerlink" title="安全熔断丝"></a>安全熔断丝</h1><blockquote><p>随着入侵者的增加，MCU为了自身的安全，后来增加了安全熔断丝(Security Fuse)来禁止访问数据。如图：<br><img src="/images/learn/hacker/KNhbuuq44zs31loUNWrEXg_002.jpg" alt="图片"><br>优点：很容易做到，不需要完全重新设计MCU构架，仅用熔断丝来控制数据的访问。<br>缺点：熔断丝容易被定位、攻击。<br>例如：熔丝的状态可以通过直接把位输出连到电源或地线上来进行修改。有些仅用激光或聚焦离子束来切断熔丝的感应电路就可以了。用非侵入式攻击也一样成功，因为一个分离的熔丝版图异于正常存储阵列，可以用组合外部信号来使位处与不能被正确读出的状态，那样就可以访问存在内部芯片上信息了。用半侵入式攻击可以使破解者快速取得成功，但需要打开芯片的封装来接近晶粒。一个众所周知方法，就是用紫外线擦掉安全熔断丝。</p></blockquote><h1 id="安全熔丝变成存储器阵列的一部分"><a href="#安全熔丝变成存储器阵列的一部分" class="headerlink" title="安全熔丝变成存储器阵列的一部分"></a>安全熔丝变成存储器阵列的一部分</h1><blockquote><p>再后来MCU制造商将安全熔丝做成存储器阵列的一部分，如图：<br><img src="/images/learn/hacker/KNhbuuq44zs31loUNWrEXg_003.jpg" alt="图片"><br>一般的熔丝与主存储器离得很近，或干脆共享些控制线，与主存储器用相同的工艺来制造，熔断丝很难被定位。非入侵试攻击仍然可以用，可以用组合外部信号来使熔断位处于不被正确读出的状态。同样，半侵入式攻击也可用。<br>当然，破解者需要更多的时间去寻找安全熔丝或控制电路负责安全监视的部分，但这些可以自动完成。进行侵入式攻击将是很困难需要手工操作，那将花费更多的成本来破解。</p></blockquote><h1 id="用主存储器的一部分来控制外部对数据访问"><a href="#用主存储器的一部分来控制外部对数据访问" class="headerlink" title="用主存储器的一部分来控制外部对数据访问"></a>用主存储器的一部分来控制外部对数据访问</h1><blockquote><p>利用上电时锁定特定区域地址的信息，将它作为安全熔丝。或用密码来控制对存储器访问。例如：德州仪器的MSP430F112只有输入正确的32字节密码后才能进行回读操作。<br>如果没输入，只有擦字节密码后才能进行回读操作。尽管这个保护方法看上去比先前的更有效，但它有一些缺点可以用低成本的非侵入式攻击，如时序分析和功耗来破解。<br>如果安全熔丝状态是上电或复位后存储器的一部分，这就给破解者用电源噪声来破解的机会，强制路进入存储中错误状态。</p></blockquote><h1 id="使用顶层金属网络"><a href="#使用顶层金属网络" class="headerlink" title="使用顶层金属网络"></a>使用顶层金属网络</h1><blockquote><p>使用顶层金属网络设计，提升入侵难度。所有的网格都用来监控短路和开路，一旦触发，会导致存储器复位或清零。如图：<br><img src="/images/learn/hacker/KNhbuuq44zs31loUNWrEXg_004.jpg" alt="图片"><br>普通的MCU不会使用这种保护方法，因为设计较难，且在异常运行条件下也会触发，如：高强度电磁场噪声，低温或高温，异常的时钟信号或供电不良。故有些普通的MCU使用更廉价的伪顶层金属网格，会被非常高效的光学分析进行微探测而被攻击。<br>另外，这些网格不能防范非侵入式攻击。同样不能有效防范半侵入式攻击，因为导线之间有电容，并且光线可以通过导线抵达电路的有效区域。在智能卡中，电源和地之间也铺了一些这样的网格线。部分可编程的智能卡走得更远，干脆砍掉了标准的编程接口，甚至干掉了读取EEPROM接口，取而代之的是启动模块，可以在代码装入后擦掉或者屏蔽自己，之后只能响应使用者的嵌入软件所支持的功能。有效地防范了非侵入式攻击。</p></blockquote><h1 id="智能卡芯片安全设计"><a href="#智能卡芯片安全设计" class="headerlink" title="智能卡芯片安全设计"></a>智能卡芯片安全设计</h1><blockquote><p>近些年，一些智能卡使用存储器总线加密(Bus Encryption)技术来防止探测攻击。如图：<br><img src="/images/learn/hacker/KNhbuuq44zs31loUNWrEXg_005.jpg" alt="图片"><br>数据以密文方式存储在存储器中。即使入侵者获得数据总线的数据，也不可能知道密钥或者别的敏感信息(如数据还原方法)。这种保护措施有效地防范了侵入式和半侵入式攻击。<br>有些智能卡甚至能够做到每张卡片总线加密密钥不同，这样即使入侵者完全破解了，也无法生产出相同功能的芯片来，因为每个智能卡芯片有唯一的ID号，无法买到相同ID号的智能卡。<br>另外值得一提的是，有些智能卡将标准的模块结构如解码器，寄存器文件，ALU和I/O电路用类似ASIC逻辑来设计。这些设计成为混合逻辑(Gle Logic)设计。<br>混合逻辑使得实际上不可能通过手工寻找信号或节点来获得卡的信息进行物理攻击。大大提高了CPU内核的性能和安全性。混合逻辑设计几乎不可能知道总线的物理位置，有效地防范了反向工程和微探测攻击。</p></blockquote><h1 id="智能卡芯片加密方案优缺点"><a href="#智能卡芯片加密方案优缺点" class="headerlink" title="智能卡芯片加密方案优缺点"></a>智能卡芯片加密方案优缺点</h1><blockquote><p>对于开发者来讲，选择更为安全设计的微控制器或可以得到更好的保护。与大多数微控制器相比，即使是十年前设计的智能卡也能提供更好的保护。现代的智能卡提供了更多的防攻击保护，内部电压传感器保护免受电源噪声攻击(Power Glitch attacks)、过压和欠压保护。<br>时钟频率传感器防止受到静态分析(Static analysis)的降低时钟频率攻击；同时也可以防止时钟噪声(Clock glitch attacks)进行提高时钟频率的攻击。顶层金属网格和内部总线硬件加密可以防止微探测攻击。<br>但是，与微控制器相比，智能卡芯片也有劣势，如：芯片价格昂贵，小批量的很难买到货。开发工具昂贵，需要和制造商签署保密协议，即使是说明书也要这样。很多制造商仅向特定客户销售大批量的智能卡。<br>另一个不足是I/O的功能受限，普通智能卡芯片通常只有ISO7816接口，极少有单独的I/O口。<br>这使得多数应用中不能取代微控制器，而只能用于安全要求非常高的行业，如：付费机顶盒，银行卡，SIM卡，二代身份证，高端加密芯片等领域。智能卡芯片在加密芯片领域的应用，将是个不错的方向。因为智能卡芯片安全等级高，IO资源少。<br>而普通MCU的硬件资源非常丰富，安全程度却不高，可以将MCU中一些关键算法及运行参数，以特殊形式存放在智能卡芯片中，从而实现高安全强度的强大功能。</p></blockquote><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote><p>坚持不懈的尝试突破保护机制的破解团体和不断引入新的安全防范方案的制造商之间的斗争是没有尽头的。“道高一尺，魔高一丈”，又或是“邪不压正”，将不停地在两派之间上演！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 芯片破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 杂谈闲语 </tag>
            
            <tag> 芯片破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的MCU是怎么被破解的！</title>
      <link href="/20230530/more_reverse/%E4%BD%A0%E7%9A%84MCU%E6%98%AF%E6%80%8E%E4%B9%88%E8%A2%AB%E7%A0%B4%E8%A7%A3%E7%9A%84.html"/>
      <url>/20230530/more_reverse/%E4%BD%A0%E7%9A%84MCU%E6%98%AF%E6%80%8E%E4%B9%88%E8%A2%AB%E7%A0%B4%E8%A7%A3%E7%9A%84.html</url>
      
        <content type="html"><![CDATA[<p>在我们周围，MCU 的安全等级正在逐步提升，一些公司甚至推出了安全主控，这是很好的现象，说明各行业都越来越重视嵌入式领域的信息安全和程序安全了。但目前仍有很多行业，比如消费类电子产品，低成本的通讯模块、电源控制模块等等，迫于成本压力以及更新换代速度问题，都无法更新使用更安全的主控 MCU。<br>还有另一个重要的原因就是企业的研发组织以及工程师对安全的重视程度不够，从而不愿意花更多的时间和成本进行安全的研发。<br>大家可能都知道破解 51 单片机是很容易的，但为什么容易，又是如何来破解的，可能很多人就不大清楚了。其实对于MCU的破解从简单来讲，它并不像我们开发项目那样复杂，有时候一个漏洞被发现，可能一个小技巧就可以获取或者篡改用户程序，行业里解密的方法有很多，每个人破解的思路也不一样。但大致也就是以下几种。</p><hr><h1 id="软件破解"><a href="#软件破解" class="headerlink" title="软件破解"></a>软件破解</h1><p>利用软件破解目标单片机的方法，并且利用这种方法，不会对目标 MCU 元器件造成物理损伤。<br>这种破解方法最早的时候主要是对 WINBONGD，SYNCMOS 单片机和 GAL 门阵列，这种利用软件解密设备，按照一定的步骤操作，执行片内的程序送到片外的指令，然后用解密的设备进行截获，这样芯片内部的程序就被解密完成了（GAL 采用逻辑猜测），就可以得到加密单片机中的程序。<br><img src="/images/learn/hacker/MQEfrVQTFylwCh2CKEPgHg_001.jpg" alt="图片"><br>另外对于我们现在市场上比较普遍的ARM系列芯片也同样适用，比如我们在发布产品的时候没有把相关的调试接口关闭掉，如SWD接口，那么破译者完全可以利用这个调试接口，将自己编写的一段代码烧录到MCU的ram中，并将执行这一端代码，而这一段代码就可以把我们存放在flash中的固件程序一个字节一个字节的从芯片中读取出来。<br>除了这种调试作用的SWD接口外，对于具备OTA功能的产品也要注意保护自己的OTA通道，一旦OTA过程被识破，黑客完全有机会利用这个接口去运行自己的程序，从而将Flash中的信息获取到。</p><h2 id="芯片的唯一ID"><a href="#芯片的唯一ID" class="headerlink" title="芯片的唯一ID"></a>芯片的唯一ID</h2><p>以上所讲的都是利用芯片本身或者软件漏洞来获取用户固件的案例，那么会有人说，我利用芯片的唯一ID在程序运行过程中对ID做校验，这样即便把固件拷贝出来也没办法批量生产。<br>好的，芯片设计中增加了唯一ID确实给芯片的破解增加了一些难度，但黑客往往都是不走寻常路的。<br>首先这种唯一ID在硬件上就存在漏洞，是有机会被篡改的，ID或者读取ID的地址。那么我们从软件上来破解也是可以的。<br>破解方法：</p><ol><li>首先按照上面提到获取固件的破解方法，获取到 MCU 的 HEX 文件。</li><li>使用软件进行 HEX 反编译，反编译软件目前有很多。</li><li>在反编译的程序中，找到对比点，比如图 3 所示，CJNE 语句可能就是这个对比点。因此只要把箭头 2 那行语句删除，然后重新把汇编语言下载到 MCU 中，破解工作就完成了。此时即使没有加密芯片，MCU 也能正常运行了。<br><img src="/images/learn/hacker/MQEfrVQTFylwCh2CKEPgHg_002.png" alt="图片"></li></ol><h2 id="加密芯片是否安全"><a href="#加密芯片是否安全" class="headerlink" title="加密芯片是否安全?"></a>加密芯片是否安全?</h2><p>关于加密芯片，我想说的是，加密芯片本身还是非常安全的，它内部都设计了相关的防硬件破解的措施，一但对芯片进行硬件探测和破解就会触发其内部保护电路，将自身数据全部擦除。<br>但是我们的产品是一个系统，他不是单独的一个加密芯片，一旦我们的功能的主要部分暴露在非安全区，就给黑客带来了可乘之机，比如一般的智能硬件产品的功能实现都是在系统的主MCU中，在主MCU之外往往通过SPI或者IIC接口来连接加密芯片对系统进行保护。<br>加密原理：<br>MCU 和加密芯片各存储一条认证秘钥，存储同样的加密算法；<br>MCU 产生随机数发给加密芯片，后者用秘钥加密后将密文返回，此时 MCU 解密后，比对明文是否和生成的随机数相等。如果相等，程序正常运行; 如果不相等，出错处理。<br>因为盗版商没有这条秘钥，加密芯片与 MCU 交互的数据又是随机变化的，无法找到规律，所以只能把加密芯片的程序破解了，再复制一片加密芯片才能让 MCU 的程序跑起来。而加密芯片不同于通用 MCU，它内部有很多安全机制，破解难度非常大。</p><p>这种加密方案看似非常安全，但其实主MCU存在安全漏洞，依然会被拷贝出固件，执行类似破解唯一ID加密的方法即可，因此这种加密芯片只能保护个别数据，无法对整个系统进行全面的保护。</p><hr><h1 id="硬件破解"><a href="#硬件破解" class="headerlink" title="硬件破解"></a>硬件破解</h1><p>前面所讲的都有一个前提，那就是用户忘记关闭调试接口，或者用的OTA程序被破解利用，使得黑客获取到了芯片内部的固件程序。<br>接下来我们聊一下另一个情况，工程师认真，没有留下调试接口，同时OTA逻辑也设计的非常可靠，具备了各种保护逻辑和防重放措施，保证不被黑客检测到重复的命令信息。<br>难道这样就没办法破解了吗？很遗憾，这才是真正研究芯片破解技术的专业人员的起步环境。<br>全球有很多做芯片破解的公司和研究机构，他们有的甚至在一些院校实验室和研究所里面，他们往往会为芯片设计公司服务，来帮助设计公司提高自己的芯片安全指标，当然也可以提供芯片破译服务给有利可图者提供服务。<br>芯片的安全就是攻防对决，不断提高技术水平的过程，接下来我们看一下硬件上是怎么破解一颗芯片的。</p><p>流程如下：<br>1、测试<br>使用高档编程器等设备测试芯片是否正常，并把配置字保存。<br>2、开盖<br>采用手工或专用开盖设备进行开盖处理，这里说的开盖并不是说单片机或者其他 MCU 真有一个盖。<br>MCU 其实是一个大规模集成电路，它是由 N 个电路组合而成的，而晶圆就是搭载集成电路的载体。将晶圆进行封装后，就形成了我们日常所用的 IC 芯片，封装形式可以有多种，比如 TSSOP28、QFN28 等，大家可以自己去百度搜索，这里不再复述。<br><img src="/images/learn/hacker/MQEfrVQTFylwCh2CKEPgHg_003.png" alt="图片"><br>3、做电路修改<br>对不同芯片，提供对应的图纸，让厂家做电路修改，目的是让 MCU 的存储区变得可读。有些 MCU 默认不允许读出 Flash 或者 E2PROM 中的数据，因为有硬件电路做保护，而一旦切断加密连线，程序就暴露可读了。如图 2 所示<br><img src="/images/learn/hacker/MQEfrVQTFylwCh2CKEPgHg_004.png" alt="图片"><br>（切割掉加密熔丝，这样就可以直接读出芯片内部程序）<br>4、读程序<br>取回修改过的 MCU，直接用编程器读出程序，可以是 HEX 文件，或者 BIN 文件。<br>5、烧写样片给客户<br>按照读出的程序和配置，烧写到目标 MCU 中，这样就完成了 MCU 的破解。至此，硬件破解法成功完成。</p><hr><h1 id="其他硬件破解"><a href="#其他硬件破解" class="headerlink" title="其他硬件破解"></a>其他硬件破解</h1><p>开盖修改电路破除芯片设置的读保护来对芯片进行破译，这其实还是最一般的手段，对于很多具备熔丝位以及更高保护措施的芯片，依然有各种破译办法，接下来简单列举一下：</p><h2 id="电子探测攻击"><a href="#电子探测攻击" class="headerlink" title="电子探测攻击"></a>电子探测攻击</h2><p>该技术通常以高时间分辨率来监控处理器在正常操作时所有电源和接口连接的模拟特性，并通过监控它的电磁辐射特性来实施攻击。因为单片机是一个活动的电子器件，当它执行不同的指令时，对应的电源功率消耗也相应变化。这样通过使用特殊的电子测量仪器和数学统计方法分析和检测这些变化，即可获取单片机中的特定关键信息。</p><h2 id="过错产生技术"><a href="#过错产生技术" class="headerlink" title="过错产生技术"></a>过错产生技术</h2><p>该技术使用异常工作条件来使处理器出错，然后提供额外的访问来进行攻击。使用最广泛的过错产生攻击手段包括电压冲击和时钟冲击。处理器执行错误操作。电源和时钟瞬态跳变可以在某些处理器中影响单条指令的解码和执行。</p><h2 id="探针技术"><a href="#探针技术" class="headerlink" title="探针技术"></a>探针技术</h2><p>该技术是直接暴露芯片内部连线，然后观察，阻止，干扰单片机以达到攻击目的。</p><h2 id="紫外线攻击方法"><a href="#紫外线攻击方法" class="headerlink" title="紫外线攻击方法"></a>紫外线攻击方法</h2><p>紫外线攻击也称为紫外线攻击方法，就是利用紫外线照射芯片，让加密的芯片变成了不加密的芯片，然后用编程器直接转换程序。这种方法适合OTP的芯片，做单片机的工程师都知道OTP OTP芯片的封装有陶瓷封装的一半都有石英玻璃，这种是可以直接用紫外线照射的，如果是用塑料封装的，就需要先将芯片开盖，将晶圆暴露以后才可以通过这种芯片的加密性比较差，解密基本不需要任何成本，所以市场上这种芯片解密的价格非常便宜，SONIX的SN8P2511解密，飞凌单片机解密等价格就非常便宜。</p><h2 id="FIB恢复加密熔丝方法"><a href="#FIB恢复加密熔丝方法" class="headerlink" title="FIB恢复加密熔丝方法"></a>FIB恢复加密熔丝方法</h2><p>这种方法适用于很多的具有熔丝加密的芯片，最有特色的芯片就是TI的MSP430解密的方法，因为MSP430加密的时候要烧熔丝，那么只要能将熔丝恢复上，那就变一般解密公司利用探针来实现，将熔丝位连上，也有的人因为自己没有太多的解密设备，需要交由其他半导体线路修改的公司来修改线路，一般可以使用FIB（聚焦离子束）设备这些设备目前在国内的二手设备很多，也价格很便宜，一些有实力的解密公司都配置了自己的设备。这种方法依据需要设备和耗材，不是好的方法，但是很多芯片如果没有更好的方法的时候，就需要这种方法来实现。</p><h2 id="修改加密线路的方法"><a href="#修改加密线路的方法" class="headerlink" title="修改加密线路的方法"></a>修改加密线路的方法</h2><p>目前市场上的CPLD和DSP芯片设计复杂，加密性能要高，采用上述方法是很难做到解密的，那么就需要对芯片结构作前面的分析，然后找到加密电路，然后利用芯片线路修改的设备将芯片的线路做一些修改，让加密电路失效，让加密的DSP或CPLD变成了不加密的芯片从而可以读出代码。如TMS320LF2407A解密，TMS320F28335解密，TMS320F2812解密就是采用这种方法。</p>]]></content>
      
      
      <categories>
          
          <category> 芯片破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 杂谈闲语 </tag>
            
            <tag> 芯片破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机解密技术简介</title>
      <link href="/20230530/more_reverse/%E5%8D%95%E7%89%87%E6%9C%BA%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B.html"/>
      <url>/20230530/more_reverse/%E5%8D%95%E7%89%87%E6%9C%BA%E8%A7%A3%E5%AF%86%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是单片机解密"><a href="#什么是单片机解密" class="headerlink" title="什么是单片机解密?"></a>什么是单片机解密?</h1><p>单片机解密又叫单片机破解，芯片解密，IC解密，但是这严格说来这几种称呼都不科学，但E经成了习惯叫法，我们把CPLD解密，DSP解密都习惯称为单片机解密。单片机只是能装载程序芯片的其中一个类。能烧录程序并能加密的芯片还有DSP, CPLD, PLD, ATR, ARN等。当然具存储功能的存储器芯片也能加密，比如DS2401 Ds2501 AT88S0104 DM2602 AT88SC0104D等 ，当中也有专门设计有加密算法用于专业加密的芯片或设计验证厂家代码工作等功能芯片,该类芯片业能实现防止电子产品复制的目的。单片机攻击者借助专用设备或者自制设备,利用单片机芯片设计上的漏洞或软件缺陷，通过多种技术手段,就可以从芯片中提取关键信息，获取单片机内程序这就叫单片机解密。</p><h1 id="单片机解密有哪些方式"><a href="#单片机解密有哪些方式" class="headerlink" title="单片机解密有哪些方式?"></a>单片机解密有哪些方式?</h1><h2 id="软件攻击"><a href="#软件攻击" class="headerlink" title="软件攻击"></a>软件攻击</h2><p>该技术通常使用处理器通信接口并利用协议、加密算法或这些算法中的安全漏洞来进行攻击。软件攻击取得成功的一一个典型事例是对早期ATMel AT89C 系列单片机的攻击。攻击者利用了该系列单片机擦除操作时序设计上的漏洞，使用自编程序在搊除加密锁定位后，停止下一步擦除片內程序存储器数据的操作，从而使加过密的单片机变成没加密的单片机,然后利用编程器读出片内程序。<br>在其他加密方法的基础上，可以研究出-些设备,配合一定的软件,来做软件攻击。<br>近期国内出现了了-种51单片机解密设备(成都-位高手搞出来的) , 这种解密器主要针对SyncMos. winbond, 在生产工艺上的漏洞，利用某些编程器定位插字节,通过-定的方法查找芯片中是否有连续空位,也就是说查找芯片中连续的FF F字节，插入的字节能够执行把片内的程序送到片外的指令，然后用解密的设备进行截获，这样芯片内部的程序就被解密完成了。</p><h2 id="电子探测攻击"><a href="#电子探测攻击" class="headerlink" title="电子探测攻击"></a>电子探测攻击</h2><p>该技术通用以高时间分辨率来监控处理器在正常操作时所有电源和接口连接的模拟特性，并通过监控它的电磁辐射特性来实施攻击。因为单片机是一个活动的电子器件,当它执行不同的指令时,对应的电源功率消耗也相应变化。这样通过使用特殊的电子测量仪器和数学统计方法分析和检测这些变化，即可获取单片机中的特定关键信息。<br>RF编程器可以直接读出老的型号的加密MCU中的程序,就是采用这个原理。</p><h2 id="过错产生技术"><a href="#过错产生技术" class="headerlink" title="过错产生技术"></a>过错产生技术</h2><p>该技术使用异常工作条件来使处理器出错，然后提供额外的访问来攻击。使用最广泛的过错产生攻击手段包括电压冲击和时钟冲击。低电压和高电压攻击可用来禁止保护电路工作或强制处理器执行错误操作。时钟瞬态跳变也许会复位保护电路而不会破坏受保护信息。电源和时钟瞬态跳变可以在某些处理器中影响单条指令的解码和执行。</p><h2 id="探针技术"><a href="#探针技术" class="headerlink" title="探针技术"></a>探针技术</h2><p>该技术是直接暴露芯片内部连线，然后观察、操控、干扰单片机以达到攻击目的。<br>为了方便起见，人们将以上四种攻击技术分成两类，一类是侵入型攻击 (物理攻击) ,这类攻击需要破坏封装,然后借助半导体测试设备、显微镜和微定位器， 在专门的实验室花上几小时甚至几周时间才能完成。所有的微探针技术都属于侵入型攻击。另外三种方法属于非侵入型攻击,被攻击的单片机不会被物理损坏。在某些场合非侵入型攻击是特别危险的，这是因为非侵入型攻击所需设备通常可以自制和升级，因此非常廉价。<br>大部分非侵入型攻击需要攻击者具备良好的处理器知识和软件知识。与之相反，侵入型的探针攻击则不需要太多的初始知识，而且通常可用一整套相似的技术对付宽范围的产品。因此，对单片机的攻击往往从侵入型的反向工程开始,积累的经验有助于开发更加廉价和快速的非侵入型攻击技术。</p><h1 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h1><h2 id="揭去芯片封装"><a href="#揭去芯片封装" class="headerlink" title="揭去芯片封装"></a>揭去芯片封装</h2><p>侵入型攻击的第一 步是揭去芯片封装(简称“开盖”有时候称“开封”,英文为“DECAP”，decapsulation)。<br>有两种方法可以达到这一-目的:<br>第一种是完全溶解掉芯片封装,暴露金属连线。<br>第二种是只移掉硅核_上面的塑料封装。<br>第一种方法需要将芯片绑定到测试夹具上,借助绑定台来操作;第二种方法除了需要具备攻击者一定的知识和必要的技能外,还需要个人的智慧和耐心，但操作起来相对比较方便,完全家庭中操作。<br>芯片上面的塑料可以用小刀揭开，芯片周围的环氧树脂可以用浓硝酸腐蚀掉。热的浓硝酸会溶解掉芯片封装而不会影响芯片及连线。该过程一般在非常干燥的条件下进行,因为水的存在可能会侵蚀已暴露的铝线连接(这就可能造成解密失败) 。</p><h2 id="清洗芯片"><a href="#清洗芯片" class="headerlink" title="清洗芯片"></a>清洗芯片</h2><p>接着在超声池里先用丙酮清洗该芯片以除去残余硝酸,并浸泡。</p><h2 id="寻找保护熔的位置并破坏"><a href="#寻找保护熔的位置并破坏" class="headerlink" title="寻找保护熔的位置并破坏"></a>寻找保护熔的位置并破坏</h2><p>最后一步是寻找保护熔丝的位置并将保护熔丝暴露在紫外光下。一般用一 台放大倍数至少100倍的显微镜，从编程电压输入脚的连线跟踪进去,来寻找保护熔丝。若没有显微镜，则采用将芯片的不同部分暴露到紫外光下并观察结果的方式进行简单的索。操作时应用不透明的纸片覆盖芯片以保护程序存储器不被紫外光擲除。将保护熔丝暴露在紫外光下5~10分钟就能破坏掉保护位的保护作用，之后，使用简单的编程器就可直接读出程序存储器的内容。<br>对于使用了防护层来保护EPROM单元的单片机来说，使用紫外光复位保护电路是不可行的。对于这种类型的单片机，- 般使用微探针技术来读取存储器内容。在芯片封装打开后，将芯片置于显微镜下就能够很容易的找到从存储器连到电路其它部分的数据总线。由于某种原因，芯片锁定位在编程模式下并不锁定对存储器的访问。利用这一缺陷将探针放在数据线的上面就能读到所有想要的数据。在编程模式下，重启读过程并连接探针到另外的数据线上就可以读出程序和数据存储器中的所有信息。</p><h2 id="借助显微镜和激光切割机破坏保护熔丝"><a href="#借助显微镜和激光切割机破坏保护熔丝" class="headerlink" title="借助显微镜和激光切割机破坏保护熔丝"></a>借助显微镜和激光切割机破坏保护熔丝</h2><p>还有一种可能的攻击手段是借助显微镜和激光切割机等设备来寻找保护熔丝,从而寻查和这部分电路相联系的所有信号线。由于设计有缺陷，因此,只要切断从保护熔丝到其它电路的某一根信号线(或切割掉整个加密电路)或连接1~3根金线(通常称FIB: focused ionbeam)，就能禁止整个保护功能，这样，使用简单的编程器就能直接读出程序存储器的内容。<br>虽然大多数普通单片机都具有熔丝烧断保护单片机内代码的功能，但由于通用低档的单片机并非定位于制作安全类产品，因此,它们往往没有提供有针对性的防范措施且安全级别较低。加上单片机应用场合广泛，销售量大，厂商间委托加工与技术转让频繁,大量技术资料外泻，使得利用该类芯片的设计漏洞和厂商的测试接口，并通过修改熔丝保护位等侵入型攻击或非侵入型攻击手段来读取单片机的内部程序变得比较容易。</p>]]></content>
      
      
      <categories>
          
          <category> 芯片破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 杂谈闲语 </tag>
            
            <tag> 芯片破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式开发，如何防止设备被抄袭？</title>
      <link href="/20230530/more_reverse/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%AE%BE%E5%A4%87%E8%A2%AB%E6%8A%84%E8%A2%AD.html"/>
      <url>/20230530/more_reverse/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%AE%BE%E5%A4%87%E8%A2%AB%E6%8A%84%E8%A2%AD.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在国内做产品设计开发，很难避免不被抄袭，被仿照。在没有形成技术壁垒之前，如何防止产品被抄袭是一个不可回避的问题。</p><hr><h1 id="常规设备"><a href="#常规设备" class="headerlink" title="常规设备"></a>常规设备</h1><p>常规设备主要的防护手段有：</p><ul><li>专利保护</li><li>加密保护代码</li><li>授权校验</li><li>持续更新和改进</li></ul><h2 id="专利保护"><a href="#专利保护" class="headerlink" title="专利保护"></a>专利保护</h2><p>对于一些比较重要的技术发明或是创新，应该尽快申请专利。虽然目前国内对于知识产权保护的力度有限，但申请专利还是有用的，至少可以避免专利被别人提前申请，导致自己侵权。</p><h2 id="加密保护代码"><a href="#加密保护代码" class="headerlink" title="加密保护代码"></a>加密保护代码</h2><p>这里会涉及到加密与性能和成本的平衡，如果对设备成本不是很敏感，可以添加加密芯片；如果是要对程序进行加密，这可能会影响程序的执行效率。</p><h2 id="授权校验"><a href="#授权校验" class="headerlink" title="授权校验"></a>授权校验</h2><p>在产品中引入授权验证机制，例如使用加密密钥或者授权证书，以验证产品的合法性。这可以有效防止未经授权的复制和使用。</p><h2 id="持续更新和改进"><a href="#持续更新和改进" class="headerlink" title="持续更新和改进"></a>持续更新和改进</h2><p>及时修复软件中的漏洞和缺陷，持续进行功能改进和升级。这样可以让产品保持竞争优势，并减少被抄袭的动力。</p><hr><h1 id="嵌入式设备"><a href="#嵌入式设备" class="headerlink" title="嵌入式设备"></a>嵌入式设备</h1><p>对于嵌入式设备而言，主要涉及到结构外观，硬件电路，嵌入式软件。除上面介绍的方法，还可以有下面几种方式，可以增加被抄袭的难度</p><ul><li>打磨关键芯片LOGO</li><li>关闭调试串口</li><li>flash 设置读保护</li><li>对关键信息进行加密和混淆</li></ul><h2 id="打磨关键芯片LOGO"><a href="#打磨关键芯片LOGO" class="headerlink" title="打磨关键芯片LOGO"></a>打磨关键芯片LOGO</h2><p>在嵌入式系统中，不同的处理器，使用不同的交叉编译工具，程序分区布局情况也不一样，可以增加逆向工程分析难度</p><h2 id="关闭调试串口"><a href="#关闭调试串口" class="headerlink" title="关闭调试串口"></a>关闭调试串口</h2><p>正常产品，在量产的时候都应该关闭调试串口，有两个目的：<br>避免调试串口有信号干扰，影响系统稳定性。<br>调试串口一般都会把程序的一些调试和系统信息打印出来，别人可以从这些信息入手进行逆向分析。</p><h2 id="flash-设置读保护"><a href="#flash-设置读保护" class="headerlink" title="flash 设置读保护"></a>flash 设置读保护</h2><p>有一些MCU，在它的烧录器中是可以设置读保护的，也就是使用工具无法直接读取MCU里面的程序。<br>常规的flash也有保护机制，但是保护等级很弱，可以增加加密芯片的方式来避免程序被直接拷贝。但是会影响程序的效率以及增加设备成本。</p><h2 id="对关键信息进行加密和混淆"><a href="#对关键信息进行加密和混淆" class="headerlink" title="对关键信息进行加密和混淆"></a>对关键信息进行加密和混淆</h2><p>在嵌入式系统中，受限于flash容量大小影响，一般都会对执行程序进行格式转换，再压缩。运行的时候，先解压，再进行格式转换，最后再运行。</p><p>在这里可以增加一个步骤，就是加密和混淆，先对关键信息进行加密，然后再转换，之后再压缩，这样可以大大增加逆向分析的难度。</p><hr><h1 id="君正T系列程序破解"><a href="#君正T系列程序破解" class="headerlink" title="君正T系列程序破解"></a>君正T系列程序破解</h1><p>下面以君正广发的方案进行分析:<br>君正的执行程序是放置在根文件系统上，根文件系统挂载上之后，先进行一些初始化设置，然后就直接运行在根文件系统的执行程序。<br>拿到一个君正T系列官方的固件，如果要进行破解，基本的流程应该如下：</p><ul><li>找到根文件系统的位置</li><li>解压根文件系统</li><li>恢复文件系统格式</li><li>找到可执行程序</li><li>对可执行程序进行反编译等操作</li></ul><h2 id="找到根文件系统的位置"><a href="#找到根文件系统的位置" class="headerlink" title="找到根文件系统的位置"></a>找到根文件系统的位置</h2><p>这里涉及到根文件系统的起始位置和大小。<br>一般而言，根文件系统会是在一个独立的分区，而分区信息是可以在boot的参数中去获取，同时可以获取到根文件系统的类型等信息<br>对于君正官方的固件，可以在boot中找到bootargs，bootcmd等信息：<br><img src="/images/disasm/qxrRjyyyzhTYubxo0mp_Tw_001.png" alt="图片"></p><p>通过上面可以知道rootfs的大小为6048K,起始位置为5728K = 0X598000<br><img src="/images/disasm/qxrRjyyyzhTYubxo0mp_Tw_002.png" alt="图片"></p><h2 id="解压和恢复根文件系统"><a href="#解压和恢复根文件系统" class="headerlink" title="解压和恢复根文件系统"></a>解压和恢复根文件系统</h2><p>官方打包的操作方法是：</p><pre class="line-numbers language-none"><code class="language-none">find . | cpio -H newc -o &gt; ..&#x2F;rootfs_camera.cpiolzop -9 -f rootfs_camera.cpio -o rootfs_camera.cpio.lzofind . | cpio -H newc -o &gt; ..&#x2F;rootfs_camera.cpio<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>它是使用 cpio 命令将当前文件及其子文件打包成<code>rootfs_camera.cpio</code> 文件，使用的是newc 文件格式<br><code>lzop -9 -f rootfs_camera.cpio -o rootfs_camera.cpio.lzo</code><br>它是使用lzop 命令，将<code>rootfs_camera.cpio</code>压缩成<code>rootfs_camera.cpio.lzo</code> 文件</p><h2 id="逆向操作"><a href="#逆向操作" class="headerlink" title="逆向操作"></a>逆向操作</h2><p>执行下面命令：</p><pre class="line-numbers language-none"><code class="language-none">lzop -d rootfs_camera.cpio.lzocpio -i &lt; rootfs_camera.cpiolzop -d rootfs_camera.cpio.lzo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将<code>rootfs_camera.cpio.lzo</code> 文件解压到当前目录<br><code>cpio -i &lt; rootfs_camera.cpio</code><br><code>rootfs_camera.cpio</code> 文件中的内容将被解包并恢复为原始的文件和目录结构，这些文件和目录将出现在当前工作目录中。<br>通过<code>etc/init.d/rcS</code> 文件可以找到有启动哪些程序，对应程序放置在什么位置,最后可以通过反汇编等信息得到想要的信息。</p><hr><h1 id="如何防止被逆向破解"><a href="#如何防止被逆向破解" class="headerlink" title="如何防止被逆向破解"></a>如何防止被逆向破解</h1><p>通过上面对君正官方的设计分析，对于内行的专业工程师，还是比较容易被破解。那可以通过什么手段增加被破解的难度呢？</p><h2 id="对整个根文件系统进行加密"><a href="#对整个根文件系统进行加密" class="headerlink" title="对整个根文件系统进行加密"></a>对整个根文件系统进行加密</h2><p>加密分为对称加密和非对称加密，在嵌入式系统中，比较推荐使用对称加密的算法，比如AES算法</p><ul><li>编译打包过程</li><li>选择AES密钥长度</li><li>生成密钥</li><li>使用密钥对文件进行加密</li><li>将加密的<code>rootfs_camera.cpio.lzo</code> 打包到固件包里</li></ul><p>设备运行流程</p><blockquote><p>kernel 在启动过程中，会将根文件系统拷贝到内存中，然后再进行解压<br>在解压之前，使用打包时的密钥进行解密，之后再按原来流程继续执行</p></blockquote><p>优缺点</p><blockquote><p>优点是可以对整个文件系统进行加密，破解的难度会比较高<br>缺点是会影响启动速度，如果对于快速启动系统，这种方式会有影响</p></blockquote><h2 id="只对关键信息加密"><a href="#只对关键信息加密" class="headerlink" title="只对关键信息加密"></a>只对关键信息加密</h2><p>对嵌入式系统而言，关键信息可以是：</p><ul><li>某些关键算法库</li><li>产品序列号等信息</li><li>算法模型文件等</li></ul><p>加密和解密方式与上面根文件系统加密方式一样，区别是在系统运行的不同阶段进行解密操作</p><ul><li>优点是不会影响系统的启动速递</li><li>缺点是相对来说，比较容易被逆向分析</li></ul><hr><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>所有的加密都有被破解的可能，实际设计产品应根据产品行业安全等级去设计不同等级的加密。不提倡大家去抄袭破解别人的设备，但也应合理地保护好自己的知识产权。<br>持续更新和改进自己的产品设计方案，让自己的产品和方案形成技术壁垒，这就不会过度的担心自己产品被抄袭了。</p>]]></content>
      
      
      <categories>
          
          <category> 芯片破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 杂谈闲语 </tag>
            
            <tag> 芯片破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用stm32的UID给固件加密</title>
      <link href="/20230530/more_reverse/%E7%94%A8stm32%E7%9A%84UID%E7%BB%99%E5%9B%BA%E4%BB%B6%E5%8A%A0%E5%AF%86.html"/>
      <url>/20230530/more_reverse/%E7%94%A8stm32%E7%9A%84UID%E7%BB%99%E5%9B%BA%E4%BB%B6%E5%8A%A0%E5%AF%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="聊一聊"><a href="#聊一聊" class="headerlink" title="聊一聊"></a>聊一聊</h1><blockquote><p>演员这首歌大家应该再熟悉不过了，其中印象最为深刻的歌词是:”简单点，说话的方式简单点……”,说话真的是一门技术，同时也是门艺术！<br>今天跟大家带来的知识不算难，现在非常多MCU都有全球唯一标识码这个东西，可能大家都了解过，不过具体怎么用并没有实际设计过！下面重点对其加密方面的应用跟大家理一理。</p></blockquote><h1 id="stm32的标识码UID"><a href="#stm32的标识码UID" class="headerlink" title="stm32的标识码UID"></a>stm32的标识码UID</h1><blockquote><p>对于目前大部分MCU都会存在一个唯一标识码供用户使用，同样stm32也是一样，通过查找对应的数据手册便可以得到该唯一标识码的具体信息。<br>这里以stm32F103为例，其他型号的stm32性能也可能不存在该唯一标识，具体需要根据对应的数据手册进行查阅，如果存在可能基地址稍有不同。如下图所示:<br><img src="/images/learn/hacker/Oo32n9te9mIWDtrzwFEXrw_001.png" alt="图片"><br>分析一下：<br>1  stm32的标识码放在了唯一设备ID寄存器里面，一共96个bit也就是12个字节且只能读取。<br>2  通过手册上的说明可以大致了解到该唯一标识码的应用场景。<br>3 一般的量产产品都会有一个设备的条码，那么这个唯一的标识码便可以作为条码的一部分来供查找。<br>4  在通信协议中该唯一标识码可以作为一种标识序列号来进行设备的加载和区分。<br>5  当然最后就是把其作为一个安全密钥，然后与软件加密算法结合起来以降低固件被恶意复制的风险。</p></blockquote><h1 id="读取UID"><a href="#读取UID" class="headerlink" title="读取UID"></a>读取UID</h1><blockquote><p>对于该唯一标识ID，bug菌这里谈两点注意的:<br>  1、唯一标识ID只是stm32里面一种ID，其实一款芯片内部还有很多其他ID，比如设备ID和其他内部组件的ID等；<br>  2、UID一共是96位具有唯一性，而截取中间的几位不一定具有唯一性。<br>  3、对于UID的读取非常简单，上面的手册截图也说明了，可以通过字节、半字和字来进行读取，也就是说可以用8位、16位、32位来读取。<br>参考Demo：</p><pre class="line-numbers language-none"><code class="language-none">uint32_t  Unique[3] &#x3D; &#123;0&#125;;uint8_t   unique[12] &#x3D; &#123;0&#125;;int main(void)&#123;            uint8_t i;    Unique[0] &#x3D; *(uint32_t*)(0x1FFFF7E8);    Unique[1] &#x3D; *(uint32_t*)(0x1FFFF7E8 + 4);    Unique[2] &#x3D; *(uint32_t*)(0x1FFFF7E8 + 8);    printf(&quot;以uint32_t读:\r\n&quot;);&#x2F;&#x2F;插入换行    printf(&quot;ID  0-31 :%x\r\n&quot;,Unique[0]);&#x2F;&#x2F;插入换行    printf(&quot;ID 32-63 :%x\r\n&quot;,Unique[1]);&#x2F;&#x2F;插入换行    printf(&quot;ID 64-95 :%x\r\n&quot;,Unique[2]);&#x2F;&#x2F;插入换行    for(i &#x3D; 0 ;i &lt; 12;i++)    &#123;        unique[i] &#x3D; *(uint8_t*)(0x1FFFF7E8 + i);    &#125;    printf(&quot;以uint8_t读:\r\n&quot;);&#x2F;&#x2F;插入换行    for(i &#x3D; 0;i&lt;12;i++)    &#123;         printf(&quot;ID byte%d :%x   &quot;,i,unique[i]);&#x2F;&#x2F;插入换行        if(i%4 &#x3D;&#x3D; 3) printf(&quot;\r\n&quot;);&#x2F;&#x2F;插入换行     &#125;    printf(&quot;\r\n公众号:最后一个bug\r\n&quot;);&#x2F;&#x2F;插入换行&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：<br><img src="/images/learn/hacker/Oo32n9te9mIWDtrzwFEXrw_002.png" alt="图片"></p></blockquote><h1 id="UID加密简易版"><a href="#UID加密简易版" class="headerlink" title="UID加密简易版"></a>UID加密简易版</h1><blockquote><p>之前bug菌整理过一篇单片机解密的文章&lt;【整理】一文带你了解”单片机解密”技术&gt;，对于解密的办法可以说是无比的残忍，其实芯片的加密与解密跟网络安全的攻防是一样的。<br>所谓:”道高一尺魔高一丈”，只有不断的更新加密技术以增加解密成本或许在一定程度上能够遏制不正规解密行为在，下面就先介绍一下UID的一种简易加密方案，为什么说简易呢？可以说修改部分固件实现一个跳转功能就解密了，不过对于一般的小型产品还是能够在一定程度上起到保密效果的。<br><img src="/images/learn/hacker/Oo32n9te9mIWDtrzwFEXrw_003.png" alt="图片"></p><p>解释两句：<br>  1 左边是在芯片外部实现的，可以通过编写一个上位机来自动生成密钥并保存到芯片中的存储介质中。<br>  2 上面所说的UID与密钥的隐式获取是指 : 其读取过程中的地址等信息不要显式的暴露在固件中，比如上面提到的UID的地址或许是密钥的地址，可以通过数据变换、运算等等进行隐藏。<br>  3 最后一步如果密钥不一致进行自动清除固件，该思想有点类似于我们平时密码输入，如果输入次数较多就会锁定无法解锁，这样对解密过程造成阻碍。</p></blockquote><h1 id="加强版本"><a href="#加强版本" class="headerlink" title="加强版本"></a>加强版本</h1><p>对于上面的加密方法其关卡点就一个位置，如果在固件空白区域安插一些跳转指令跳转到正常运行的位置，你的固件就解密了。<br>所以目前比较常用的是对整个固件进行完整性标识序列与UID组合进行加密的办法。<br><img src="/images/learn/hacker/Oo32n9te9mIWDtrzwFEXrw_004.png" alt="图片"><br><img src="/images/learn/hacker/Oo32n9te9mIWDtrzwFEXrw_005.png" alt="图片"><br>所以对于未使用的存储区域最好是都填充完，避免被解密者利用。</p><h1 id="另类版本"><a href="#另类版本" class="headerlink" title="另类版本"></a>另类版本</h1><blockquote><p>出于关卡点过于单一的问题考虑，我们需要进行多处的关卡点处理，同样各个关卡点的复杂度也会给解密者带来困难，每一处关卡点都带有解密信息，相当于每次都会需要判断机密，从而让跳转这种办法失效。<br>最简单的处理办法就是定义一些宏处理，比如:</p><pre class="line-numbers language-none"><code class="language-none">#define Sect_TURE  (UIDCODE - SAVECODE  + 1)#define Sect_FALSE (UIDCODE - SAVECODE)#define Sect_NUM_1 (UIDCODE - SAVECODE  + 1)#define Sect_NUM_2 (UIDCODE - SAVECODE  + 2)......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然不仅仅只有上面的处理，我们还可以通过替换为其他变量来隐藏一些处理办法，从而达到迷惑解密着的目的。这样我们就可以把加密分布到程序的各个角落，加强了固件的安全性。<br>不过这样的办法如果放在访问较为频繁的位置，势必会影响系统的性能，如果所使用的芯片性能一般，可以选择部分关键关卡点处理。<br>好吧，所以一切安全的前提是唯一标识码UID无法被修改，否则也是徒劳，不过既然芯片都是人造的，那肯定就有办法进行解密，只是成本问题。</p></blockquote><h1 id="最后小结"><a href="#最后小结" class="headerlink" title="最后小结"></a>最后小结</h1><blockquote><p>本文到这里就结束了，对于MCU的加密和解密是一个永恒的话题，同样对于一个成熟的产品加密也是必须要考虑的技术问题，看看大家还有什么好的MCU加密办法，欢迎大家分享留言讨论！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 芯片破解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> STM32 </tag>
            
            <tag> 杂谈闲语 </tag>
            
            <tag> 芯片破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DAP之FLM算法研究</title>
      <link href="/20230509/flm_cmsis/DAP%E4%B9%8BFLM%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6.html"/>
      <url>/20230509/flm_cmsis/DAP%E4%B9%8BFLM%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6.html</url>
      
        <content type="html"><![CDATA[<p>玩过自制DAP工具的一定都知道通过MDK目录的FLM文件，通过工具可以获取一段FLASH的操作算法文件，算法文件由一串HEX字符串组成，但这算法的内容相信大多数的人都没有研究过。由于本人尽来因为服务的客户令人十分糟心，也想搞个刷写器的项目，因此本着好奇的心，研究了了该HEX文本的算法内容，并将汇编反译成了C。</p><p>以下记录下过程：</p><h1 id="FlashAlgo生成C文件"><a href="#FlashAlgo生成C文件" class="headerlink" title="FlashAlgo生成C文件"></a>FlashAlgo生成C文件</h1><p>FlashAlgo压缩文件内有两个FLM文件，一个EXE文件<br><img src="/images/cmsis_dap/63c506a764464eca9edbc8dcf41fac4e.png" alt="FlashAlgo压缩文件内容"></p><p>而FLM文件通过搜索MDK的安装目录大约可以找到90多个，因此对于不同的芯片，如果想要制作不同的DAP的话，通过更换FLM文件即可制作算法文件。<br><img src="/images/cmsis_dap/0e33e10622e64130aecc13d924d17383.png" alt="MDK安装目录的FLM"></p><h2 id="flash-algo生成的C代码"><a href="#flash-algo生成的C代码" class="headerlink" title="flash_algo生成的C代码"></a>flash_algo生成的C代码</h2><p> 以下以STM32F10X的芯片为例，使用flash_algo生成的C代码如下</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;* Flash OS Routines (Automagically Generated) * Copyright (c) 2009-2015 ARM Limited *&#x2F;#include &quot;flash_blob.h&quot;&#x2F;*******************************************              stm32F1系列的下载算法*其作用就是在下载主程序之前，给目标MCU的SRAM下载一段引导代码*然后调用这段代码里面的flash读取和擦除函数对目标芯片编程*不同芯片的下载算法不同，其下载算法可以在MDK的FLM文件中提取*&#x2F;static const uint32_t flash_code[] &#x3D; &#123;    0xE00ABE00, 0x062D780D, 0x24084068, 0xD3000040, 0x1E644058, 0x1C49D1FA, 0x2A001E52, 0x4770D1F2,    0x4603B510, 0x4C442000, 0x48446020, 0x48446060, 0x46206060, 0xF01069C0, 0xD1080F04, 0x5055F245,    0x60204C40, 0x60602006, 0x70FFF640, 0x200060A0, 0x4601BD10, 0x69004838, 0x0080F040, 0x61104A36,    0x47702000, 0x69004834, 0x0004F040, 0x61084932, 0x69004608, 0x0040F040, 0xE0036108, 0x20AAF64A,    0x60084930, 0x68C0482C, 0x0F01F010, 0x482AD1F6, 0xF0206900, 0x49280004, 0x20006108, 0x46014770,    0x69004825, 0x0002F040, 0x61104A23, 0x61414610, 0xF0406900, 0x61100040, 0xF64AE003, 0x4A2120AA,    0x481D6010, 0xF01068C0, 0xD1F60F01, 0x6900481A, 0x0002F020, 0x61104A18, 0x47702000, 0x4603B510,    0xF0201C48, 0xE0220101, 0x69004813, 0x0001F040, 0x61204C11, 0x80188810, 0x480FBF00, 0xF01068C0,    0xD1FA0F01, 0x6900480C, 0x0001F020, 0x61204C0A, 0x68C04620, 0x0F14F010, 0x4620D006, 0xF04068C0,    0x60E00014, 0xBD102001, 0x1C921C9B, 0x29001E89, 0x2000D1DA, 0x0000E7F7, 0x40022000, 0x45670123,    0xCDEF89AB, 0x40003000, 0x00000000&#125;;const program_target_t flash_algo &#x3D; &#123;    0x20000021,  &#x2F;&#x2F; Init    0x20000053,  &#x2F;&#x2F; UnInit    0x20000065,  &#x2F;&#x2F; EraseChip    0x2000009F,  &#x2F;&#x2F; EraseSector    0x200000DD,  &#x2F;&#x2F; ProgramPage    &#x2F;&#x2F; BKPT : start of blob + 1    &#x2F;&#x2F; RSB  : address to access global&#x2F;static data    &#x2F;&#x2F; RSP  : stack pointer    &#123;        0x20000001,        0x20000C00,        0x20001000    &#125;,    0x20000400,  &#x2F;&#x2F; mem buffer location    0x20000000,  &#x2F;&#x2F; location to write prog_blob in target RAM    sizeof(flash_code),  &#x2F;&#x2F; prog_blob size    flash_code,  &#x2F;&#x2F; address of prog_blob    0x00000400,  &#x2F;&#x2F; ram_to_flash_bytes_to_be_written&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将其中的flash_code写入到一个TXT文件中，并使用自制的工具将其转换为HEX文件<br><img src="/images/cmsis_dap/8497831d50914708b548bebda944d2f9.png" alt="flash_codel转HEX"></p><h1 id="反汇编的ASM文件"><a href="#反汇编的ASM文件" class="headerlink" title="反汇编的ASM文件"></a>反汇编的ASM文件</h1><pre class="line-numbers language-ASM" data-language="ASM"><code class="language-ASM">;-------------------------------------------------------------------------------;---- DISASSEMBLE INFORMATION :;---- File Name: flash_blob.hex;---- CPU Family:STM32F10x;---- CPU Factory:STMicroelectronics;---- CPU Model: STM32F103C8T6;---- Time Stamp: 621073228816300;----;----   Writen by: beacon_light@163.com;----      Wechat: 18676693732;----          QQ: 19263826;-------------------------------------------------------------------------------                PRESERVE8                THUMB                AREA    RESET, DATA, READONLY                DCD 0__Vectors       DCD Reset_Handler                ;ALIGN 0X200; Segment type: Pure code                AREA    |.text|, CODE, READONLY;AREA    RAMCODE, CODE, READONLY; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; S U B R O U T I N E &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Reset_Handler;BKPT_20000000                BKPT    0                B       loc_2000001Aloc_20000004                LDRB    R5, [R1]                LSLS    R5, R5, #0x18                EORS    R0, R5                MOVS    R4, #8loc_2000000C                LSLS    R0, R0, #1                BCC     loc_20000012                EORS    R0, R3loc_20000012                SUBS    R4, R4, #1                BNE     loc_2000000C                ADDS    R1, R1, #1                SUBS    R2, R2, #1loc_2000001A                CMP     R2, #0                BNE     loc_20000004                BX      LR; End of function BKPT_20000000; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; S U B R O U T I N E &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Init_20000020                PUSH    &#123;R4,LR&#125;                MOV     R3, R0                MOVS    R0, #0                LDR     R4, off_20000138 ; 0x40022000                STR     R0, [R4]                LDR     R0, dword_2000013C ; 0x45670123                STR     R0, [R4,#4]                LDR     R0, dword_20000140 ; 0xCDEF89AB                STR     R0, [R4,#4]                MOV     R0, R4                LDR     R0, [R0,#0x1C]                TST.W   R0, #4                BNE     loc_2000004E                MOVW    R0, #0x5555                LDR     R4, off_20000144 ; 0x40003000                STR     R0, [R4]                MOVS    R0, #6                STR     R0, [R4,#4]                MOVW    R0, #0xFFF                STR     R0, [R4,#8]loc_2000004E                MOVS    R0, #0                POP     &#123;R4,PC&#125;; End of function Init_20000020; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; S U B R O U T I N E &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;UnInit_20000052                MOV     R1, R0                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0x10]                ORR.W   R0, R0, #0x80                LDR     R2, off_20000138 ; 0x40022000                STR     R0, [R2,#0x10]                MOVS    R0, #0                BX      LR; End of function UnInit_20000052; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; S U B R O U T I N E &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;EraseChip_20000064                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0x10]                ORR.W   R0, R0, #4                LDR     R1, off_20000138 ; 0x40022000                STR     R0, [R1,#0x10]                MOV     R0, R1                LDR     R0, [R0,#0x10]                ORR.W   R0, R0, #0x40                STR     R0, [R1,#0x10]                B       loc_20000084; ---------------------------------------------------------------------------loc_2000007C                MOVW    R0, #0xAAAA                LDR     R1, off_20000144 ; 0x40003000                STR     R0, [R1]loc_20000084                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0xC]                TST.W   R0, #1                BNE     loc_2000007C                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0x10]                BIC.W   R0, R0, #4                LDR     R1, off_20000138 ; 0x40022000                STR     R0, [R1,#0x10]                MOVS    R0, #0                BX      LR; End of function EraseChip_20000064; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; S U B R O U T I N E &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;EraseSector_2000009E                MOV     R1, R0                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0x10]                ORR.W   R0, R0, #2                LDR     R2, off_20000138 ; 0x40022000                STR     R0, [R2,#0x10]                MOV     R0, R2                STR     R1, [R0,#0x14]                LDR     R0, [R0,#0x10]                ORR.W   R0, R0, #0x40                STR     R0, [R2,#0x10]                B       loc_200000C2; ---------------------------------------------------------------------------loc_200000BA                MOVW    R0, #0xAAAA                LDR     R2, off_20000144 ; 0x40003000                STR     R0, [R2]loc_200000C2                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0xC]                TST.W   R0, #1                BNE     loc_200000BA                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0x10]                BIC.W   R0, R0, #2                LDR     R2, off_20000138 ; 0x40022000                STR     R0, [R2,#0x10]                MOVS    R0, #0                BX      LR; End of function EraseSector_2000009E; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; S U B R O U T I N E &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;ProgramPage_200000DC                PUSH    &#123;R4,LR&#125;                MOV     R3, R0                ADDS    R0, R1, #1                BIC.W   R1, R0, #1                B       loc_2000012E; ---------------------------------------------------------------------------loc_200000E8                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0x10]                ORR.W   R0, R0, #1                LDR     R4, off_20000138 ; 0x40022000                STR     R0, [R4,#0x10]                LDRH    R0, [R2]                STRH    R0, [R3]                NOPloc_200000FA                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0xC]                TST.W   R0, #1                BNE     loc_200000FA                LDR     R0, off_20000138 ; 0x40022000                LDR     R0, [R0,#0x10]                BIC.W   R0, R0, #1                LDR     R4, off_20000138 ; 0x40022000                STR     R0, [R4,#0x10]                MOV     R0, R4                LDR     R0, [R0,#0xC]                TST.W   R0, #0x14                BEQ     loc_20000128                MOV     R0, R4                LDR     R0, [R0,#0xC]                ORR.W   R0, R0, #0x14                STR     R0, [R4,#0xC]                MOVS    R0, #1locret_20000126                POP     &#123;R4,PC&#125;; ---------------------------------------------------------------------------loc_20000128                ADDS    R3, R3, #2                ADDS    R2, R2, #2                SUBS    R1, R1, #2loc_2000012E                CMP     R1, #0                BNE     loc_200000E8                MOVS    R0, #0                B       locret_20000126; End of function ProgramPage_200000DC; ---------------------------------------------------------------------------                ALIGN 4off_20000138    DCD 0x40022000dword_2000013C  DCD 0x45670123dword_20000140  DCD 0xCDEF89ABoff_20000144    DCD 0x40003000                DCD 0; seg000        ends                END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="重构的C代码"><a href="#重构的C代码" class="headerlink" title="重构的C代码"></a>重构的C代码</h1><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;stm32f10x_flash.h&quot;&#x2F;* Flash Access Control Register bits *&#x2F;#define ACR_LATENCY_Mask         ((uint32_t)0x00000038)#define ACR_HLFCYA_Mask          ((uint32_t)0xFFFFFFF7)#define ACR_PRFTBE_Mask          ((uint32_t)0xFFFFFFEF)&#x2F;* Flash Access Control Register bits *&#x2F;#define ACR_PRFTBS_Mask          ((uint32_t)0x00000020) &#x2F;* Flash Control Register bits *&#x2F;#define CR_PG_Set                ((uint32_t)0x00000001)#define CR_PG_Reset              ((uint32_t)0x00001FFE) #define CR_PER_Set               ((uint32_t)0x00000002)#define CR_PER_Reset             ((uint32_t)0x00001FFD)#define CR_MER_Set               ((uint32_t)0x00000004)#define CR_MER_Reset             ((uint32_t)0x00001FFB)#define CR_OPTPG_Set             ((uint32_t)0x00000010)#define CR_OPTPG_Reset           ((uint32_t)0x00001FEF)#define CR_OPTER_Set             ((uint32_t)0x00000020)#define CR_OPTER_Reset           ((uint32_t)0x00001FDF)#define CR_STRT_Set              ((uint32_t)0x00000040)#define CR_LOCK_Set              ((uint32_t)0x00000080)&#x2F;* FLASH Mask *&#x2F;#define RDPRT_Mask               ((uint32_t)0x00000002)#define WRP0_Mask                ((uint32_t)0x000000FF)#define WRP1_Mask                ((uint32_t)0x0000FF00)#define WRP2_Mask                ((uint32_t)0x00FF0000)#define WRP3_Mask                ((uint32_t)0xFF000000)#define OB_USER_BFB2             ((uint16_t)0x0008)&#x2F;* FLASH Keys *&#x2F;#define RDP_Key                  ((uint16_t)0x00A5)#define FLASH_KEY1               ((uint32_t)0x45670123)#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)&#x2F;* FLASH BANK address *&#x2F;#define FLASH_BANK1_END_ADDRESS   ((uint32_t)0x807FFFF)&#x2F;* Delay definition *&#x2F;   #define EraseTimeout          ((uint32_t)0x000B0000)#define ProgramTimeout        ((uint32_t)0x00002000)#define BKPT(v) __asm &#123; BKPT v &#125;void BreakPoint(int r0, char* r1, int len, int r3)&#123;    int c, temp;      BKPT(0)    for(; len; len--,r1++) &#123;      temp &#x3D; *r1&lt;&lt;24;      r0 ^&#x3D; temp;      for(c&#x3D;8; c; c--) &#123;           temp &#x3D; r0;           r0 &lt;&lt;&#x3D; 1;           if(temp&amp;0x80000000) &#123;               r0 ^&#x3D; r3;           &#125;      &#125;   &#125;&#125;int Init()&#123;     FLASH-&gt;ACR &#x3D; 0; &#x2F;&#x2F; 0x40022000    FLASH-&gt;KEYR &#x3D; FLASH_KEY1; &#x2F;&#x2F; 0x45670123, unlock Flash 1&#x2F;2    FLASH-&gt;KEYR &#x3D; FLASH_KEY2; &#x2F;&#x2F; 0xCDEF89AB, unlock Flash 2&#x2F;2    if(FLASH-&gt;OBR&amp;4) &#123;        &#x2F;&#x2F; User Option: IWDG_SW(Bit0) is Set        IWDG-&gt;KR &#x3D; 0x5555;         IWDG-&gt;PR &#x3D; 6;         IWDG-&gt;RLR &#x3D; 0xFFF;     &#125;    return 0; &#125;int UnInit(void) &#123;    FLASH-&gt;CR |&#x3D; CR_LOCK_Set;     return 0; &#125; int EraseChip(void)&#123;    FLASH-&gt;CR |&#x3D; CR_MER_Set;  &#x2F;&#x2F; 0x04    FLASH-&gt;CR |&#x3D; CR_STRT_Set; &#x2F;&#x2F; 0x40    while(FLASH-&gt;SR&amp;FLASH_FLAG_BSY) &#123;         IWDG-&gt;KR &#x3D; 0xAAAA;     &#125;    FLASH-&gt;CR &amp;&#x3D; CR_MER_Reset;     return 0; &#125;int EraseSector(int sectorNum) &#123;    FLASH-&gt;CR |&#x3D; CR_PER_Set; &#x2F;&#x2F; 0x02     FLASH-&gt;AR &#x3D; sectorNum;     FLASH-&gt;CR |&#x3D; CR_STRT_Set; &#x2F;&#x2F; 0x40    while(FLASH-&gt;SR&amp;FLASH_FLAG_BSY) &#123;         IWDG-&gt;KR &#x3D; 0xAAAA;     &#125;    FLASH-&gt;CR &amp;&#x3D; CR_PER_Reset;     return 0; &#125;int ProgramPage(char* dst, int size, char* src, int len) &#123;     &#x2F;&#x2F; Align 2 bytes    size +&#x3D; 1;     size &amp;&#x3D; ~1;         for(; size; size-&#x3D;2) &#123;         FLASH-&gt;CR |&#x3D; CR_PG_Set; &#x2F;&#x2F; 0x01         *((uint16_t*)dst) &#x3D; *((uint16_t*)src);         __NOP();        while(FLASH-&gt;SR&amp;FLASH_FLAG_BSY);         FLASH-&gt;CR &amp;&#x3D; CR_PG_Reset;          if(FLASH-&gt;SR&amp;(FLASH_FLAG_PGERR|FLASH_FLAG_WRPRTERR)) &#123;             FLASH-&gt;SR |&#x3D; FLASH_FLAG_PGERR|FLASH_FLAG_WRPRTERR;             return 1;         &#125;        dst +&#x3D; 2;         src +&#x3D; 2;     &#125;    return 0; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="一个未知问题"><a href="#一个未知问题" class="headerlink" title="一个未知问题"></a>一个未知问题</h1><p>由文中可见BreakPoint函数中的操作，联系DAP的上下文，该段代码并没有什么的用途 ，不知具体何用<br><img src="/images/cmsis_dap/0b27ce35ca674a7baa6c461e2b32cb7c.png" alt="swd_falsh_syscall_exec调用"></p><p> breakpoint是做为完成函数调用后的返回，里面正常应该是一个死循环，但实际上的操作做了一些数据的运算，实在不知其义</p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>​<a href="/downloads/code/dap/flash_blob.zip">flash_blob.zip</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_43666306/article/details/109311798">关于STM32Flash详解_stmflash_涂路的博客-CSDN博客</a><br><a href="https://blog.csdn.net/weibo1230123/article/details/80705866">STM32的IWDG（独立看门狗）详细用法_stm32 iwdg_魏波.的博客-CSDN博客</a><br><a href="https://blog.csdn.net/zhanglifu3601881/article/details/95040782">STM32 进阶教程 11 - RAM中运行程序_stm32程序在ram中运行_张十三的博客的博客-CSDN博客</a></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 算法研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 原创 </tag>
            
            <tag> FLM </tag>
            
            <tag> CMSIS-DAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写FLM编程算法文件（制作离线烧录器的OPT文件）</title>
      <link href="/20230509/flm_cmsis/FLM-%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95.html"/>
      <url>/20230509/flm_cmsis/FLM-%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在MDK的Debug界面下的Flash Download可以选择芯片的编程算法，在安装了芯片包之后可以直接得到目标的编程算法文件，但是对于芯片包的开发者或者有独特的下载需求(校验)，这个时候就需要去编写编程算法文件。<br><img src="/images/cmsis_dap/8ab95bd49dc578b964281ef5c8f07f40.png" alt="MDK选择芯片的编程算法"></p><p>编程算法是一段程序，主要功能是擦除相应的内存块，并将程序写入到相应的内存区域上去。在点击下载按钮的时候，这段程序会被先下载到目标芯片的RAM上，然后才会通过它，将用户写的程序写入到指定的内存区域内。</p><p>通过SWD接口协议下载一段下载算法，然后只需要把固件的数据文件直接下载到RAM中，下载算法会自动运行，边接收固件边写入FLASH，实现一个完整的烧录过程。<br><img src="/images/cmsis_dap/14d224ba6d09ae234693c523757bf255.png" alt="SWD接口协议下载算法流程"></p><h1 id="如何实现一个自己的编程算法？"><a href="#如何实现一个自己的编程算法？" class="headerlink" title="如何实现一个自己的编程算法？"></a>如何实现一个自己的编程算法？</h1><h2 id="加载工程模板"><a href="#加载工程模板" class="headerlink" title="加载工程模板"></a>加载工程模板</h2><p>在MDK安装路径下有一个编程算法的<a href="D:\Keil_v5\ARM\Flash_Template">工程模板(D:\Keil_v5\ARM\Flash_Template)</a><br><img src="/images/cmsis_dap/80a2fbfba5a7e6e05926fb0e91f965a1.png" alt="MDK安装路径的编程算法模板"></p><p>打开工程，里面主要有两个文件，分别是FlashPrg.c和FlashDev.c。</p><h2 id="实现设备相关的结构体"><a href="#实现设备相关的结构体" class="headerlink" title="实现设备相关的结构体"></a>实现设备相关的结构体</h2><p>在FlashDev.c中主要实现了一个设备相关的结构体，需要根据目标的Flash情况去实现。<br><img src="/images/cmsis_dap/b091a8db72396e36426b1bcdc16f0be8.png" alt="设备结构体"></p><p>例如STM32F103实现如下<br><img src="/images/cmsis_dap/f68b3a3e191dce067ad2c74c7099c51a.png" alt="STM32F103实现"></p><h2 id="实现FlashPrg-c中与Flash编程相关的函数"><a href="#实现FlashPrg-c中与Flash编程相关的函数" class="headerlink" title="实现FlashPrg.c中与Flash编程相关的函数"></a>实现FlashPrg.c中与Flash编程相关的函数</h2><p>在FlashPrg.c中实现了与Flash编程相关的函数<br><img src="/images/cmsis_dap/f7e0ec004f647b4c178097d20936aac9.png" alt="FlashPrg.c实现"></p><h3 id="1-int-Init-unsigned-long-adr-unsigned-long-clk-unsigned-long-fnc"><a href="#1-int-Init-unsigned-long-adr-unsigned-long-clk-unsigned-long-fnc" class="headerlink" title="1. int Init(unsigned long adr, unsigned long clk, unsigned long fnc);"></a>1. <code>int Init(unsigned long adr, unsigned long clk, unsigned long fnc);</code></h3><p>负责FLASH器件的初始化工作，其中：<br>adr：设备首地址<br>clk：时钟频率<br>fnc：要执行的flash操作，包括Erase、Program、Verify</p><h3 id="2-int-EraseChip-void"><a href="#2-int-EraseChip-void" class="headerlink" title="2. int EraseChip(void);"></a>2. <code>int EraseChip(void);</code></h3><p>擦除整块flash</p><h3 id="3-int-EraseSector-unsigned-long-adr"><a href="#3-int-EraseSector-unsigned-long-adr" class="headerlink" title="3. int EraseSector(unsigned long adr);"></a>3. <code>int EraseSector(unsigned long adr);</code></h3><p>擦除adr所指定地址处的整个sector</p><h3 id="4-int-ProgramPage-unsigned-long-adr-unsigned-long-sz-unsigned-char-buf"><a href="#4-int-ProgramPage-unsigned-long-adr-unsigned-long-sz-unsigned-char-buf" class="headerlink" title="4. int ProgramPage(unsigned long adr, unsigned long sz, unsigned char *buf);"></a>4. <code>int ProgramPage(unsigned long adr, unsigned long sz, unsigned char *buf);</code></h3><p>对flash进行烧写操作，其中：<br>adr：待烧写地址<br>sz：待烧写数据长度<br>buf：待烧写数据</p><h1 id="FLM文件的获取及使用"><a href="#FLM文件的获取及使用" class="headerlink" title="FLM文件的获取及使用"></a>FLM文件的获取及使用</h1><p>编译工程文件，在输出目录下即可看到*.axf文件，工程中的*.axf文件跟*.FLM文件相同，只需将后缀.axf修改为.FLM，然后复制到MDK安装目录的ARM/FLASH下，就能在选项卡里选择自己的编程算法文件了。<br><code>cmd.exe /C copy &quot;Objects\%L&quot; &quot;.\@L.FLM&quot;</code><br><img src="/images/cmsis_dap/cbd1290a927060f01e8134e41d0a63cd.png" alt="FLM复制"></p><p>再通过FlashAlgo开源库进行文件转换就能得到离线下载的编程算法文件了，参考该文献C语言解析FLM(ELF)格式文件可以得到转换工具。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://www.cnblogs.com/jiuliblog-2016/p/11907019.html">MDK程序下载 —- FLM文件</a><br><a href="https://www.elecfans.com/d/1724573.html">怎么样实现烧写算法FLM文件</a></p><h2 id="参考手册："><a href="#参考手册：" class="headerlink" title="参考手册："></a>参考手册：</h2><p><a href="https://www.aliyundrive.com/s/gzqwYgj6v36">STM32F10XX闪存编程手册.pdf</a><br><a href="https://www.aliyundrive.com/s/KPvr4FumMmz">STM32中文参考手册_V10.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> FLM </tag>
            
            <tag> CMSIS-DAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown 官方教程</title>
      <link href="/20230509/markdown_base/MarkDown-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B.html"/>
      <url>/20230509/markdown_base/MarkDown-%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-基本语法"><a href="#Markdown-基本语法" class="headerlink" title="Markdown 基本语法"></a>Markdown 基本语法</h1><p>Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。<br>在线体验一下 Markdown在线编辑器。<br>千万不要被「标记」、「语言」吓到，Markdown的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。<br>就是这十个不到的标记符号，却能让人优雅地沉浸式记录，专注内容而不是纠结排版，达到「心中无尘，码字入神」的境界。<br>让我们从 Markdown 标题语法开始学习吧。</p><h2 id="Markdown-标题语法"><a href="#Markdown-标题语法" class="headerlink" title="Markdown 标题语法"></a>Markdown 标题语法</h2><p>要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题(&lt;h3&gt;) (例如：### My Header)。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left"><code># Heading level 1</code></td><td align="left"><code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code></td><td align="left">Heading level 1</td></tr><tr><td align="left"><code>## Heading level 2</code></td><td align="left"><code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code></td><td align="left">Heading level 2</td></tr><tr><td align="left"><code>### Heading level 3</code></td><td align="left"><code>&lt;h3&gt;Heading level 3&lt;/h3&gt;</code></td><td align="left">Heading level 3</td></tr><tr><td align="left"><code>#### Heading level 4</code></td><td align="left"><code>&lt;h4&gt;Heading level 4&lt;/h4&gt;</code></td><td align="left">Heading level 4</td></tr><tr><td align="left"><code>##### Heading level 5</code></td><td align="left"><code>&lt;h5&gt;Heading level 5&lt;/h5&gt;</code></td><td align="left">Heading level 5</td></tr><tr><td align="left"><code>###### Heading level 6</code></td><td align="left"><code>&lt;h6&gt;Heading level 6&lt;/h6&gt;</code></td><td align="left">Heading level 6</td></tr></tbody></table><h2 id="可选语法"><a href="#可选语法" class="headerlink" title="可选语法"></a>可选语法</h2><p>还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 – 号来标识二级标题。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left"><code>Heading level 1===============</code></td><td align="left"><code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code></td><td align="left">Heading level 1</td></tr><tr><td align="left"><code>Heading level 2---------------</code></td><td align="left"><code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code></td><td align="left">Heading level 2</td></tr></tbody></table><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>不同的 Markdown 应用程序处理 # 和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在 # 和标题之间进行分隔。</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left"># Here’s a Heading</td><td align="left">#Here’s a Heading</td></tr></tbody></table><hr><h1 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h1><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left">I really like using Markdown.<br><br>I think I’ll use it to format all of my documents from now on.</td><td align="left">&lt;p&gt;I really like using Markdown.&lt;/p&gt;<br><br>&lt;p&gt;I think I’ll use it to format all of my documents from now on.&lt;/p&gt;</td><td align="left">I really like using Markdown.<br><br>I think I’ll use it to format all of my documents from now on.</td></tr></tbody></table><h2 id="段落（Paragraph）用法的最佳实"><a href="#段落（Paragraph）用法的最佳实" class="headerlink" title="段落（Paragraph）用法的最佳实"></a>段落（Paragraph）用法的最佳实</h2><p>不要用空格（spaces）或制表符（ tabs）缩进段落。</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left">Don’t put tabs or spaces in front of your paragraphs.<br><br>Keep lines left-aligned like this.</td><td align="left">This can result in unexpected formatting problems.<br><br>    Don’t add tabs or spaces in front of paragraphs.</td></tr></tbody></table><hr><h1 id="Markdown-换行语法"><a href="#Markdown-换行语法" class="headerlink" title="Markdown 换行语法"></a>Markdown 换行语法</h1><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<code>&lt;br&gt;</code>)。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left">This is the first line. <br>And this is the second line.</td><td align="left">&lt;p&gt;This is the first line.&lt;br&gt;<br>And this is the second line.&lt;/p&gt;</td><td align="left">This is the first line.<br>And this is the second line.</td></tr></tbody></table><h2 id="换行（Line-Break）用法的最佳实践"><a href="#换行（Line-Break）用法的最佳实践" class="headerlink" title="换行（Line Break）用法的最佳实践"></a>换行（Line Break）用法的最佳实践</h2><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 结尾空格（trailing whitespace) 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 <code>&lt;br&gt;</code> 标签。</p><p>为了兼容性，请在行尾添加“结尾空格”或 HTML 的 <code>&lt;br&gt;</code> 标签来实现换行。</p><p>还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (<code>\</code>) 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（<code>return</code>）即可实现换行。</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left"><code>First line with two spaces after. </code><br><code>And the next line.</code><br><br><code>First line with the HTML tag after.&lt;br&gt;And the next line.</code></td><td align="left"><code>First line with a backslash after.\</code><br><code>And the next line.</code><br><br><code>First line with nothing after.And the next line.</code></td></tr></tbody></table><hr><h1 id="Markdown-强调语法"><a href="#Markdown-强调语法" class="headerlink" title="Markdown 强调语法"></a>Markdown 强调语法</h1><p>通过将文本设置为粗体或斜体来强调其重要性。</p><h2 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="粗体（Bold）"></a>粗体（Bold）</h2><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left"><code>I just love **bold text**.</code></td><td align="left"><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td><td align="left">I just love <strong>bold text</strong>.</td></tr><tr><td align="left">I just love <strong>bold text</strong>.</td><td align="left">I just love <strong>bold text</strong>.</td><td align="left">I just love <strong>bold text</strong>.</td></tr><tr><td align="left"><code>Love**is**bold</code></td><td align="left"><code>Love&lt;strong&gt;is&lt;/strong&gt;</code></td><td align="left">Love<strong>is</strong>bold</td></tr></tbody></table><h3 id="粗体（Bold）用法最佳实践"><a href="#粗体（Bold）用法最佳实践" class="headerlink" title="粗体（Bold）用法最佳实践"></a>粗体（Bold）用法最佳实践</h3><p>Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left"><code>Love**is**bold</code></td><td align="left"><code>Love__is__bold</code></td></tr></tbody></table><h2 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a>斜体（Italic）</h2><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left"><code>Italicized text is the *cat&#39;s meow*.</code></td><td align="left">Italicized text is the <em>cat’s meow</em>.</td><td align="left">Italicized text is the <em>cat’s meow</em>.</td></tr><tr><td align="left"><code>Italicized text is the _cat&#39;s meow_.</code></td><td align="left">Italicized text is the <em>cat’s meow</em>.</td><td align="left">Italicized text is the <em>cat’s meow</em>.</td></tr><tr><td align="left"><code>A*cat*meow</code></td><td align="left">A<em>cat</em>meow</td><td align="left">A<em>cat</em>meow</td></tr></tbody></table><h3 id="斜体（Italic）用法的最佳实践"><a href="#斜体（Italic）用法的最佳实践" class="headerlink" title="斜体（Italic）用法的最佳实践"></a>斜体（Italic）用法的最佳实践</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left"><code>A*cat*meow</code></td><td align="left"><code>A_cat_meow</code></td></tr></tbody></table><h2 id="粗体（Bold）和斜体（Italic）"><a href="#粗体（Bold）和斜体（Italic）" class="headerlink" title="粗体（Bold）和斜体（Italic）"></a>粗体（Bold）和斜体（Italic）</h2><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left"><code>This text is ***really important***.</code></td><td align="left"><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td align="left">This text is <em><strong>really important</strong></em>.</td></tr><tr><td align="left"><code>This text is ___really important___.</code></td><td align="left"><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td align="left">This text is <em><strong>really important</strong></em>.</td></tr><tr><td align="left"><code>This text is __*really important*__.</code></td><td align="left"><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td align="left">This text is <strong><em>really important</em></strong>.</td></tr><tr><td align="left"><code>This text is **_really important_**.</code></td><td align="left"><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td align="left">This text is <strong><em>really important</em></strong>.</td></tr><tr><td align="left"><code>This is really***very***important text.</code></td><td align="left"><code>This is really&lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt;important text.</code></td><td align="left">This is really<em><strong>very</strong></em>important tett.</td></tr></tbody></table><h3 id="粗体（Bold）和斜体（Italic）用法的最佳实践"><a href="#粗体（Bold）和斜体（Italic）用法的最佳实践" class="headerlink" title="粗体（Bold）和斜体（Italic）用法的最佳实践"></a>粗体（Bold）和斜体（Italic）用法的最佳实践</h3><p>Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left"><code>This is really***very***important text.</code></td><td align="left"><code>This is really___very___important text.</code></td></tr></tbody></table><hr><h1 id="Markdown-引用语法"><a href="#Markdown-引用语法" class="headerlink" title="Markdown 引用语法"></a>Markdown 引用语法</h1><p>要创建块引用，请在段落前添加一个 &gt; 符号。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Dorothy followed her through many of the beautiful rooms in her castle.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下所示：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p></blockquote><h2 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="多个段落的块引用"></a>多个段落的块引用</h2><p>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h2 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h2><p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote></blockquote><h2 id="带有其它元素的块引用"><a href="#带有其它元素的块引用" class="headerlink" title="带有其它元素的块引用"></a>带有其它元素的块引用</h2><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p><pre class="line-numbers language-none"><code class="language-none">&gt; #### The quarterly results look great!&gt;&gt; - Revenue was off the chart.&gt; - Profits were higher than ever.&gt;&gt;  *Everything* is going according to **plan**.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><blockquote><p><strong> The quarterly results look great! </strong></p><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p> <em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><hr><h1 id="Markdown-列表语法"><a href="#Markdown-列表语法" class="headerlink" title="Markdown 列表语法"></a>Markdown 列表语法</h1><p>可以将多个条目组织成有序或无序列表。</p><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left"><code>1. First item</code><br><code>2. Second item </code><br><code>3. Third item  </code><br><code>4. Fourth item</code><br></td><td align="left"><code>&lt;ol&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt; </code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;li&gt;Third item&lt;/li&gt; </code><br><code>&lt;li&gt;Fourth item&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code></td><td align="left">1. First item<br>2. Second item<br>3. Third item<br>4. Fourth item</td></tr><tr><td align="left"><code>1. First item</code><br><code>1. Second item</code><br><code>1. Third item</code><br><code>1. Fourth item</code></td><td align="left"><code>&lt;ol&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;li&gt;Third item&lt;/li&gt;</code><br><code>&lt;li&gt;Fourth item&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code></td><td align="left">1. First item<br>1. Second item<br>1. Third item<br>1. Fourth item</td></tr><tr><td align="left"><code>1. First item</code><br><code>8. Second item</code><br><code>3. Third item</code><br><code>5. Fourth item</code></td><td align="left"><code>&lt;ol&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;li&gt;Third item&lt;/li&gt;</code><br><code>&lt;li&gt;Fourth item&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code></td><td align="left">First item<br>Second item<br>Third item<br>Fourth item</td></tr><tr><td align="left"><code>1. First item</code><br><code>2. Second item</code><br><code>3. Third item</code><br><code>    1. Indented item</code><br><code>    2. Indented item</code><br><code>4. Fourth item</code></td><td align="left"><code>&lt;ol&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;li&gt;Third item</code><br><code>&lt;ol&gt;</code><br><code>&lt;li&gt;Indented item&lt;/li&gt;</code><br><code>&lt;li&gt;Indented item&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code><br><code>&lt;/li&gt;</code><br><code>&lt;li&gt;Fourth item&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code></td><td align="left">1. First item<br>2. Second item<br>3. Third item<br>    1. Indented item<br>    2. Indented item<br>4. Fourth item</td></tr></tbody></table><h3 id="有序列表最佳实践"><a href="#有序列表最佳实践" class="headerlink" title="有序列表最佳实践"></a>有序列表最佳实践</h3><p>CommonMark and a few other lightweight markup languages let you use a parenthesis ()) as a delimiter (e.g., 1) First item), but not all Markdown applications support this, so it isn’t a great option from a compatibility perspective. For compatibility, use periods only.</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left"><code>1. First item</code><br><code>2. Second item</code></td><td align="left"><code>1) First item</code> <br><code>2) Second item</code></td></tr></tbody></table><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left"><code>- First item</code><br><code>- Second item</code><br><code>- Third item</code><br><code>- Fourth item</code></td><td align="left"><code>&lt;ul&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;li&gt;Third item&lt;/li&gt;</code><br><code>&lt;li&gt;Fourth item&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code></td><td align="left">- First item<br>- Second item<br>- Third item<br>- Fourth item</td></tr><tr><td align="left"><code>* First item</code><br><code>* Second item</code><br><code>* Third item</code><br><code>* Fourth item</code></td><td align="left"><code>&lt;ul&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;li&gt;Third item&lt;/li&gt;</code><br><code>&lt;li&gt;Fourth item&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code></td><td align="left">* First item<br>* Second item<br>* Third item<br>* Fourth item</td></tr><tr><td align="left"><code>+ First item</code><br><code>+ Second item</code><br><code>+ Third item</code><br><code>+ Fourth item</code></td><td align="left"><code>&lt;ul&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;li&gt;Third item&lt;/li&gt;</code><br><code>&lt;li&gt;Fourth item&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code></td><td align="left">+ First item<br>+ Second item<br>+ Third item<br>+ Fourth item</td></tr><tr><td align="left"><code>- First item</code><br><code>- Second item</code><br><code>- Third item</code><br><code>    - Indented item</code><br><code>    - Indented item</code><br><code>- Fourth item</code></td><td align="left"><code>&lt;ul&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;li&gt;Third item</code><br><code>&lt;ul&gt;</code><br><code>&lt;li&gt;Indented item&lt;/li&gt;</code><br><code>&lt;li&gt;Indented item&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code><br><code>&lt;/li&gt;</code><br><code>&lt;li&gt;Fourth item&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code></td><td align="left">- First item<br>- Second item<br>- Third item<br>    - Indented item<br>    - Indented item<br>- Fourth item</td></tr></tbody></table><h3 id="无序列表最佳实践"><a href="#无序列表最佳实践" class="headerlink" title="无序列表最佳实践"></a>无序列表最佳实践</h3><p>Markdown applications don’t agree on how to handle different delimiters in the same list. For compatibility, don’t mix and match delimiters in the same list — pick one and stick with it.</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left"><code>- First item</code><br><code>- Second item</code><br><code>- Third item</code><br><code>- Fourth item</code><br></td><td align="left"><code>+ First item</code><br><code>* Second item</code><br><code>- Third item</code><br><code>+ Fourth item</code></td></tr></tbody></table><h2 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a>在列表中嵌套其他元素</h2><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：</p><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><pre class="line-numbers language-none"><code class="language-none">*   This is the first list item.*   Here&#39;s the second list item.    I need to add another paragraph below the second list item.*   And here&#39;s the third list item.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ul><li><p>  This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>  I need to add another paragraph below the second list item.</p></li><li><p>  And here’s the third list item.</p></li></ul><h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><pre class="line-numbers language-none"><code class="language-none">*   This is the first list item.*   Here&#39;s the second list item.    &gt; A blockquote would look great below the second list item.*   And here&#39;s the third list item.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ul><li><p>  This is the first list item.</p></li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>  And here’s the third list item.</p></li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。</p><pre class="line-numbers language-none"><code class="language-none">1.  Open the file.2.  Find the following code block on line 21:        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;Test&lt;&#x2F;title&gt;          &lt;&#x2F;head&gt;3.  Update the title to match the name of your website.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ol><li> Open the file.</li><li> Find the following code block on line 21:<pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;    &lt;head&gt;      &lt;title&gt;Test&lt;&#x2F;title&gt;    &lt;&#x2F;head&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li> Update the title to match the name of your website.</li></ol><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><pre class="line-numbers language-none"><code class="language-none">1.  Open the file containing the Linux mascot.2.  Marvel at its beauty.    ![Tux, the Linux mascot](&#x2F;images&#x2F;learn&#x2F;markdown&#x2F;tux.png)3.  Close the file.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ol><li><p> Open the file containing the Linux mascot.</p></li><li><p>Marvel at its beauty.</p><p> <img src="/images/learn/markdown/tux.png" alt="Tux, the Linux mascot"></p></li><li><p> Close the file.</p></li></ol><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>You can nest an unordered list in an ordered list, or vice versa.</p><pre class="line-numbers language-none"><code class="language-none">1. First item2. Second item3. Third item    - Indented item    - Indented item4. Fourth item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ol><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ol><hr><h1 id="Markdown-代码语法"><a href="#Markdown-代码语法" class="headerlink" title="Markdown 代码语法"></a>Markdown 代码语法</h1><p>要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left">At the command prompt, type <code>nano</code>.</td><td align="left"><code>At the command prompt, type &lt;code&gt;nano&lt;/code&gt;.</code></td><td align="left">At the command prompt, type nano.</td></tr></tbody></table><h2 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h2><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(``)中。</p><table><thead><tr><th align="left">Markdown语法</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left">&#96;&#96;Use &#96;code&#96; in your Markdown file&#96;&#96;.</td><td align="left"><code>&lt;code&gt;Use `code` in your Markdown file.&lt;/code&gt;</code></td><td align="left">Use <code>code</code> in your Markdown file.</td></tr></tbody></table><h2 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h2><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;head&gt;  &lt;&#x2F;head&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><pre><code>&lt;html&gt;  &lt;head&gt;  &lt;/head&gt;&lt;/html&gt;</code></pre><p>Note: 要创建不用缩进的代码块，请使用 围栏式代码块（fenced code blocks）.</p><hr><h1 id="Markdown-分隔线语法"><a href="#Markdown-分隔线语法" class="headerlink" title="Markdown 分隔线语法"></a>Markdown 分隔线语法</h1><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。</p><pre class="line-numbers language-none"><code class="language-none">***---_________________<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上三个分隔线的渲染效果看起来都一样：</p><h2 id="分隔线（Horizontal-Rule）用法最佳实践"><a href="#分隔线（Horizontal-Rule）用法最佳实践" class="headerlink" title="分隔线（Horizontal Rule）用法最佳实践"></a>分隔线（Horizontal Rule）用法最佳实践</h2><p>为了兼容性，请在分隔线的前后均添加空白行。</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left"><code>Try to put a blank line before...</code><br><br><code>---</code><br><br><code>...and after a horizontal rule.</code></td><td align="left"><code>Without blank lines, this would be a heading.</code><br><code>---</code><br><code>Don&#39;t do this!</code></td></tr></tbody></table><hr><h1 id="Markdown-链接语法"><a href="#Markdown-链接语法" class="headerlink" title="Markdown 链接语法"></a>Markdown 链接语法</h1><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p><p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p>对应的HTML代码：<code>&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;</code></p><pre class="line-numbers language-none"><code class="language-none">这是一个链接 [Markdown语法](https:&#x2F;&#x2F;markdown.com.cn)。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：<br>这是一个链接 <a href="https://markdown.com.cn/">Markdown语法</a>。</p><h2 id="给链接增加-Title"><a href="#给链接增加-Title" class="headerlink" title="给链接增加 Title"></a>给链接增加 Title</h2><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。</p><pre class="line-numbers language-none"><code class="language-none">这是一个链接 [Markdown语法](https:&#x2F;&#x2F;markdown.com.cn &quot;最好的markdown教程&quot;)。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：<br>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><h2 id="网址和Email地址"><a href="#网址和Email地址" class="headerlink" title="网址和Email地址"></a>网址和Email地址</h2><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><pre class="line-numbers language-none"><code class="language-none">&lt;https:&#x2F;&#x2F;markdown.com.cn&gt;&lt;fake@example.com&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>渲染效果如下：<br><a href="https://markdown.com.cn/">https://markdown.com.cn</a><br><a href="mailto:&#x66;&#97;&#x6b;&#x65;&#x40;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#x66;&#97;&#x6b;&#x65;&#x40;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a></p><h2 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h2><p>强调 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。</p><pre class="line-numbers language-none"><code class="language-none">I love supporting the **[EFF](https:&#x2F;&#x2F;eff.org)**.This is the *[Markdown Guide](https:&#x2F;&#x2F;www.markdownguide.org)*.See the section on [&#96;code&#96;](#code).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：<br>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em>.<br>See the section on <a href="#code"><code>code</code></a>.</p><h2 id="引用类型链接"><a href="#引用类型链接" class="headerlink" title="引用类型链接"></a>引用类型链接</h2><p>引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。</p><h3 id="链接的第一部分格式"><a href="#链接的第一部分格式" class="headerlink" title="链接的第一部分格式"></a>链接的第一部分格式</h3><p>引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p><p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。</p><p>以下示例格式对于链接的第一部分效果相同：</p><pre class="line-numbers language-none"><code class="language-none">[hobbit-hole][1][hobbit-hole] [1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="链接的第二部分格式"><a href="#链接的第二部分格式" class="headerlink" title="链接的第二部分格式"></a>链接的第二部分格式</h3><p>引用类型链接的第二部分使用以下属性设置格式：</p><p>放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如[label]:）。<br>链接的URL，可以选择将其括在尖括号中。<br>链接的可选标题，可以将其括在双引号，单引号或括号中。<br>以下示例格式对于链接的第二部分效果相同：</p><pre class="line-numbers language-none"><code class="language-none">[1]: https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle[1]: https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;[1]: https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle &#39;Hobbit lifestyles&#39;[1]: https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle (Hobbit lifestyles)[1]: &lt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;[1]: &lt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39;[1]: &lt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&gt; (Hobbit lifestyles)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注或脚注）。</p><h2 id="链接最佳实践"><a href="#链接最佳实践" class="headerlink" title="链接最佳实践"></a>链接最佳实践</h2><p>不同的 Markdown 应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用%20代替空格。</p><table><thead><tr><th align="left">✅  Do this</th><th align="left">❌  Don’t do this</th></tr></thead><tbody><tr><td align="left"><code>[link](https://www.example.com/my%20great%20page)</code></td><td align="left"><code>[link](https://www.example.com/my great page)</code></td></tr></tbody></table><hr><h1 id="Markdown-图片语法"><a href="#Markdown-图片语法" class="headerlink" title="Markdown 图片语法"></a>Markdown 图片语法</h1><p>要添加图像，请使用感叹号 (<code>!</code>), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。<br>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。<br>对应的HTML代码：<code>&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;</code></p><pre class="line-numbers language-none"><code class="language-none">![这是图片](&#x2F;images&#x2F;learn&#x2F;markdown&#x2F;philly-magic-garden.jpg &quot;Magic Gardens&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：<br><img src="/images/learn/markdown/philly-magic-garden.jpg" alt="这是图片" title="Magic Gardens"></p><p>#链接图片<br>给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。</p><pre class="line-numbers language-none"><code class="language-none">[![沙漠中的岩石图片](&#x2F;images&#x2F;learn&#x2F;markdown&#x2F;shiprock.jpg &quot;Shiprock&quot;)](https:&#x2F;&#x2F;markdown.com.cn)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：<br><a href="https://markdown.com.cn/"><img src="/images/learn/markdown/shiprock.jpg" alt="沙漠中的岩石图片" title="Shiprock"></a></p><hr><h1 id="Markdown-转义字符语法"><a href="#Markdown-转义字符语法" class="headerlink" title="Markdown 转义字符语法"></a>Markdown 转义字符语法</h1><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><p>* Without the backslash, this would be a bullet in an unordered list.<br>渲染效果如下：</p><ul><li>Without the backslash, this would be a bullet in an unordered list.</li></ul><h2 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h2><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p><table><thead><tr><th align="center">Character</th><th align="left">Name</th></tr></thead><tbody><tr><td align="center">\</td><td align="left">backslash</td></tr><tr><td align="center">&#96;</td><td align="left">backtick (see also escaping backticks in code)</td></tr><tr><td align="center">*</td><td align="left">asterisk</td></tr><tr><td align="center">_</td><td align="left">underscore</td></tr><tr><td align="center">{ }</td><td align="left">curly braces</td></tr><tr><td align="center">[ ]</td><td align="left">brackets</td></tr><tr><td align="center">( )</td><td align="left">parentheses</td></tr><tr><td align="center">#</td><td align="left">pound sign</td></tr><tr><td align="center">+</td><td align="left">plus sign</td></tr><tr><td align="center">-</td><td align="left">minus sign (hyphen)</td></tr><tr><td align="center">.</td><td align="left">dot</td></tr><tr><td align="center">!</td><td align="left">exclamation mark</td></tr><tr><td align="center">&#124;</td><td align="left">pipe (see also escaping pipe in tables)</td></tr></tbody></table><h2 id="可替换显示的-ASCII-代码"><a href="#可替换显示的-ASCII-代码" class="headerlink" title="可替换显示的 ASCII 代码"></a>可替换显示的 ASCII 代码</h2><p><img src="/images/learn/markdown/20180826173654878.png" alt="可替换显示的 ASCII 代码"></p><h2 id="特殊字符自动转义"><a href="#特殊字符自动转义" class="headerlink" title="特殊字符自动转义"></a>特殊字符自动转义</h2><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 &lt; 和 &amp;。</p><p>&amp; 符号其实很容易让写作网页文件的人感到困扰，如果你要打「AT&amp;T」 ，你必须要写成「<code>AT&amp;amp;T」</code> ，还得转换网址内的 <code>&amp;</code> 符号，如果你要链接到：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;images.google.com&#x2F;images?num&#x3D;30&amp;q&#x3D;larry+bird<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你必须要把网址转成：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;images.google.com&#x2F;images?num&#x3D;30&amp;q&#x3D;larry+bird<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>才能放到链接标签的 href 属性里。不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p><p>Markdown 允许你直接使用这些符号，它帮你自动转义字符。如果你使用 &amp; 符号的作为 HTML 实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成 &amp;。所以你如果要在文件中插入一个著作权的符号，你可以这样写：</p><pre class="line-numbers language-none"><code class="language-none">&amp;copy;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Markdown 将不会对这段文字做修改，但是如果你这样写：</p><pre class="line-numbers language-none"><code class="language-none">AT&amp;T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Markdown 就会将它转为：</p><pre class="line-numbers language-none"><code class="language-none">AT&amp;T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类似的状况也会发生在 &lt; 符号上，因为 Markdown 支持 行内 HTML ，如果你使用 &lt; 符号作为 HTML 标签的分隔符，那 Markdown 也不会对它做任何转换，但是如果你是写：</p><pre class="line-numbers language-none"><code class="language-none">4 &lt; 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Markdown 将会把它转换为：</p><pre class="line-numbers language-none"><code class="language-none">4 &lt; 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要特别注意的是，在 Markdown 的块级元素和内联元素中， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都会被自动转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML。（在 HTML 语法中，你要手动把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体。）</p><hr><h1 id="Markdown-内嵌-HTML-标签"><a href="#Markdown-内嵌-HTML-标签" class="headerlink" title="Markdown 内嵌 HTML 标签"></a>Markdown 内嵌 HTML 标签</h1><p>对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到 Markdown 文本中即可。</p><h2 id="行级內联标签"><a href="#行级內联标签" class="headerlink" title="行级內联标签"></a>行级內联标签</h2><p>HTML 的行级內联标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。</p><p>HTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown 的语法是可以解析的。</p><pre class="line-numbers language-none"><code class="language-none">This **word** is bold. This &lt;em&gt;word&lt;&#x2F;em&gt; is italic.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下:<br>This <strong>word</strong> is bold. This <em>word</em> is italic.</p><h2 id="区块标签"><a href="#区块标签" class="headerlink" title="区块标签"></a>区块标签</h2><p>区块元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p><p>例如，在 Markdown 文件里加上一段 HTML 表格：</p><pre class="line-numbers language-none"><code class="language-none">This is a regular paragraph.&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;Foo&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>This is another regular paragraph.<br>请注意，Markdown 语法在 HTML 区块标签中将不会被进行处理。例如，你无法在 HTML 区块内使用 Markdown 形式的<code>*强调*</code>。</p><p>#HTML 用法最佳实践<br>出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。如有疑问，请查看相应 Markdown 应用程序的手册。某些应用程序只支持 HTML 标签的子集。</p><p>对于 HTML 的块级元素 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code> 和 <code>&lt;p&gt;</code>，请在其前后使用空行（blank lines）与其它内容进行分隔。尽量不要使用制表符（tabs）或空格（spaces）对 HTML 标签做缩进，否则将影响格式。</p><p>在 HTML 块级标签内不能使用 Markdown 语法。例如 <code>&lt;p&gt;italic and **bold**&lt;/p&gt;</code> 将不起作用。</p><hr><h1 id="markdown扩展语法"><a href="#markdown扩展语法" class="headerlink" title="markdown扩展语法"></a>markdown扩展语法</h1><hr><h2 id="Markdown-扩展语法入门"><a href="#Markdown-扩展语法入门" class="headerlink" title="Markdown 扩展语法入门"></a>Markdown 扩展语法入门</h2><p>John Gruber的原始设计文档中概述的基本语法主要是为了应付大多数情况下的日常所需元素，但对于某些人来说还不够，这就是扩展语法的用武之地。</p><p>一些个人和组织开始通过添加其他元素（例如表，代码块，语法突出显示，URL自动链接和脚注）来扩展基本语法。可以通过使用基于基本Markdown语法的轻量级标记语言，或通过向兼容的Markdown处理器添加扩展来启用这些元素。</p><h2 id="Markdown-扩展语法可用性"><a href="#Markdown-扩展语法可用性" class="headerlink" title="Markdown 扩展语法可用性"></a>Markdown 扩展语法可用性</h2><p>并非所有Markdown应用程序都支持扩展语法元素。您需要检查您的应用程序所使用的轻量级标记语言是否支持您要使用的扩展语法元素。如果没有，那么仍然有可能在Markdown处理器中启用扩展。</p><h3 id="轻量标记语言"><a href="#轻量标记语言" class="headerlink" title="轻量标记语言"></a>轻量标记语言</h3><p>有几种轻量级标记语言是Markdown的超集。它们包含Gruber的基本语法，并通过添加其他元素（例如表，代码块，语法突出显示，URL自动链接和脚注）在此基础上构建。许多最受欢迎的Markdown应用程序使用以下轻量级标记语言之一：</p><ul><li><a href="https://commonmark.org/">CommonMark</a></li><li><a href="https://github.github.com/gfm/">GitHub Flavored Markdown (GFM)</a></li><li><a href="https://michelf.ca/projects/php-markdown/extra/">Markdown Extra</a></li><li><a href="https://fletcherpenney.net/multimarkdown/">MultiMarkdown</a></li><li><a href="https://rmarkdown.rstudio.com/">R Markdown</a></li></ul><h3 id="Markdown-处理器"><a href="#Markdown-处理器" class="headerlink" title="Markdown 处理器"></a>Markdown 处理器</h3><p>有许多<a href="https://github.com/markdown/markdown.github.com/wiki/Implementations">Markdown处理器</a>可用。它们中的许多允许您添加启用扩展语法元素的扩展。查看您所使用处理器的文档以获取更多信息。</p><hr><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。</p><pre class="line-numbers language-none"><code class="language-none">| Syntax      | Description || ----------- | ----------- || Header      | Title       || Paragraph   | Text        |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>呈现的输出如下所示：</p><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table><p>单元格宽度可以变化，如下所示。呈现的输出将看起来相同。</p><pre class="line-numbers language-none"><code class="language-none">| Syntax | Description || --- | ----------- || Header | Title || Paragraph | Text |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Tip: 使用连字符和管道创建表可能很麻烦。为了加快该过程，请尝试使用Markdown Tables Generator。使用图形界面构建表，然后将生成的Markdown格式的文本复制到文件中。</p><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。</p><pre class="line-numbers language-none"><code class="language-none">| Syntax      | Description | Test Text     || :---        |    :----:   |          ---: || Header      | Title       | Here&#39;s this   || Paragraph   | Text        | And more      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>呈现的输出如下所示：</p><table><thead><tr><th align="left">Syntax</th><th align="center">Description</th><th align="right">Test Text</th></tr></thead><tbody><tr><td align="left">Header</td><td align="center">Title</td><td align="right">Here’s this</td></tr><tr><td align="left">Paragraph</td><td align="center">Text</td><td align="right">And more</td></tr></tbody></table><h3 id="格式化表格中的文字"><a href="#格式化表格中的文字" class="headerlink" title="格式化表格中的文字"></a>格式化表格中的文字</h3><p>您可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（&#96;）中的单词或短语，而不是代码块）和强调。</p><p>您不能添加标题，块引用，列表，水平规则，图像或HTML标签。</p><h3 id="在表中转义管道字符"><a href="#在表中转义管道字符" class="headerlink" title="在表中转义管道字符"></a>在表中转义管道字符</h3><p>您可以使用表格的HTML字符代码（<code>&amp;#124;</code>）在表中显示竖线（<code>|</code>）字符。</p><hr><h2 id="Markdown-围栏代码块"><a href="#Markdown-围栏代码块" class="headerlink" title="Markdown 围栏代码块"></a>Markdown 围栏代码块</h2><p>Markdown基本语法允许您通过将行缩进四个空格或一个制表符来创建代码块。如果发现不方便，请尝试使用受保护的代码块。根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>呈现的输出如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tip:要在代码块中显示反引号？请参阅了解如何转义它们。</p><h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>许多Markdown处理器都支持受围栏代码块的语法突出显示。使用此功能，您可以为编写代码的任何语言添加颜色突出显示。要添加语法突出显示，请在受防护的代码块之前的反引号旁边指定一种语言。</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;json&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>呈现的输出如下所示：<br>{ “firstName”: “John”, “lastName”: “Smith”, “age”: 25 }</p><hr><h2 id="Markdown-脚注"><a href="#Markdown-脚注" class="headerlink" title="Markdown 脚注"></a>Markdown 脚注</h2><p>脚注使您可以添加注释和参考，而不会使文档正文混乱。当您创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置。读者可以单击链接以跳至页面底部的脚注内容。</p><p>要创建脚注参考，请在方括号（<code>[^1]</code>）内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注参考与脚注本身相关联-在输出中，脚注按顺序编号。</p><p>在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（<code>[^1]: My footnote.</code>）。您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表之类的其他元素之外的任何位置。</p><pre class="line-numbers language-none"><code class="language-none">Here&#39;s a simple footnote,[^1] and here&#39;s a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here&#39;s one with multiple paragraphs and code.    Indent paragraphs to include them in the footnote.    &#96;&#123; my code &#125;&#96;    Add as many paragraphs as you like.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>呈现的输出如下所示：<br>Here’s a simple footnote,[^1] and here’s a longer one.[^bignote]</p><p>[^1]: This is the first footnote.</p><p>[^bignote]: Here’s one with multiple paragraphs and code.</p><pre><code>Indent paragraphs to include them in the footnote.`&#123; my code &#125;`Add as many paragraphs as you like.</code></pre><hr><h2 id="Markdown-标题编号"><a href="#Markdown-标题编号" class="headerlink" title="Markdown 标题编号"></a>Markdown 标题编号</h2><p>许多Markdown处理器支持标题的自定义ID - 一些Markdown处理器会自动添加它们。添加自定义ID允许您直接链接到标题并使用CSS对其进行修改。要添加自定义标题ID，请在与标题相同的行上用大括号括起该自定义ID。</p><pre class="line-numbers language-none"><code class="language-none">### My Great Heading &#123;#custom-id&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>HTML看起来像这样：</p><pre class="line-numbers language-none"><code class="language-none">&lt;h3 id&#x3D;&quot;custom-id&quot;&gt;My Great Heading&lt;&#x2F;h3&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="链接到标题ID-headid"><a href="#链接到标题ID-headid" class="headerlink" title="链接到标题ID (#headid)"></a>链接到标题ID (#headid)</h3><p>通过创建带有数字符号（<code>#</code>）和自定义标题ID的<code>[标准链接]((/basic-syntax/links.html)</code>，可以链接到文件中具有自定义ID的标题。</p><table><thead><tr><th align="left">Markdown</th><th align="left">HTML</th><th align="left">预览效果</th></tr></thead><tbody><tr><td align="left"><code>[Heading IDs](#heading-ids)</code></td><td align="left"><code>&lt;a href=&quot;#heading-ids&quot;&gt;Heading IDs&lt;/a&gt;</code></td><td align="left">Heading IDs</td></tr></tbody></table><p>其他网站可以通过将自定义标题ID添加到网页的完整URL（例如<code>[Heading IDs](https://markdown.com.cn/extended-syntax/heading-ids.html#headid</code>)）来链接到标题。</p><hr><h2 id="Markdown-定义列表"><a href="#Markdown-定义列表" class="headerlink" title="Markdown 定义列表"></a>Markdown 定义列表</h2><p>一些Markdown处理器允许您创建术语及其对应定义的定义列表。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</p><pre class="line-numbers language-none"><code class="language-none">First Term: This is the definition of the first term.Second Term: This is one definition of the second term.: This is another definition of the second term.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HTML看起来像这样：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;  &lt;dt&gt;First Term&lt;&#x2F;dt&gt;  &lt;dd&gt;This is the definition of the first term.&lt;&#x2F;dd&gt;  &lt;dt&gt;Second Term&lt;&#x2F;dt&gt;  &lt;dd&gt;This is one definition of the second term. &lt;&#x2F;dd&gt;  &lt;dd&gt;This is another definition of the second term.&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><dl><dt>呈现的输出如下所示：<br>First Term</dt><dd>This is the definition of the first term.</dd></dl><dl><dt>Second Term<br>: This is one definition of the second term.</dt><dd>This is another definition of the second term.</dd></dl><hr><h2 id="markdown-删除线"><a href="#markdown-删除线" class="headerlink" title="markdown 删除线"></a>markdown 删除线</h2><p>您可以通过在单词中心放置一条水平线来删除单词。结果看起来像这样。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号~~。</p><pre class="line-numbers language-none"><code class="language-none">~~世界是平坦的。~~ 我们现在知道世界是圆的。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>呈现的输出如下所示：<br><del>世界是平坦的。</del> 我们现在知道世界是圆的。</p><hr><h2 id="Markdown-任务列表语法"><a href="#Markdown-任务列表语法" class="headerlink" title="Markdown 任务列表语法"></a>Markdown 任务列表语法</h2><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。</p><pre class="line-numbers language-none"><code class="language-none">- [x] Write the press release- [ ] Update the website- [ ] Contact the media<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>呈现的输出如下所示：</p><ul><li><input checked="" disabled="" type="checkbox"> Write the press release</li><li><input disabled="" type="checkbox"> Update the website</li><li><input disabled="" type="checkbox"> Contact the media</li></ul><hr><h2 id="Markdown-使用-Emoji-表情"><a href="#Markdown-使用-Emoji-表情" class="headerlink" title="Markdown 使用 Emoji 表情"></a>Markdown 使用 Emoji 表情</h2><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入emoji shortcodes。</p><h3 id="复制和粘贴表情符号"><a href="#复制和粘贴表情符号" class="headerlink" title="复制和粘贴表情符号"></a>复制和粘贴表情符号</h3><p>在大多数情况下，您可以简单地从Emojipedia 等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。</p><p>Tip: 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8。.</p><h3 id="使用表情符号简码"><a href="#使用表情符号简码" class="headerlink" title="使用表情符号简码"></a>使用表情符号简码</h3><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p><pre class="line-numbers language-none"><code class="language-none">去露营了！ :tent: 很快回来。真好笑！ :joy:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>呈现的输出如下所示：<br>去露营了！ :tent: 很快回来。</p><p>真好笑！ :joy:</p><p>Note: 注意：您可以使用此表情符号简码列表，但请记住，表情符号简码因应用程序而异。有关更多信息，请参阅Markdown应用程序的文档。</p><hr><h2 id="自动网址链接"><a href="#自动网址链接" class="headerlink" title="自动网址链接"></a>自动网址链接</h2><p>许多Markdown处理器会自动将URL转换为链接。这意味着如果您输入<a href="http://www.example.com,即使您未使用方括号,您的markdown处理器也会自动将其转换为链接./">http://www.example.com，即使您未使用方括号，您的Markdown处理器也会自动将其转换为链接。</a></p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>呈现的输出如下所示：<br><a href="http://www.example.com/">http://www.example.com</a></p><h3 id="禁用自动URL链接"><a href="#禁用自动URL链接" class="headerlink" title="禁用自动URL链接"></a>禁用自动URL链接</h3><p>如果您不希望自动链接URL，则可以通过将URL表示为带反引号的代码来删除该链接。</p><pre class="line-numbers language-none"><code class="language-none">&#96;http:&#x2F;&#x2F;www.example.com&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>呈现的输出如下所示：<br><code>http://www.example.com</code></p><h1 id="MarkDown-工具"><a href="#MarkDown-工具" class="headerlink" title="MarkDown 工具"></a>MarkDown 工具</h1><p><a href="https://devtool.tech/html-md">HTML/URL To Markdown</a><br><a href="https://convertio.co/zh/webp-gif/">WEBP到GIF转换器</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客</title>
      <link href="/20230508/hexo_base/hexo.html"/>
      <url>/20230508/hexo_base/hexo.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>hexo官网: <a href="http://hexo.io/">http://hexo.io</a><br>hexo文档: <a href="https://hexo.io/zh-cn/docs">https://hexo.io/zh-cn/docs</a><br>github: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a><br>&lt;!- more -&gt;</p><h2 id="hexo优势"><a href="#hexo优势" class="headerlink" title="hexo优势"></a>hexo优势</h2><p>由于github pages存放的都是静态文件，hexo所做的就是将md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。<br>hexo具有以下特点：</p><h3 id="超快速度："><a href="#超快速度：" class="headerlink" title="超快速度："></a>超快速度：</h3><p>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染<br>支持 Markdown：Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件</p><h3 id="一键部署："><a href="#一键部署：" class="headerlink" title="一键部署："></a>一键部署：</h3><p>只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p><h3 id="丰富的插件："><a href="#丰富的插件：" class="headerlink" title="丰富的插件："></a>丰富的插件：</h3><p>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><p>Node.js (Node.js 版本需不低于 8.6，建议使用 Node.js 10.0 及以上版本)<br>Git<br>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-cli -ghexo init npm installhexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果您的电脑中尚未安装所需要的程序，请根据hexo官网安装指示完成安装:<a href="https://hexo.io/zh-cn/docs/%E3%80%82">https://hexo.io/zh-cn/docs/。</a></p><h2 id="hexo指令"><a href="#hexo指令" class="headerlink" title="hexo指令"></a>hexo指令</h2><p>配置好之后，hexo就可以使用了，常用的hexo命令可访问hexo指令。</p><pre class="line-numbers language-none"><code class="language-none">hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #部署到GitHubhexo help  # 查看帮助hexo version  #查看Hexo的版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缩写形式：</p><pre class="line-numbers language-none"><code class="language-none">hexo n &#x3D;&#x3D; hexo newhexo g &#x3D;&#x3D; hexo generatehexo s &#x3D;&#x3D; hexo serverhexo d &#x3D;&#x3D; hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>组合命令</p><pre class="line-numbers language-none"><code class="language-none">hexo s -g #生成并本地预览hexo d -g #生成并上传<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p>GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。</p><h2 id="Github简介"><a href="#Github简介" class="headerlink" title="Github简介"></a>Github简介</h2><p>作为开源代码库以及版本控制系统，Github拥有超过900万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。<br>如前所述，作为一个分布式的版本控制系统，在Git中并不存在主库这样的概念，每一份复制出的库都可以独立使用，任何两个库之间的不一致之处都可以进行合并。</p><h2 id="清空Github仓库内容"><a href="#清空Github仓库内容" class="headerlink" title="清空Github仓库内容"></a>清空Github仓库内容</h2><p>如果想要清空github仓库中的内容，可以先创建分支，然后清空本地master中的文件，保留.git和readme.md，清空后git到远程仓库中，可参考Github清空远程仓库。</p><h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><pre class="line-numbers language-none"><code class="language-none">$ cd ~&#x2F;. ssh #检查本机已存在的ssh密钥<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果提示：No such file or directory 说明你是第一次使用git。</p><pre class="line-numbers language-none"><code class="language-none">ssh-keygen -t rsa -C &quot;邮件地址&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到 .ssh\id_rsa.pub 文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：<br>测试是否成功</p><pre class="line-numbers language-none"><code class="language-none">ssh -T git@github.com # 注意邮箱地址不用改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看到如下提示，说明配置成功。<br>You’ve successfully authenticated, but GitHub does not provide shell access.<br>此时你还需要配置：</p><pre class="line-numbers language-none"><code class="language-none">$ git config --global user.name &quot;liuxianan&quot;&#x2F;&#x2F; 你的github用户名，非昵称$ git config --global user.email  &quot;xxx@qq.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参考：使用hexo+github搭建免费个人博客详细教程<br>Deploy到github中<br>修改站点配置文件(_config.yml)，修改 depoly ：</p><pre class="line-numbers language-none"><code class="language-none">deploy:  type: git   repo: git@github.com:username&#x2F;username.github.io.git &#x2F;&#x2F;替换成自己的邮箱  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果不行，安装插件：</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h1 id="Hexo-定制"><a href="#Hexo-定制" class="headerlink" title="Hexo 定制"></a>Hexo 定制</h1><hr><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>hexo的主题非常之多，可以从官网的主题中自由选择。这里以next主题为例。<br>主题的下载可以通过git到hexo/theme或者直接download zip然后解压到hexo/theme文件夹。<br>在站点配置文件(_config.yml)中查找theme，<br>然后将landscape修改为next或者hexo-theme-next，具体以theme中文件夹名称为主。<br>hexo d -g后hexo s并刷新网页，可以看到主题已经更换成了next。</p><p>Next主题修改<br>语言修改<br>在站点文件_config.yml中查找language并将en修改为简体中文（zh-CN）：</p><pre class="line-numbers language-none"><code class="language-none">title: 明明如月subtitle:description:keywords:author: sunfovelanguage: zh-CN &#x2F;&#x2F;语言名称要写对timezone:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意更改的语言名称要写对，具体查看主题文件夹下的language文件夹中的名称。</p><p>新建带日期格式的博文<br>使用hexo new post “博文名称”生成的博文以博文名称生成文件，当文件太多时不便于管理查看，生成yyyy-MM-dd-博文名称的名称有助于我们管理自己的博文。<br>在站点文件_config.yml中设置博客生成名称:</p><pre class="line-numbers language-none"><code class="language-none"># Writingnew_post_name: :year-:month-:day-:title.md # File name of new posts <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重新执行hexo new post “博文名称”命令，就可以生成yyyy-MM-dd-博文名称.md类型的名称了。</p><h2 id="侧栏头像"><a href="#侧栏头像" class="headerlink" title="侧栏头像"></a>侧栏头像</h2><p>在主题文件_config.yml中搜索：</p><pre class="line-numbers language-none"><code class="language-none">avatar:  # In theme directory (source&#x2F;images): &#x2F;images&#x2F;avatar.gif  # In site directory (source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif  # You can also use other linking images.  url: #&#x2F;images&#x2F;avatar.gif  # If true, the avatar would be dispalyed in circle.  rounded: false  # If true, the avatar would be rotated with the cursor.  rotated: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在url处添加头像路径，本地图片放到主题文件夹下的source/image中，rounded为是否用圆形头像， rotated为是否旋转头像。</p><h2 id="添加标签和分类"><a href="#添加标签和分类" class="headerlink" title="添加标签和分类"></a>添加标签和分类</h2><p>添加一个 分类 页面，并在菜单中显示页面链接。<br>新建一个页面，命名为 categories 。命令如下：</p><pre class="line-numbers language-none"><code class="language-none">hexo new page categories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。</p><pre class="line-numbers language-none"><code class="language-none">title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments并将值设置为 false，如：</p><pre class="line-numbers language-none"><code class="language-none">title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot;comments: false---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在菜单中添加链接。编辑主题的_config.yml ，将 menu 中的 categories: /categories注释去掉，如下:</p><pre class="line-numbers language-none"><code class="language-none">menu:  home: &#x2F;  categories: &#x2F;categories  archives: &#x2F;archives  tags: &#x2F;tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加标签和这个操作类似，将categories换成tags即可。</p><p>参考：创建分类界面</p><h2 id="对文章进行加密"><a href="#对文章进行加密" class="headerlink" title="对文章进行加密"></a>对文章进行加密</h2><p>打开hemes\hexo-theme-next\layout_partials\head\head.swig，在文件的开头位置找到如下代码</p><pre class="line-numbers language-none"><code class="language-none">&lt;meta charset&#x3D;&quot;UTF-8&quot;&#x2F;&gt;&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1&quot;&#x2F;&gt;&lt;meta name&#x3D;&quot;theme-color&quot; content&#x3D;&quot;&#123;&#123; theme.android_chrome_color &#125;&#125;&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在上边代码的末尾添加如下代码：</p><pre class="line-numbers language-none"><code class="language-none">&lt;script&gt;    (function()&#123;        if(&#39;&#123;&#123; page.password &#125;&#125;&#39;)&#123;            if (prompt(&#39;请输入文章密码&#39;) !&#x3D;&#x3D; &#39;&#123;&#123; page.password &#125;&#125;&#39;)&#123;                alert(&#39;密码错误！&#39;);if (history.length &#x3D;&#x3D;&#x3D; 1) &#123;    window.opener &#x3D; null;    window.open(&#39;&#39;, &#39;_self&#39;);    window.close();                &#125; else &#123;                    history.back();                &#125;            &#125;        &#125;    &#125;)();&lt;&#x2F;script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加完脚本代码，接下来在想要加密的文章的文件头加上password 属性就行了，如下：</p><pre class="line-numbers language-none"><code class="language-none">---title: XXXdate: XXXtags:  - XXXcategories:  - XXXpassword: 123---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样在打开这篇文章时只有输入了123这个密码才可以打开成功。<br>参考：NexT主题个性化 - 对文章进行加密</p><h2 id="Hexo-admin编辑博客"><a href="#Hexo-admin编辑博客" class="headerlink" title="Hexo admin编辑博客"></a>Hexo admin编辑博客</h2><p>如果自己编辑 MD 文件的话，确实比较麻烦，你可以用一些 MD 的编辑器，但是在管理 MD 文件上还是操作不方便。<br>这里推荐使用 hexo-admin，而且编辑完之后可以马上看到效果呢。<br>需要说明的是，hexo-admin 管理是本地用的，就是你需要在本地编辑完之后再上传到 github，而不能直接在线编辑保存，因为 github pages 只支持静态页面的。<br>安装过程：</p><pre class="line-numbers language-none"><code class="language-none">npm install --save hexo-admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 hexo-admin 你可以<br>Pages - 新加 page；<br>Posts - 新加或删除 post；双击一个 post，你可以编辑，预览，新增修改 tags、categories，选择发布或不发布；<br>Settings - 一些配置；<br>Deploy - 可以直接部署到 github。<br>参考：hexo-admin安装使用<br>注：按照这个方案配置hexo-admin后，会出现如下警告，但不太影响使用。</p><pre class="line-numbers language-none"><code class="language-none">hexo s -g(node:12084) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.INFO  Start processingINFO  Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后，可以进行认证，详见：【hexo】安装并配置admin插件。<br>这样登录admin就需要账号密码验证。</p><h2 id="阅读全文"><a href="#阅读全文" class="headerlink" title="阅读全文"></a>阅读全文</h2><p>推荐使用&lt; !–more–&gt; 进行手动截断，网上有很多教程自动截断，但文中包含中文和一些特殊符号的时候，判断可能会失效。自动截断教程可参考：Hexo-设置阅读全文。</p><h2 id="修改标签样式"><a href="#修改标签样式" class="headerlink" title="修改标签样式"></a>修改标签样式</h2><p>修改模板 \themes\hexo-theme-next\layout_macro/post.swig，搜索，将 #换成<i class="fa fa-tag"></i></p><h2 id="修改布局模板"><a href="#修改布局模板" class="headerlink" title="修改布局模板"></a>修改布局模板</h2><p>layout 布局模板放在 scaffolds/目录下，文件名称就是layout 名称。每次新建时，Hexo 会尝试在 scaffolds 文件夹中寻找同名文件，并根据其内容建立文章。所以可以在这里添加自己的 layout，作为常用的新建模板使用。同时你也可以编辑现有的 layout，比如 post 的 layout 默认是 scaffolds\post.md。</p><p>这里有一份文章配置信息，可以根据情况修改后作为模板复用，或直接在保存文章的路径新建.md文件中使用：</p><pre class="line-numbers language-none"><code class="language-none">---title:   #文章名date:   #发表日期updated:   #更新日期categories:   #文章分类tags:   #文章标签，多标签时使用英文逗号隔开photos:  #如果使用Fancybox（文章头部展示图片），如此设置- URL1- URL2---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：Hexo 使用指导</p><h2 id="切换主题风格"><a href="#切换主题风格" class="headerlink" title="切换主题风格"></a>切换主题风格</h2><p>在主题文件_config.yml中查找schemes</p><pre class="line-numbers language-none"><code class="language-none"># Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4种风格大同小异，你们可以选择自己喜欢的风格。</p><p>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白<br>Mist - Muse 的紧凑版本，整洁有序的单栏外观<br>Pisces - 双栏 Scheme，小家碧玉似的清新<br>Gemini - 类似Pisces<br>配置浏览进度<br>在主题文件_config.yml中查找scrollpercent，将false改为true。</p><p>本地搜索<br>安装插件</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改 站点配置 文件:</p><pre class="line-numbers language-none"><code class="language-none">search:  path: search.xml  field: post  content: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>path - file path. By default is search.xml . If the file extension is .json, the output format will be JSON. Otherwise XML format file will be exported.<br>field - the search scope you want to search, you can chose:<br>post (Default) - will only covers all the posts of your blog.<br>page - will only covers all the pages of your blog.<br>all - will covers all the posts and pages of your blog.<br>content - whether contains the whole content of each article. If false, the generated results only cover title and other meta info without mainbody. By default is true.<br>参考：hexo-generator-search</p><p>注：之前只能搜索标题，不能搜索内容，可能是与local admin冲突，去掉admin后，可以正常使用了。后面发现好像是之前post的一个文件格式有问题，加了URL 1和URL 2导致没法搜索。并不是，烦。但是已经不报错了。<br>最后不清楚到底为啥，并不能搜索全文，无论修改成post还是all，都不行。最后在github上找到了一个解决方案，完美解决，感谢。<br>经验证，仅仅采用第二种方案还是不行，必须要同时安装两个插件才可以。<br>使用hexo-generator-search-zip</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-generator-search-zip --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置说明：修改站点文件</p><pre class="line-numbers language-none"><code class="language-none">search:  path: search.json  zipPath: search.zip  versionPath: searchVersion.txt  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中field有以下可选，</p><ul><li>post (Default) - will only covers all the posts of your blog.</li><li>page - will only covers all the pages of your blog.</li><li>all - will covers all the posts and pages of your blog.</li></ul><p>参考：hexo-generator-search-zip</p><p>SiteMap插件<br>hexo-generator-sitemap：生成易于搜索引擎搜素的网站地图</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-generator-sitemap --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加配置信息：</p><pre class="line-numbers language-none"><code class="language-none">#feedatom:  type: atom  path: atom.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可以在主题配置文件中添加相关配置，可以在页面上显示。<br>比如，添加链接信息</p><pre class="line-numbers language-none"><code class="language-none">links:  Feed: &#x2F;atom.xml  SiteMap: &#x2F;sitemap.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参考：手把手教从零开始在GitHub上使用Hexo搭建博客教程(二)-Hexo参数设置</p><p>注：有点问题，给关了。</p><p>设置菜单及对应页面<br>在主题配置文件中查找menu：</p><pre class="line-numbers language-none"><code class="language-none">menu:  home: &#x2F; || home  #about: &#x2F;about&#x2F; || user  tags: &#x2F;tags&#x2F; || tags  categories: &#x2F;categories&#x2F; || th  archives: &#x2F;archives&#x2F; || archive  #schedule: &#x2F;schedule&#x2F; || calendar  #sitemap: &#x2F;sitemap.xml || sitemap  #commonweal: &#x2F;404&#x2F; || heartbeat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>去掉#注释即可显示对应的菜单项，也可自定义新的菜单项。 ||之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。</p><p>新添加的菜单需要翻译对应的中文<br>打开hexo/theme/next/languages/zh-CN.yml，在menu下自定义，如：</p><pre class="line-numbers language-none"><code class="language-none">menu:  resources: 资源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>hexo new page “categories”<br>此时在根目录的source文件夹下会生成一个categories文件，文件中有一个index.md文件，修改内容如下</p><pre class="line-numbers language-none"><code class="language-none">---title: 分类date: 2017-12-14 13:05:38type: &quot;categories&quot;comments: false---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。</p><p>参考：Hexo框架下用NexT(v7.0+)主题美化博客</p><p>网站图标设置<br>图标可以从图标素材网站：iconfont、easyicon上进行下载。<br>下载16x16以及32x32大小的PNG格式图标，置于/themes/next/source/images/下<br>打开themes/next/下的_config.yml，查找favicon</p><pre class="line-numbers language-none"><code class="language-none">favicon:  small: &#x2F;images&#x2F;favicon-16x16-next.png  medium: &#x2F;images&#x2F;favicon-32x32-next.png  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png  safari_pinned_tab: &#x2F;images&#x2F;logo.svg  #android_manifest: &#x2F;images&#x2F;manifest.json  #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改small和medium的路径为下载的图标路径</p><p>参考：Hexo框架下用NexT(v7.0+)主题美化博客</p><p>设定站点建立时间<br>打开themes/next/下的_config.yml，查找since</p><pre class="line-numbers language-none"><code class="language-none">footer:  # Specify the date when the site was setup.  # If not defined, current year will be used.  #since: 2019<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果不设置，默认显示当前年份。</p><p>参考：Hexo框架下用NexT(v7.0+)主题美化博客</p><p>修改侧栏颜色<br>打开\themes\hexo-theme-next\source\css_schemes\Pisces中的_menu.styl文件，查找background：</p><pre class="line-numbers language-none"><code class="language-none">.menu-item-active a &#123;  background: #f9f9f9;  border-bottom-color: white;  $badges &#x3D; hexo-config(&#39;menu_settings.badges&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将f9f9f9修改成自己想要的颜色，可从encycolorpedia上查看颜色。</p><p>创建同名文件夹<br>新建文章时，在相同目录下创建同名文件夹（便于图片管理）：<br>打开站点配置文件_config.yml，搜索post_asset_folder字段，设置其值为true<br>安装hexo-asset-image：</p><pre class="line-numbers language-none"><code class="language-none">npm install hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时hexo new “fileName”会在/source/_posts目录下创建同名的文件夹<br>只需在 md 文件里使用 [图片上传失败…(image-a6bdde-1570251308276)] ，无需路径名就可以插入图片。</p><p>设置博客透明度<br>在\themes\hexo-theme-next\source\css_schemes\Pisces_layout.styl文件中，查找.content，修改background：</p><pre class="line-numbers language-none"><code class="language-none">.content-wrap &#123;  background: rgba(255, 255, 255, 0.8);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>rgba中最后一个参数表示透明度。</p><p>图片点击放大<br>图片可点击放大查看，放大后可关闭。打开站点配置文件_config.yml，搜索fancybox字段，设置其值为true<br>进入到theme/text/文件夹下，打开<code>git bash</code>。</p><p>博客访问量统计<br>打开主题配置文件_config.yml，查找busuanzi：</p><pre class="line-numbers language-none"><code class="language-none">busuanzi_count:  enable: false  total_visitors: true  total_visitors_icon: user  total_views: true  total_views_icon: eye  post_views: true  post_views_icon: eye<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>false改为true即可。</p><p>修改powered标识<br>修改文末的“由 Hexo 强力驱动”，theme版本标志：</p><pre class="line-numbers language-none"><code class="language-none">  # If not defined, &#96;author&#96; from Hexo &#96;_config.yml&#96; will be used.  copyright:  powered:    # Hexo link (Powered by Hexo).    enable: true    # Version info of Hexo after Hexo link (vX.X.X).    version: truetheme:    # Theme &amp; scheme info link (Theme - NexT.scheme).    enable: true    # Version info of NexT after scheme info (vX.X.X).    version: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>false改为true即可。</p><h2 id="统计字数"><a href="#统计字数" class="headerlink" title="统计字数"></a>统计字数</h2><p>使用hexo-symbols-count-time. Symbols count and time to read of articles.Better than hexo-reading-time and faster than hexo-worcount. No external dependencies.安装：</p><pre class="line-numbers language-none"><code class="language-none">$ npm install hexo-symbols-count-time --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在站点配置文件中添加：</p><pre class="line-numbers language-none"><code class="language-none">symbols_count_time:  symbols: true  time: true  total_symbols: true  total_time: true  exclude_codeblock: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在主题配置文件中修改：</p><pre class="line-numbers language-none"><code class="language-none">symbols_count_time:  separated_meta: true  item_text_post: true  item_text_total: false  awl: 4  wpm: 275  suffix: mins.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://github.com/theme-next/hexo-symbols-count-time">https://github.com/theme-next/hexo-symbols-count-time</a></p><p>社交账号</p><pre class="line-numbers language-none"><code class="language-none">Usage: Key: permalink || iconKey is the link label showing to end users. Value before || delimiter is the target permalink. Value after || delimiter is the name of Font Awesome icon. If icon (with or without delimiter) is not specified, globe icon will be loaded.social:  GitHub: https:&#x2F;&#x2F;github.com&#x2F;sunfove || github  E-Mail: mailto:sunfove@gmail.com || envelope  #Weibo: https:&#x2F;&#x2F;weibo.com&#x2F;yourname || weibo  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || google  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || twitter  #FB Page: https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname || facebook  #VK Group: https:&#x2F;&#x2F;vk.com&#x2F;yourname || vk  #StackOverflow: https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname || stack-overflow  #YouTube: https:&#x2F;&#x2F;youtube.com&#x2F;yourname || youtube  #Instagram: https:&#x2F;&#x2F;instagram.com&#x2F;yourname || instagram  #Skype: skype:yourname?call|chat || skype<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><p>Blog rolls：</p><pre class="line-numbers language-none"><code class="language-none">links_settings:  icon: link  title: 友情链接  # Available values: block | inline  layout: blocklinks:  我的简书: https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;39e329082972<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><p>评论系统采用了Valine和Leancloud结合，先在Leancloud申请账号，并创建应用</p><p>进入应用设置，在安全中心绑定域名，然后在应用keys中读取AppID和AppKey，进入主题配置文件中，查找valine，然后按照如下形式填写ID和Key。</p><pre class="line-numbers language-none"><code class="language-none">valine:  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version  appid:  # Your leancloud application appid  appkey:  # Your leancloud application appkey  notify: false # Mail notifier. See: https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki  verify: false # Verification code  placeholder: 说两句吧 # Comment box placeholder  avatar: monsterid # Gravatar style  guest_info: nick,mail,link # Custom comment header  pageSize: 10 # Pagination size  language: # Language, available values: en, zh-cn  visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&#39; for counter compatibility. Article reading statistic https:&#x2F;&#x2F;valine.js.org&#x2F;visitor.html  comment_count: true # If false, comment count will only be displayed in post page, not in home page  #post_meta_order: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中Valine 的 avatar 参数用来设置评论头像，avatar 参数可选值如下:<br><img src="/images/learn/hexo/9a433736810c61c7f57a04294cca22da.png" alt="avatar parames"></p><h2 id="匿名聊天"><a href="#匿名聊天" class="headerlink" title="匿名聊天"></a>匿名聊天</h2><p>按照网上的说明配置Daovoice一直出现问题，后来使用了chatra，十天试用期，之后又尝试了tidio，以下是tidio配置说明。</p><pre class="line-numbers language-none"><code class="language-none">tidio:  enable: true  key:  # Public Key, get it from dashboard. See: https:&#x2F;&#x2F;www.tidiochat.com&#x2F;panel&#x2F;settings&#x2F;developer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>id通过在tidio官网注册账号，然后输入中developer中找到public key，输入即可。但是加载速度似乎特别慢，可能因为服务器在国外的缘故。</p><h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><p>添加打赏。在主题文件中查找reward：</p><pre class="line-numbers language-none"><code class="language-none"> reward_settings:  # If true, reward would be displayed in every article by default.  # You can show or hide reward in a specific article throuth &#96;reward: true | false&#96; in Front-matter.  enable: true  animation: true  #comment: Donate comment here.reward:  #wechatpay: &#x2F;images&#x2F;wechatpay.png  #alipay: &#x2F;images&#x2F;alipay.png  #bitcoin: &#x2F;images&#x2F;bitcoin.png<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="百度SEO"><a href="#百度SEO" class="headerlink" title="百度SEO"></a>百度SEO</h2><p>在主题配置工具中，查找baidu_push并更改为true：</p><pre class="line-numbers language-none"><code class="language-none"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO.baidu_push: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h2><p>在百度统计中注册账号并获取app_id，然后在主题配置文件中查找Baidu Analytics，粘贴到对应位置。</p><pre class="line-numbers language-none"><code class="language-none"># Baidu Analyticsbaidu_analytics:  # &lt;app_id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>在Hexo生成首页HTML时，将top值高的文章排在前面，达到置顶功能。<br>修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js，在生成文章之前进行文章top值排序。<br>需添加的代码：</p><pre class="line-numbers language-none"><code class="language-none">posts.data &#x3D; posts.data.sort(function(a, b) &#123;    if(a.top &amp;&amp; b.top) &#123; &#x2F;&#x2F; 两篇文章top都有定义        if(a.top &#x3D;&#x3D; b.top) return b.date - a.date; &#x2F;&#x2F; 若top值一样则按照文章日期降序排        else return b.top - a.top; &#x2F;&#x2F; 否则按照top值降序排    &#125;    else if(a.top &amp;&amp; !b.top) &#123; &#x2F;&#x2F; 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）        return -1;    &#125;    else if(!a.top &amp;&amp; b.top) &#123;        return 1;    &#125;    else return b.date - a.date; &#x2F;&#x2F; 都没定义按照文章日期降序排&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改完成后，只需要在front-matter中设置需要置顶文章的top值，将会根据top值大小来选择置顶顺序top值越大越靠前。需要注意的是，这个文件不是主题的一部分，也不是Git管理的，备份的时候比较容易忽略。<br>以下是最终的generator.js内容</p><pre class="line-numbers language-none"><code class="language-none">&#39;use strict&#39;;var pagination &#x3D; require(&#39;hexo-pagination&#39;);module.exports &#x3D; function(locals)&#123;  var config &#x3D; this.config;  var posts &#x3D; locals.posts;    posts.data &#x3D; posts.data.sort(function(a, b) &#123;        if(a.top &amp;&amp; b.top) &#123;            if(a.top &#x3D;&#x3D; b.top) return b.date - a.date;            else return b.top - a.top;        &#125;        else if(a.top &amp;&amp; !b.top) &#123;            return -1;        &#125;        else if(!a.top &amp;&amp; b.top) &#123;            return 1;        &#125;        else return b.date - a.date;    &#125;);  var paginationDir &#x3D; config.pagination_dir || &#39;page&#39;;  return pagination(&#39;&#39;, posts, &#123;    perPage: config.index_generator.per_page,    layout: [&#39;index&#39;, &#39;archive&#39;],    format: paginationDir + &#39;&#x2F;%d&#x2F;&#39;,    data: &#123;      __index: true    &#125;  &#125;);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="设置置顶标志"><a href="#设置置顶标志" class="headerlink" title="设置置顶标志"></a>设置置顶标志</h2><p>打开：/blog/themes/next/layout/_macro 目录下的post.swig文件，定位到</p><p>标签下，插入如下代码：</p><pre class="line-numbers language-none"><code class="language-none">&#123;% if post.top %&#125;  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;&#123;% endif %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我没有修改color而是修改了font size = 2，使得和其他字体大小统一。</p><p>参考：Hexo博客添加文章置顶功能<br>hexo博客优化之文章置顶+置顶标签</p><pre class="line-numbers language-none"><code class="language-none">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;sunfove&#x2F;article&#x2F;details&#x2F;111105635<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
